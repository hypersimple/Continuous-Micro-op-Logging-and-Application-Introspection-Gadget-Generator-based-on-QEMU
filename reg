arm-semi.c:    TaskState *ts = env->opaque;
arm-semi.c:        env->regs[0] = ret;
arm-semi.c:        switch (env->regs[0]) {
arm-semi.c:            env->regs[0] = arm_semi_syscall_len - ret;
arm-semi.c:            env->regs[0] = 0;
arm-semi.c:            env->regs[0] = ret;
arm-semi.c:    cpu_memory_rw_debug(env, env->regs[13]-64+32, (uint8_t *)&size, 4, 0);
arm-semi.c:    env->regs[0] = be32_to_cpu(size);
arm-semi.c:    ((TaskState *)env->opaque)->swi_errno = err;
arm-semi.c:    TaskState *ts = env->opaque;
arm-semi.c:    nr = env->regs[0];
arm-semi.c:    args = env->regs[1];
arm-semi.c:            return env->regs[0];
arm-semi.c:            return env->regs[0];
arm-semi.c:                return env->regs[0];
arm-semi.c:            ret = env->regs[0];
arm-semi.c:            return env->regs[0];
arm-semi.c:            return env->regs[0];
arm-semi.c:            return env->regs[0];
arm-semi.c:            return env->regs[0];
arm-semi.c:			   ARG(0), env->regs[13]-64);
arm-semi.c:            return env->regs[0];
arm-semi.c:            ret = env->regs[0];
arm-semi.c:            return env->regs[0];
arm-semi.c:            return env->regs[0];
bsd-user/elfload.c:    int family = (thread_env->cpuid_version >> 8) & 0xff;
bsd-user/elfload.c:  return thread_env->cpuid_features;
bsd-user/main.c:                abi_ulong params = (abi_ulong) env->regs[R_ESP] +
bsd-user/main.c:                int32_t syscall_nr = env->regs[R_EAX];
bsd-user/main.c:                env->regs[R_EAX] = do_freebsd_syscall(env,
bsd-user/main.c:                env->regs[R_EAX] = do_openbsd_syscall(env,
bsd-user/main.c:                                                      env->regs[R_EAX],
bsd-user/main.c:                                                      env->regs[R_EBX],
bsd-user/main.c:                                                      env->regs[R_ECX],
bsd-user/main.c:                                                      env->regs[R_EDX],
bsd-user/main.c:                                                      env->regs[R_ESI],
bsd-user/main.c:                                                      env->regs[R_EDI],
bsd-user/main.c:                                                      env->regs[R_EBP]);
bsd-user/main.c:            if (((abi_ulong)env->regs[R_EAX]) >= (abi_ulong)(-515)) {
bsd-user/main.c:                env->regs[R_EAX] = -env->regs[R_EAX];
bsd-user/main.c:                env->eflags |= CC_C;
bsd-user/main.c:                env->eflags &= ~CC_C;
bsd-user/main.c:                env->regs[R_EAX] = do_freebsd_syscall(env,
bsd-user/main.c:                                                      env->regs[R_EAX],
bsd-user/main.c:                                                      env->regs[R_EDI],
bsd-user/main.c:                                                      env->regs[R_ESI],
bsd-user/main.c:                                                      env->regs[R_EDX],
bsd-user/main.c:                                                      env->regs[R_ECX],
bsd-user/main.c:                                                      env->regs[8],
bsd-user/main.c:                                                      env->regs[9], 0, 0);
bsd-user/main.c:                env->regs[R_EAX] = do_openbsd_syscall(env,
bsd-user/main.c:                                                      env->regs[R_EAX],
bsd-user/main.c:                                                      env->regs[R_EDI],
bsd-user/main.c:                                                      env->regs[R_ESI],
bsd-user/main.c:                                                      env->regs[R_EDX],
bsd-user/main.c:                                                      env->regs[10],
bsd-user/main.c:                                                      env->regs[8],
bsd-user/main.c:                                                      env->regs[9]);
bsd-user/main.c:            env->eip = env->exception_next_eip;
bsd-user/main.c:            if (((abi_ulong)env->regs[R_EAX]) >= (abi_ulong)(-515)) {
bsd-user/main.c:                env->regs[R_EAX] = -env->regs[R_EAX];
bsd-user/main.c:                env->eflags |= CC_C;
bsd-user/main.c:                env->eflags &= ~CC_C;
bsd-user/main.c:            if (env->eflags & VM_MASK) {
bsd-user/main.c:            if (!(env->error_code & 1))
bsd-user/main.c:            info._sifields._sigfault._addr = env->cr[2];
bsd-user/main.c:            if (env->eflags & VM_MASK) {
bsd-user/main.c:                info._sifields._sigfault._addr = env->eip;
bsd-user/main.c:            if (env->eflags & VM_MASK) {
bsd-user/main.c:                    info._sifields._sigfault._addr = env->eip;
bsd-user/main.c:            if (env->eflags & VM_MASK) {
bsd-user/main.c:            info._sifields._sigfault._addr = env->eip;
bsd-user/main.c:            pc = env->segs[R_CS].base + env->eip;
bsd-user/main.c:    index = (index + cwp * 16) % (16 * env->nwindows);
bsd-user/main.c:    if (index < 8 && env->cwp == env->nwindows - 1)
bsd-user/main.c:        index += 16 * env->nwindows;
bsd-user/main.c:    sp_ptr = env->regbase[get_reg_index(env, cwp1, 6)];
bsd-user/main.c:        put_user_ual(env->regbase[get_reg_index(env, cwp1, 8 + i)], sp_ptr);
bsd-user/main.c:    new_wim = ((env->wim >> 1) | (env->wim << (env->nwindows - 1))) &
bsd-user/main.c:        ((1LL << env->nwindows) - 1);
bsd-user/main.c:    save_window_offset(env, cpu_cwp_dec(env, env->cwp - 2));
bsd-user/main.c:    env->wim = new_wim;
bsd-user/main.c:    save_window_offset(env, cpu_cwp_dec(env, env->cwp - 2));
bsd-user/main.c:    env->cansave++;
bsd-user/main.c:    env->canrestore--;
bsd-user/main.c:    new_wim = ((env->wim << 1) | (env->wim >> (env->nwindows - 1))) &
bsd-user/main.c:        ((1LL << env->nwindows) - 1);
bsd-user/main.c:    cwp1 = cpu_cwp_inc(env, env->cwp + 1);
bsd-user/main.c:    sp_ptr = env->regbase[get_reg_index(env, cwp1, 6)];
bsd-user/main.c:        get_user_ual(env->regbase[get_reg_index(env, cwp1, 8 + i)], sp_ptr);
bsd-user/main.c:    env->canrestore++;
bsd-user/main.c:    if (env->cleanwin < env->nwindows - 1)
bsd-user/main.c:        env->cleanwin++;
bsd-user/main.c:    env->cansave--;
bsd-user/main.c:    env->wim = new_wim;
bsd-user/main.c:        cwp1 = cpu_cwp_inc(env, env->cwp + offset);
bsd-user/main.c:        if (env->wim & (1 << cwp1))
bsd-user/main.c:        if (env->canrestore == 0)
bsd-user/main.c:        env->cansave++;
bsd-user/main.c:        env->canrestore--;
bsd-user/main.c:    cwp1 = cpu_cwp_inc(env, env->cwp + 1);
bsd-user/main.c:    env->wim = 1 << cwp1;
bsd-user/main.c:            syscall_nr = env->gregs[1];
bsd-user/main.c:                                         env->regwptr[0], env->regwptr[1],
bsd-user/main.c:                                         env->regwptr[2], env->regwptr[3],
bsd-user/main.c:                                         env->regwptr[4], env->regwptr[5], 0, 0);
bsd-user/main.c:                                        env->regwptr[0], env->regwptr[1],
bsd-user/main.c:                                        env->regwptr[2], env->regwptr[3],
bsd-user/main.c:                                        env->regwptr[4], env->regwptr[5]);
bsd-user/main.c:                                         env->regwptr[0], env->regwptr[1],
bsd-user/main.c:                                         env->regwptr[2], env->regwptr[3],
bsd-user/main.c:                                         env->regwptr[4], env->regwptr[5]);
bsd-user/main.c:                env->xcc |= PSR_CARRY;
bsd-user/main.c:                env->psr |= PSR_CARRY;
bsd-user/main.c:                env->xcc &= ~PSR_CARRY;
bsd-user/main.c:                env->psr &= ~PSR_CARRY;
bsd-user/main.c:            env->regwptr[0] = ret;
bsd-user/main.c:                env->gregs[1] & TARGET_OPENBSD_SYSCALL_G2RFLAG) {
bsd-user/main.c:                env->pc = env->gregs[2];
bsd-user/main.c:                env->npc = env->pc + 4;
bsd-user/main.c:                       env->gregs[1] & TARGET_OPENBSD_SYSCALL_G7RFLAG) {
bsd-user/main.c:                env->pc = env->gregs[7];
bsd-user/main.c:                env->npc = env->pc + 4;
bsd-user/main.c:                env->pc = env->npc;
bsd-user/main.c:                env->npc = env->npc + 4;
bsd-user/main.c:            env->pc = env->npc;
bsd-user/main.c:            env->npc = env->npc + 4;
bsd-user/main.c:            env->pc = env->npc;
bsd-user/main.c:            env->npc = env->npc + 4;
bsd-user/main.c:                /* XXX: check env->error_code */
bsd-user/main.c:                info._sifields._sigfault._addr = env->mmuregs[4];
bsd-user/main.c:                /* XXX: check env->error_code */
bsd-user/main.c:                    info._sifields._sigfault._addr = env->dmmuregs[4];
bsd-user/main.c:                    info._sifields._sigfault._addr = env->tsptr->tpc;
bsd-user/main.c:    env->opaque = ts;
bsd-user/main.c:    env->cr[0] = CR0_PG_MASK | CR0_WP_MASK | CR0_PE_MASK;
bsd-user/main.c:    env->hflags |= HF_PE_MASK;
bsd-user/main.c:    if (env->cpuid_features & CPUID_SSE) {
bsd-user/main.c:        env->cr[4] |= CR4_OSFXSR_MASK;
bsd-user/main.c:        env->hflags |= HF_OSFXSR_MASK;
bsd-user/main.c:    if (!(env->cpuid_ext2_features & CPUID_EXT2_LM)) {
bsd-user/main.c:    env->cr[4] |= CR4_PAE_MASK;
bsd-user/main.c:    env->efer |= MSR_EFER_LMA | MSR_EFER_LME;
bsd-user/main.c:    env->hflags |= HF_LMA_MASK;
bsd-user/main.c:    env->eflags |= IF_MASK;
bsd-user/main.c:    env->regs[R_EAX] = regs->rax;
bsd-user/main.c:    env->regs[R_EBX] = regs->rbx;
bsd-user/main.c:    env->regs[R_ECX] = regs->rcx;
bsd-user/main.c:    env->regs[R_EDX] = regs->rdx;
bsd-user/main.c:    env->regs[R_ESI] = regs->rsi;
bsd-user/main.c:    env->regs[R_EDI] = regs->rdi;
bsd-user/main.c:    env->regs[R_EBP] = regs->rbp;
bsd-user/main.c:    env->regs[R_ESP] = regs->rsp;
bsd-user/main.c:    env->eip = regs->rip;
bsd-user/main.c:    env->regs[R_EAX] = regs->eax;
bsd-user/main.c:    env->regs[R_EBX] = regs->ebx;
bsd-user/main.c:    env->regs[R_ECX] = regs->ecx;
bsd-user/main.c:    env->regs[R_EDX] = regs->edx;
bsd-user/main.c:    env->regs[R_ESI] = regs->esi;
bsd-user/main.c:    env->regs[R_EDI] = regs->edi;
bsd-user/main.c:    env->regs[R_EBP] = regs->ebp;
bsd-user/main.c:    env->regs[R_ESP] = regs->esp;
bsd-user/main.c:    env->eip = regs->eip;
bsd-user/main.c:    env->idt.limit = 511;
bsd-user/main.c:    env->idt.limit = 255;
bsd-user/main.c:    env->idt.base = target_mmap(0, sizeof(uint64_t) * (env->idt.limit + 1),
bsd-user/main.c:    idt_table = g2h(env->idt.base);
bsd-user/main.c:        env->gdt.base = target_mmap(0, sizeof(uint64_t) * TARGET_GDT_ENTRIES,
bsd-user/main.c:        env->gdt.limit = sizeof(uint64_t) * TARGET_GDT_ENTRIES - 1;
bsd-user/main.c:        gdt_table = g2h(env->gdt.base);
bsd-user/main.c:    env->segs[R_FS].selector = 0;
bsd-user/main.c:        env->pc = regs->pc;
bsd-user/main.c:        env->npc = regs->npc;
bsd-user/main.c:        env->y = regs->y;
bsd-user/main.c:            env->gregs[i] = regs->u_regs[i];
bsd-user/main.c:            env->regwptr[i] = regs->u_regs[i + 8];
bsd-user/syscall.c:        env->segs[idx].base = val;
bsd-user/syscall.c:        val = env->segs[idx].base;
Changelog:  - Fix race condition in env->interrupt_request.  When using TCG and a dynticks
cpu-exec.c:    env->current_tb = NULL;
cpu-exec.c:    longjmp(env->jmp_env, 1);
cpu-exec.c:    env->exception_index = -1;
cpu-exec.c:    longjmp(env->jmp_env, 1);
cpu-exec.c:    env->current_tb = tb;
cpu-exec.c:    env->current_tb = NULL;
cpu-exec.c:    env->tb_jmp_cache[tb_jmp_cache_hash_func(pc)] = tb;
cpu-exec.c:    tb = env->tb_jmp_cache[tb_jmp_cache_hash_func(pc)];
cpu-exec.c:    if (!env->watchpoint_hit) {
cpu-exec.c:        QTAILQ_FOREACH(wp, &env->watchpoints, entry) {
cpu-exec.c:    if (env->halted) {
cpu-exec.c:        env->halted = 0;
cpu-exec.c:        env->exit_request = 1;
cpu-exec.c:    CC_SRC = env->eflags & (CC_O | CC_S | CC_Z | CC_A | CC_P | CC_C);
cpu-exec.c:    DF = 1 - (2 * ((env->eflags >> 10) & 1));
cpu-exec.c:    env->eflags &= ~(DF_MASK | CC_O | CC_S | CC_Z | CC_A | CC_P | CC_C);
cpu-exec.c:    env->cc_op = CC_OP_FLAGS;
cpu-exec.c:    env->cc_dest = env->sr & 0xf;
cpu-exec.c:    env->cc_x = (env->sr >> 4) & 1;
cpu-exec.c:    env->reserve_addr = -1;
cpu-exec.c:    env->exception_index = -1;
cpu-exec.c:        if (setjmp(env->jmp_env) == 0) {
cpu-exec.c:            if (env->exception_index >= 0) {
cpu-exec.c:                if (env->exception_index >= EXCP_INTERRUPT) {
cpu-exec.c:                    ret = env->exception_index;
cpu-exec.c:                    ret = env->exception_index;
cpu-exec.c:                    env->exception_index = -1;
cpu-exec.c:                interrupt_request = env->interrupt_request;
cpu-exec.c:                    if (unlikely(env->singlestep_enabled & SSTEP_NOIRQ)) {
cpu-exec.c:                        env->interrupt_request &= ~CPU_INTERRUPT_DEBUG;
cpu-exec.c:                        env->exception_index = EXCP_DEBUG;
cpu-exec.c:                        env->interrupt_request &= ~CPU_INTERRUPT_HALT;
cpu-exec.c:                        env->halted = 1;
cpu-exec.c:                        env->exception_index = EXCP_HLT;
cpu-exec.c:                            env->exception_index = EXCP_HALTED;
cpu-exec.c:                    } else if (env->hflags2 & HF2_GIF_MASK) {
cpu-exec.c:                            !(env->hflags & HF_SMM_MASK)) {
cpu-exec.c:                            env->interrupt_request &= ~CPU_INTERRUPT_SMI;
cpu-exec.c:                                   !(env->hflags2 & HF2_NMI_MASK)) {
cpu-exec.c:                            env->interrupt_request &= ~CPU_INTERRUPT_NMI;
cpu-exec.c:                            env->hflags2 |= HF2_NMI_MASK;
cpu-exec.c:                            env->interrupt_request &= ~CPU_INTERRUPT_MCE;
cpu-exec.c:                                   (((env->hflags2 & HF2_VINTR_MASK) && 
cpu-exec.c:                                     (env->hflags2 & HF2_HIF_MASK)) ||
cpu-exec.c:                                    (!(env->hflags2 & HF2_VINTR_MASK) && 
cpu-exec.c:                                     (env->eflags & IF_MASK && 
cpu-exec.c:                                      !(env->hflags & HF_INHIBIT_IRQ_MASK))))) {
cpu-exec.c:                            env->interrupt_request &= ~(CPU_INTERRUPT_HARD | CPU_INTERRUPT_VIRQ);
cpu-exec.c:                                   (env->eflags & IF_MASK) && 
cpu-exec.c:                                   !(env->hflags & HF_INHIBIT_IRQ_MASK)) {
cpu-exec.c:                            intno = ldl_phys(env->vm_vmcb + offsetof(struct vmcb, control.int_vector));
cpu-exec.c:                            env->interrupt_request &= ~CPU_INTERRUPT_VIRQ;
cpu-exec.c:                        if (env->pending_interrupts == 0)
cpu-exec.c:                            env->interrupt_request &= ~CPU_INTERRUPT_HARD;
cpu-exec.c:                        && (env->ie & IE_IE)) {
cpu-exec.c:                        env->exception_index = EXCP_IRQ;
cpu-exec.c:                        && (env->sregs[SR_MSR] & MSR_IE)
cpu-exec.c:                        && !(env->sregs[SR_MSR] & (MSR_EIP | MSR_BIP))
cpu-exec.c:                        && !(env->iflags & (D_FLAG | IMM_FLAG))) {
cpu-exec.c:                        env->exception_index = EXCP_IRQ;
cpu-exec.c:                        env->exception_index = EXCP_EXT_INTERRUPT;
cpu-exec.c:                        env->error_code = 0;
cpu-exec.c:                            env->interrupt_index > 0) {
cpu-exec.c:                            int pil = env->interrupt_index & 0xf;
cpu-exec.c:                            int type = env->interrupt_index & 0xf0;
cpu-exec.c:                                env->exception_index = env->interrupt_index;
cpu-exec.c:                        && !(env->uncached_cpsr & CPSR_F)) {
cpu-exec.c:                        env->exception_index = EXCP_FIQ;
cpu-exec.c:                        && ((IS_M(env) && env->regs[15] < 0xfffffff0)
cpu-exec.c:                            || !(env->uncached_cpsr & CPSR_I))) {
cpu-exec.c:                        env->exception_index = EXCP_IRQ;
cpu-exec.c:                        && !(env->uncached_asr & ASR_I)) {
cpu-exec.c:                        switch (env->pal_mode ? 7 : env->ps & PS_INT_MASK) {
cpu-exec.c:                            env->exception_index = idx;
cpu-exec.c:                            env->error_code = 0;
cpu-exec.c:                        && (env->pregs[PR_CCS] & I_FLAG)
cpu-exec.c:                        && !env->locked_irq) {
cpu-exec.c:                        env->exception_index = EXCP_IRQ;
cpu-exec.c:                        && (env->pregs[PR_CCS] & M_FLAG)) {
cpu-exec.c:                        env->exception_index = EXCP_NMI;
cpu-exec.c:                        && ((env->sr & SR_I) >> SR_I_SHIFT)
cpu-exec.c:                            < env->pending_level) {
cpu-exec.c:                        env->exception_index = env->pending_vector;
cpu-exec.c:                        (env->psw.mask & PSW_MASK_EXT)) {
cpu-exec.c:                        env->exception_index = EXC_IRQ;
cpu-exec.c:                    if (env->interrupt_request & CPU_INTERRUPT_EXITTB) {
cpu-exec.c:                        env->interrupt_request &= ~CPU_INTERRUPT_EXITTB;
cpu-exec.c:                if (unlikely(env->exit_request)) {
cpu-exec.c:                    env->exit_request = 0;
cpu-exec.c:                    env->exception_index = EXCP_INTERRUPT;
cpu-exec.c:                    env->eflags = env->eflags | cpu_cc_compute_all(env, CC_OP)
cpu-exec.c:                    env->eflags &= ~(DF_MASK | CC_O | CC_S | CC_Z | CC_A | CC_P | CC_C);
cpu-exec.c:                    cpu_m68k_flush_flags(env, env->cc_op);
cpu-exec.c:                    env->cc_op = CC_OP_FLAGS;
cpu-exec.c:                    env->sr = (env->sr & 0xffe0)
cpu-exec.c:                              | env->cc_dest | (env->cc_x << 4);
cpu-exec.c:                   infinite loop and becomes env->current_tb. Avoid
cpu-exec.c:                env->current_tb = tb;
cpu-exec.c:                if (likely(!env->exit_request)) {
cpu-exec.c:                        insns_left = env->icount_decr.u32;
cpu-exec.c:                        if (env->icount_extra && insns_left >= 0) {
cpu-exec.c:                            env->icount_extra += insns_left;
cpu-exec.c:                            if (env->icount_extra > 0xffff) {
cpu-exec.c:                                insns_left = env->icount_extra;
cpu-exec.c:                            env->icount_extra -= insns_left;
cpu-exec.c:                            env->icount_decr.u16.low = insns_left;
cpu-exec.c:                            env->exception_index = EXCP_INTERRUPT;
cpu-exec.c:                env->current_tb = NULL;
cpu-exec.c:    env->eflags = env->eflags | cpu_cc_compute_all(env, CC_OP)
cpu-exec.c:    cpu_m68k_flush_flags(env, env->cc_op);
cpu-exec.c:    env->cc_op = CC_OP_FLAGS;
cpu-exec.c:    env->sr = (env->sr & 0xffe0)
cpu-exec.c:              | env->cc_dest | (env->cc_x << 4);
cpus.c:        icount -= (env->icount_decr.u16.low + env->icount_extra);
cpus.c:    for(env = first_cpu; env != NULL; env = env->next_cpu) {
cpus.c:        fprintf(stderr, "CPU #%d:\n", env->cpu_index);
cpus.c:    return !runstate_is_running() || env->stopped;
cpus.c:    if (env->stop) {
cpus.c:    if (env->stopped || !runstate_is_running()) {
cpus.c:    if (env->stop || env->queued_work_first) {
cpus.c:    if (env->stopped || !runstate_is_running()) {
cpus.c:    if (!env->halted || qemu_cpu_has_work(env) || kvm_irqchip_in_kernel()) {
cpus.c:    for (env = first_cpu; env != NULL; env = env->next_cpu) {
cpus.c:    env->stopped = 1;
cpus.c:    if (!env->queued_work_first) {
cpus.c:        env->queued_work_first = &wi;
cpus.c:        env->queued_work_last->next = &wi;
cpus.c:    env->queued_work_last = &wi;
cpus.c:    if (!env->queued_work_first) {
cpus.c:    while ((wi = env->queued_work_first)) {
cpus.c:        env->queued_work_first = wi->next;
cpus.c:    env->queued_work_last = NULL;
cpus.c:    if (env->stop) {
cpus.c:        env->stop = 0;
cpus.c:        env->stopped = 1;
cpus.c:    env->thread_kicked = false;
cpus.c:    for (env = first_cpu; env != NULL; env = env->next_cpu) {
cpus.c:        qemu_cond_wait(env->halt_cond, &qemu_global_mutex);
cpus.c:    qemu_thread_get_self(env->thread);
cpus.c:    env->thread_id = qemu_get_thread_id();
cpus.c:    env->created = 1;
cpus.c:    qemu_thread_get_self(env->thread);
cpus.c:    env->thread_id = qemu_get_thread_id();
cpus.c:    env->created = 1;
cpus.c:    qemu_thread_get_self(env->thread);
cpus.c:    for (env = first_cpu; env != NULL; env = env->next_cpu) {
cpus.c:        env->thread_id = qemu_get_thread_id();
cpus.c:        env->created = 1;
cpus.c:        for (env = first_cpu; env != NULL; env = env->next_cpu) {
cpus.c:    err = pthread_kill(env->thread->thread, SIG_IPI);
cpus.c:        SuspendThread(env->hThread);
cpus.c:        ResumeThread(env->hThread);
cpus.c:    qemu_cond_broadcast(env->halt_cond);
cpus.c:    if (!tcg_enabled() && !env->thread_kicked) {
cpus.c:        env->thread_kicked = true;
cpus.c:    if (!cpu_single_env->thread_kicked) {
cpus.c:        cpu_single_env->thread_kicked = true;
cpus.c:    return qemu_thread_is_self(env->thread);
cpus.c:        if (!penv->stopped) {
cpus.c:        penv = penv->next_cpu;
cpus.c:        penv->stop = 1;
cpus.c:        penv = penv->next_cpu;
cpus.c:                penv->stop = 0;
cpus.c:                penv->stopped = 1;
cpus.c:                penv = penv->next_cpu;
cpus.c:            penv = penv->next_cpu;
cpus.c:        penv->stop = 0;
cpus.c:        penv->stopped = 0;
cpus.c:        penv = penv->next_cpu;
cpus.c:        env->thread = g_malloc0(sizeof(QemuThread));
cpus.c:        env->halt_cond = g_malloc0(sizeof(QemuCond));
cpus.c:        qemu_cond_init(env->halt_cond);
cpus.c:        tcg_halt_cond = env->halt_cond;
cpus.c:        qemu_thread_create(env->thread, qemu_tcg_cpu_thread_fn, env,
cpus.c:        env->hThread = qemu_thread_get_handle(env->thread);
cpus.c:        while (env->created == 0) {
cpus.c:        tcg_cpu_thread = env->thread;
cpus.c:        env->thread = tcg_cpu_thread;
cpus.c:        env->halt_cond = tcg_halt_cond;
cpus.c:    env->thread = g_malloc0(sizeof(QemuThread));
cpus.c:    env->halt_cond = g_malloc0(sizeof(QemuCond));
cpus.c:    qemu_cond_init(env->halt_cond);
cpus.c:    qemu_thread_create(env->thread, qemu_kvm_cpu_thread_fn, env,
cpus.c:    while (env->created == 0) {
cpus.c:    env->thread = g_malloc0(sizeof(QemuThread));
cpus.c:    env->halt_cond = g_malloc0(sizeof(QemuCond));
cpus.c:    qemu_cond_init(env->halt_cond);
cpus.c:    qemu_thread_create(env->thread, qemu_dummy_cpu_thread_fn, env,
cpus.c:    while (env->created == 0) {
cpus.c:    env->nr_cores = smp_cores;
cpus.c:    env->nr_threads = smp_threads;
cpus.c:    env->stopped = 1;
cpus.c:        cpu_single_env->stop = 0;
cpus.c:        cpu_single_env->stopped = 1;
cpus.c:        qemu_icount -= (env->icount_decr.u16.low + env->icount_extra);
cpus.c:        env->icount_decr.u16.low = 0;
cpus.c:        env->icount_extra = 0;
cpus.c:        env->icount_decr.u16.low = decr;
cpus.c:        env->icount_extra = count;
cpus.c:        qemu_icount -= (env->icount_decr.u16.low
cpus.c:                        + env->icount_extra);
cpus.c:        env->icount_decr.u32 = 0;
cpus.c:        env->icount_extra = 0;
cpus.c:                          (env->singlestep_enabled & SSTEP_NOTIMER) == 0);
cpus.c:        } else if (env->stop || env->stopped) {
cpus.c:    for (env = first_cpu; env != NULL; env = env->next_cpu) {
cpus.c:            if (node_cpumask[i] & (1 << env->cpu_index)) {
cpus.c:                env->numa_node = i;
cpus.c:    for(env = first_cpu; env != NULL; env = env->next_cpu) {
cpus.c:        info->value->CPU = env->cpu_index;
cpus.c:        info->value->halted = env->halted;
cpus.c:        info->value->thread_id = env->thread_id;
cpus.c:        info->value->pc = env->eip + env->segs[R_CS].base;
cpus.c:        info->value->nip = env->nip;
cpus.c:        info->value->pc = env->pc;
cpus.c:        info->value->npc = env->npc;
cpus.c:        info->value->PC = env->active_tc.PC;
cpus.c:    for (env = first_cpu; env; env = env->next_cpu) {
cpus.c:        if (cpu_index == env->cpu_index) {
cpus.c:    for (env = first_cpu; env != NULL; env = env->next_cpu) {
cpus.c:        if (!env->apic_state) {
cpus.c:            apic_deliver_nmi(env->apic_state);
cputlb.c:    env->current_tb = NULL;
cputlb.c:            env->tlb_table[mmu_idx][i] = s_cputlb_empty_entry;
cputlb.c:    memset(env->tb_jmp_cache, 0, TB_JMP_CACHE_SIZE * sizeof (void *));
cputlb.c:    env->tlb_flush_addr = -1;
cputlb.c:    env->tlb_flush_mask = 0;
cputlb.c:    if ((addr & env->tlb_flush_mask) == env->tlb_flush_addr) {
cputlb.c:               env->tlb_flush_addr, env->tlb_flush_mask);
cputlb.c:    env->current_tb = NULL;
cputlb.c:        tlb_flush_entry(&env->tlb_table[mmu_idx][i], addr);
cputlb.c:    for (env = first_cpu; env != NULL; env = env->next_cpu) {
cputlb.c:                tlb_reset_dirty_range(&env->tlb_table[mmu_idx][i],
cputlb.c:        tlb_set_dirty1(&env->tlb_table[mmu_idx][i], vaddr);
cputlb.c:    if (env->tlb_flush_addr == (target_ulong)-1) {
cputlb.c:        env->tlb_flush_addr = vaddr & mask;
cputlb.c:        env->tlb_flush_mask = mask;
cputlb.c:    mask &= env->tlb_flush_mask;
cputlb.c:    while (((env->tlb_flush_addr ^ vaddr) & mask) != 0) {
cputlb.c:    env->tlb_flush_addr &= mask;
cputlb.c:    env->tlb_flush_mask = mask;
cputlb.c:    env->iotlb[mmu_idx][index] = iotlb - vaddr;
cputlb.c:    te = &env->tlb_table[mmu_idx][index];
exec-all.h:    if (!env->current_tb) {
exec-all.h:    return env->can_do_io != 0;
exec.c:    env->interrupt_request &= ~0x01;
exec.c:        if (env->cpu_index == cpu)
exec.c:        env = env->next_cpu;
exec.c:    env->next_cpu = NULL;
exec.c:    env->cpu_index = cpu_index;
exec.c:    env->numa_node = 0;
exec.c:    QTAILQ_INIT(&env->breakpoints);
exec.c:    QTAILQ_INIT(&env->watchpoints);
exec.c:    env->thread_id = qemu_get_thread_id();
exec.c:    for(env = first_cpu; env != NULL; env = env->next_cpu) {
exec.c:        memset (env->tb_jmp_cache, 0, TB_JMP_CACHE_SIZE * sizeof (void *));
exec.c:    for(env = first_cpu; env != NULL; env = env->next_cpu) {
exec.c:        if (env->tb_jmp_cache[h] == tb)
exec.c:            env->tb_jmp_cache[h] = NULL;
exec.c:                if (env->mem_io_pc) {
exec.c:                    current_tb = tb_find_pc(env->mem_io_pc);
exec.c:                cpu_restore_state(current_tb, env, env->mem_io_pc);
exec.c:                saved_tb = env->current_tb;
exec.c:                env->current_tb = NULL;
exec.c:                env->current_tb = saved_tb;
exec.c:                if (env->interrupt_request && env->current_tb)
exec.c:                    cpu_interrupt(env, env->interrupt_request);
exec.c:            tlb_unprotect_code_phys(env, start, env->mem_io_vaddr);
exec.c:        env->current_tb = NULL;
exec.c:                  cpu_single_env->mem_io_vaddr, len,
exec.c:                  cpu_single_env->eip,
exec.c:                  cpu_single_env->eip +
exec.c:                  (intptr_t)cpu_single_env->segs[R_CS].base);
exec.c:        env->current_tb = NULL;
exec.c:        QTAILQ_INSERT_HEAD(&env->watchpoints, wp, entry);
exec.c:        QTAILQ_INSERT_TAIL(&env->watchpoints, wp, entry);
exec.c:    QTAILQ_FOREACH(wp, &env->watchpoints, entry) {
exec.c:    QTAILQ_REMOVE(&env->watchpoints, watchpoint, entry);
exec.c:    QTAILQ_FOREACH_SAFE(wp, &env->watchpoints, entry, next) {
exec.c:        QTAILQ_INSERT_HEAD(&env->breakpoints, bp, entry);
exec.c:        QTAILQ_INSERT_TAIL(&env->breakpoints, bp, entry);
exec.c:    QTAILQ_FOREACH(bp, &env->breakpoints, entry) {
exec.c:    QTAILQ_REMOVE(&env->breakpoints, breakpoint, entry);
exec.c:    QTAILQ_FOREACH_SAFE(bp, &env->breakpoints, entry, next) {
exec.c:    if (env->singlestep_enabled != enabled) {
exec.c:        env->singlestep_enabled = enabled;
exec.c:    tb = env->current_tb;
exec.c:        env->current_tb = NULL;
exec.c:    old_mask = env->interrupt_request;
exec.c:    env->interrupt_request |= mask;
exec.c:        env->icount_decr.u16.high = 0xffff;
exec.c:    env->interrupt_request |= mask;
exec.c:    env->interrupt_request &= ~mask;
exec.c:    env->exit_request = 1;
exec.c:    CPUArchState *new_env = cpu_init(env->cpu_model_str);
exec.c:    CPUArchState *next_cpu = new_env->next_cpu;
exec.c:    int cpu_index = new_env->cpu_index;
exec.c:    new_env->next_cpu = next_cpu;
exec.c:    new_env->cpu_index = cpu_index;
exec.c:    QTAILQ_INIT(&env->breakpoints);
exec.c:    QTAILQ_INIT(&env->watchpoints);
exec.c:    QTAILQ_FOREACH(bp, &env->breakpoints, entry) {
exec.c:    QTAILQ_FOREACH(wp, &env->watchpoints, entry) {
exec.c:    memset (&env->tb_jmp_cache[i], 0, 
exec.c:    memset (&env->tb_jmp_cache[i], 0, 
exec.c:    QTAILQ_FOREACH(wp, &env->watchpoints, entry) {
exec.c:        tlb_set_dirty(cpu_single_env, cpu_single_env->mem_io_vaddr);
exec.c:    if (env->watchpoint_hit) {
exec.c:    vaddr = (env->mem_io_vaddr & TARGET_PAGE_MASK) + offset;
exec.c:    QTAILQ_FOREACH(wp, &env->watchpoints, entry) {
exec.c:            if (!env->watchpoint_hit) {
exec.c:                env->watchpoint_hit = wp;
exec.c:                tb = tb_find_pc(env->mem_io_pc);
exec.c:                              "pc=%p", (void *)env->mem_io_pc);
exec.c:                cpu_restore_state(tb, env, env->mem_io_pc);
exec.c:                    env->exception_index = EXCP_DEBUG;
exec.c:    for(env = first_cpu; env != NULL; env = env->next_cpu) {
exec.c:    n = env->icount_decr.u16.low + tb->icount;
exec.c:    n = n - env->icount_decr.u16.low;
exec.c:    if ((env->hflags & MIPS_HFLAG_BMASK) != 0 && n > 1) {
exec.c:        env->active_tc.PC -= 4;
exec.c:        env->icount_decr.u16.low++;
exec.c:        env->hflags &= ~MIPS_HFLAG_BMASK;
exec.c:    if ((env->flags & ((DELAY_SLOT | DELAY_SLOT_CONDITIONAL))) != 0
exec.c:        env->pc -= 2;
exec.c:        env->icount_decr.u16.low++;
exec.c:        env->flags &= ~(DELAY_SLOT | DELAY_SLOT_CONDITIONAL);
exec.c:    /* TODO: If env->pc != tb->pc (i.e. the faulting instruction was not
gdbstub.c:        if (TARGET_LONG_BITS == 64 && env->hflags & HF_CS64_MASK) {
gdbstub.c:            GET_REG64(env->regs[gpr_map[n]]);
gdbstub.c:            GET_REG32(env->regs[gpr_map32[n]]);
gdbstub.c:        memcpy(mem_buf, &env->fpregs[n - IDX_FP_REGS], 10);
gdbstub.c:            (TARGET_LONG_BITS == 64 && env->hflags & HF_CS64_MASK)) {
gdbstub.c:            stq_p(mem_buf, env->xmm_regs[n].XMM_Q(0));
gdbstub.c:            stq_p(mem_buf + 8, env->xmm_regs[n].XMM_Q(1));
gdbstub.c:            if (TARGET_LONG_BITS == 64 && env->hflags & HF_CS64_MASK) {
gdbstub.c:                GET_REG64(env->eip);
gdbstub.c:                GET_REG32(env->eip);
gdbstub.c:        case IDX_FLAGS_REG: GET_REG32(env->eflags);
gdbstub.c:        case IDX_SEG_REGS:     GET_REG32(env->segs[R_CS].selector);
gdbstub.c:        case IDX_SEG_REGS + 1: GET_REG32(env->segs[R_SS].selector);
gdbstub.c:        case IDX_SEG_REGS + 2: GET_REG32(env->segs[R_DS].selector);
gdbstub.c:        case IDX_SEG_REGS + 3: GET_REG32(env->segs[R_ES].selector);
gdbstub.c:        case IDX_SEG_REGS + 4: GET_REG32(env->segs[R_FS].selector);
gdbstub.c:        case IDX_SEG_REGS + 5: GET_REG32(env->segs[R_GS].selector);
gdbstub.c:        case IDX_FP_REGS + 8:  GET_REG32(env->fpuc);
gdbstub.c:        case IDX_FP_REGS + 9:  GET_REG32((env->fpus & ~0x3800) |
gdbstub.c:                                         (env->fpstt & 0x7) << 11);
gdbstub.c:        case IDX_MXCSR_REG: GET_REG32(env->mxcsr);
gdbstub.c:    if (selector != env->segs[sreg].selector) {
gdbstub.c:        if (!(env->cr[0] & CR0_PE_MASK) || (env->eflags & VM_MASK)) {
gdbstub.c:        if (TARGET_LONG_BITS == 64 && env->hflags & HF_CS64_MASK) {
gdbstub.c:            env->regs[gpr_map[n]] = ldtul_p(mem_buf);
gdbstub.c:            env->regs[n] &= ~0xffffffffUL;
gdbstub.c:            env->regs[n] |= (uint32_t)ldl_p(mem_buf);
gdbstub.c:        memcpy(&env->fpregs[n - IDX_FP_REGS], mem_buf, 10);
gdbstub.c:            (TARGET_LONG_BITS == 64 && env->hflags & HF_CS64_MASK)) {
gdbstub.c:            env->xmm_regs[n].XMM_Q(0) = ldq_p(mem_buf);
gdbstub.c:            env->xmm_regs[n].XMM_Q(1) = ldq_p(mem_buf + 8);
gdbstub.c:            if (TARGET_LONG_BITS == 64 && env->hflags & HF_CS64_MASK) {
gdbstub.c:                env->eip = ldq_p(mem_buf);
gdbstub.c:                env->eip &= ~0xffffffffUL;
gdbstub.c:                env->eip |= (uint32_t)ldl_p(mem_buf);
gdbstub.c:            env->eflags = ldl_p(mem_buf);
gdbstub.c:            env->fpuc = ldl_p(mem_buf);
gdbstub.c:            env->fpstt = (tmp >> 11) & 7;
gdbstub.c:            env->fpus = tmp & ~0x3800;
gdbstub.c:            env->mxcsr = ldl_p(mem_buf);
gdbstub.c:        GET_REGL(env->gpr[n]);
gdbstub.c:        stfq_p(mem_buf, env->fpr[n-32]);
gdbstub.c:        case 64: GET_REGL(env->nip);
gdbstub.c:        case 65: GET_REGL(env->msr);
gdbstub.c:                    cr |= env->crf[i] << (32 - ((i + 1) * 4));
gdbstub.c:        case 67: GET_REGL(env->lr);
gdbstub.c:        case 68: GET_REGL(env->ctr);
gdbstub.c:        case 69: GET_REGL(env->xer);
gdbstub.c:                GET_REG32(env->fpscr);
gdbstub.c:        env->gpr[n] = ldtul_p(mem_buf);
gdbstub.c:        env->fpr[n-32] = ldfq_p(mem_buf);
gdbstub.c:            env->nip = ldtul_p(mem_buf);
gdbstub.c:                    env->crf[i] = (cr >> (32 - ((i + 1) * 4))) & 0xF;
gdbstub.c:            env->lr = ldtul_p(mem_buf);
gdbstub.c:            env->ctr = ldtul_p(mem_buf);
gdbstub.c:            env->xer = ldtul_p(mem_buf);
gdbstub.c:        GET_REGA(env->gregs[n]);
gdbstub.c:        GET_REGA(env->regwptr[n - 8]);
gdbstub.c:            GET_REG32(env->fpr[(n - 32) / 2].l.lower);
gdbstub.c:            GET_REG32(env->fpr[(n - 32) / 2].l.upper);
gdbstub.c:    case 64: GET_REGA(env->y);
gdbstub.c:    case 66: GET_REGA(env->wim);
gdbstub.c:    case 67: GET_REGA(env->tbr);
gdbstub.c:    case 68: GET_REGA(env->pc);
gdbstub.c:    case 69: GET_REGA(env->npc);
gdbstub.c:    case 70: GET_REGA(env->fsr);
gdbstub.c:            GET_REG32(env->fpr[(n - 32) / 2].l.lower);
gdbstub.c:            GET_REG32(env->fpr[(n - 32) / 2].l.upper);
gdbstub.c:        GET_REG64(env->fpr[(n - 32) / 2].ll);
gdbstub.c:    case 80: GET_REGL(env->pc);
gdbstub.c:    case 81: GET_REGL(env->npc);
gdbstub.c:                      ((env->asi & 0xff) << 24) |
gdbstub.c:                      ((env->pstate & 0xfff) << 8) |
gdbstub.c:    case 83: GET_REGL(env->fsr);
gdbstub.c:    case 84: GET_REGL(env->fprs);
gdbstub.c:    case 85: GET_REGL(env->y);
gdbstub.c:        env->gregs[n] = tmp;
gdbstub.c:        env->regwptr[n - 8] = tmp;
gdbstub.c:            env->fpr[(n - 32) / 2].l.lower = tmp;
gdbstub.c:            env->fpr[(n - 32) / 2].l.upper = tmp;
gdbstub.c:        case 64: env->y = tmp; break;
gdbstub.c:        case 66: env->wim = tmp; break;
gdbstub.c:        case 67: env->tbr = tmp; break;
gdbstub.c:        case 68: env->pc = tmp; break;
gdbstub.c:        case 69: env->npc = tmp; break;
gdbstub.c:        case 70: env->fsr = tmp; break;
gdbstub.c:            env->fpr[(n - 32) / 2].l.lower = tmp;
gdbstub.c:            env->fpr[(n - 32) / 2].l.upper = tmp;
gdbstub.c:        env->fpr[(n - 32) / 2].ll = tmp;
gdbstub.c:        case 80: env->pc = tmp; break;
gdbstub.c:        case 81: env->npc = tmp; break;
gdbstub.c:	    env->asi = (tmp >> 24) & 0xff;
gdbstub.c:	    env->pstate = (tmp >> 8) & 0xfff;
gdbstub.c:        case 83: env->fsr = tmp; break;
gdbstub.c:        case 84: env->fprs = tmp; break;
gdbstub.c:        case 85: env->y = tmp; break;
gdbstub.c:        GET_REG32(env->regs[n]);
gdbstub.c:        env->regs[n] = tmp;
gdbstub.c:        GET_REG32(env->dregs[n]);
gdbstub.c:        GET_REG32(env->aregs[n - 8]);
gdbstub.c:        case 16: GET_REG32(env->sr);
gdbstub.c:        case 17: GET_REG32(env->pc);
gdbstub.c:        env->dregs[n] = tmp;
gdbstub.c:        env->aregs[n - 8] = tmp;
gdbstub.c:        case 16: env->sr = tmp; break;
gdbstub.c:        case 17: env->pc = tmp; break;
gdbstub.c:        GET_REGL(env->active_tc.gpr[n]);
gdbstub.c:    if (env->CP0_Config1 & (1 << CP0C1_FP)) {
gdbstub.c:            if (env->CP0_Status & (1 << CP0St_FR))
gdbstub.c:		GET_REGL(env->active_fpu.fpr[n - 38].d);
gdbstub.c:		GET_REGL(env->active_fpu.fpr[n - 38].w[FP_ENDIAN_IDX]);
gdbstub.c:        case 70: GET_REGL((int32_t)env->active_fpu.fcr31);
gdbstub.c:        case 71: GET_REGL((int32_t)env->active_fpu.fcr0);
gdbstub.c:    case 32: GET_REGL((int32_t)env->CP0_Status);
gdbstub.c:    case 33: GET_REGL(env->active_tc.LO[0]);
gdbstub.c:    case 34: GET_REGL(env->active_tc.HI[0]);
gdbstub.c:    case 35: GET_REGL(env->CP0_BadVAddr);
gdbstub.c:    case 36: GET_REGL((int32_t)env->CP0_Cause);
gdbstub.c:    case 37: GET_REGL(env->active_tc.PC | !!(env->hflags & MIPS_HFLAG_M16));
gdbstub.c:    case 89: GET_REGL((int32_t)env->CP0_PRid);
gdbstub.c:    set_float_rounding_mode(ieee_rm[env->active_fpu.fcr31 & 3], &env->active_fpu.fp_status)
gdbstub.c:        env->active_tc.gpr[n] = tmp;
gdbstub.c:    if (env->CP0_Config1 & (1 << CP0C1_FP)
gdbstub.c:            if (env->CP0_Status & (1 << CP0St_FR))
gdbstub.c:              env->active_fpu.fpr[n - 38].d = tmp;
gdbstub.c:              env->active_fpu.fpr[n - 38].w[FP_ENDIAN_IDX] = tmp;
gdbstub.c:            env->active_fpu.fcr31 = tmp & 0xFF83FFFF;
gdbstub.c:        case 71: env->active_fpu.fcr0 = tmp; break;
gdbstub.c:    case 32: env->CP0_Status = tmp; break;
gdbstub.c:    case 33: env->active_tc.LO[0] = tmp; break;
gdbstub.c:    case 34: env->active_tc.HI[0] = tmp; break;
gdbstub.c:    case 35: env->CP0_BadVAddr = tmp; break;
gdbstub.c:    case 36: env->CP0_Cause = tmp; break;
gdbstub.c:        env->active_tc.PC = tmp & ~(target_ulong)1;
gdbstub.c:            env->hflags |= MIPS_HFLAG_M16;
gdbstub.c:            env->hflags &= ~(MIPS_HFLAG_M16);
gdbstub.c:        if ((env->sr & (SR_MD | SR_RB)) == (SR_MD | SR_RB)) {
gdbstub.c:            GET_REGL(env->gregs[n + 16]);
gdbstub.c:            GET_REGL(env->gregs[n]);
gdbstub.c:        GET_REGL(env->gregs[n]);
gdbstub.c:	GET_REGL(env->fregs[(n - 25) + ((env->fpscr & FPSCR_FR) ? 16 : 0)]);
gdbstub.c:	GET_REGL(env->gregs[n - 43]);
gdbstub.c:	GET_REGL(env->gregs[n - (51 - 16)]);
gdbstub.c:    case 16: GET_REGL(env->pc);
gdbstub.c:    case 17: GET_REGL(env->pr);
gdbstub.c:    case 18: GET_REGL(env->gbr);
gdbstub.c:    case 19: GET_REGL(env->vbr);
gdbstub.c:    case 20: GET_REGL(env->mach);
gdbstub.c:    case 21: GET_REGL(env->macl);
gdbstub.c:    case 22: GET_REGL(env->sr);
gdbstub.c:    case 23: GET_REGL(env->fpul);
gdbstub.c:    case 24: GET_REGL(env->fpscr);
gdbstub.c:    case 41: GET_REGL(env->ssr);
gdbstub.c:    case 42: GET_REGL(env->spc);
gdbstub.c:        if ((env->sr & (SR_MD | SR_RB)) == (SR_MD | SR_RB)) {
gdbstub.c:            env->gregs[n + 16] = tmp;
gdbstub.c:            env->gregs[n] = tmp;
gdbstub.c:        env->gregs[n] = tmp;
gdbstub.c:	env->fregs[(n - 25) + ((env->fpscr & FPSCR_FR) ? 16 : 0)] = tmp;
gdbstub.c:	env->gregs[n - 43] = tmp;
gdbstub.c:	env->gregs[n - (51 - 16)] = tmp;
gdbstub.c:    case 16: env->pc = tmp; break;
gdbstub.c:    case 17: env->pr = tmp; break;
gdbstub.c:    case 18: env->gbr = tmp; break;
gdbstub.c:    case 19: env->vbr = tmp; break;
gdbstub.c:    case 20: env->mach = tmp; break;
gdbstub.c:    case 21: env->macl = tmp; break;
gdbstub.c:    case 22: env->sr = tmp; break;
gdbstub.c:    case 23: env->fpul = tmp; break;
gdbstub.c:    case 24: env->fpscr = tmp; break;
gdbstub.c:    case 41: env->ssr = tmp; break;
gdbstub.c:    case 42: env->spc = tmp; break;
gdbstub.c:	GET_REG32(env->regs[n]);
gdbstub.c:	GET_REG32(env->sregs[n - 32]);
gdbstub.c:	env->regs[n] = tmp;
gdbstub.c:	env->sregs[n - 32] = tmp;
gdbstub.c:        GET_REG32(env->regs[n]);
gdbstub.c:        GET_REG32(env->pc);
gdbstub.c:            GET_REG8(env->pregs[n - 16]);
gdbstub.c:            GET_REG8(env->pregs[n - 16]);
gdbstub.c:            GET_REG16(env->pregs[n - 16]);
gdbstub.c:                GET_REG32(env->pregs[n - 16]);
gdbstub.c:    if (env->pregs[PR_VR] < 32)
gdbstub.c:    srs = env->pregs[PR_SRS];
gdbstub.c:	GET_REG32(env->regs[n]);
gdbstub.c:	GET_REG32(env->pregs[n - 16]);
gdbstub.c:	GET_REG32(env->sregs[srs][n - 33]);
gdbstub.c:    case 16: GET_REG8(env->pregs[0]);
gdbstub.c:    case 17: GET_REG8(env->pregs[1]);
gdbstub.c:    case 18: GET_REG32(env->pregs[2]);
gdbstub.c:    case 20: GET_REG16(env->pregs[4]);
gdbstub.c:    case 32: GET_REG32(env->pc);
gdbstub.c:	env->regs[n] = tmp;
gdbstub.c:	env->pregs[n - 16] = tmp;
gdbstub.c:    case 18: env->pregs[PR_PID] = tmp; break;
gdbstub.c:    case 32: env->pc = tmp; break;
gdbstub.c:        val = env->ir[n];
gdbstub.c:        d.d = env->fir[n - 32];
gdbstub.c:        val = env->pc;
gdbstub.c:        val = env->unique;
gdbstub.c:        env->ir[n] = tmp;
gdbstub.c:        env->fir[n - 32] = d.d;
gdbstub.c:        env->pc = tmp;
gdbstub.c:        env->unique = tmp;
gdbstub.c:        case S390_PSWM_REGNUM: GET_REGL(env->psw.mask); break;
gdbstub.c:        case S390_PSWA_REGNUM: GET_REGL(env->psw.addr); break;
gdbstub.c:            GET_REGL(env->regs[n-S390_R0_REGNUM]); break;
gdbstub.c:            GET_REG32(env->aregs[n-S390_A0_REGNUM]); break;
gdbstub.c:        case S390_FPC_REGNUM: GET_REG32(env->fpc); break;
gdbstub.c:        case S390_PC_REGNUM: GET_REGL(env->psw.addr); break;
gdbstub.c:            env->cc_op = calc_cc(env, env->cc_op, env->cc_src, env->cc_dst,
gdbstub.c:                                 env->cc_vr);
gdbstub.c:            GET_REG32(env->cc_op);
gdbstub.c:        case S390_PSWM_REGNUM: env->psw.mask = tmpl; break;
gdbstub.c:        case S390_PSWA_REGNUM: env->psw.addr = tmpl; break;
gdbstub.c:            env->regs[n-S390_R0_REGNUM] = tmpl; break;
gdbstub.c:            env->aregs[n-S390_A0_REGNUM] = tmp32; r=4; break;
gdbstub.c:        case S390_FPC_REGNUM: env->fpc = tmp32; r=4; break;
gdbstub.c:        case S390_PC_REGNUM: env->psw.addr = tmpl; break;
gdbstub.c:        case S390_CC_REGNUM: env->cc_op = tmp32; r=4; break;
gdbstub.c:        GET_REG32(env->regs[n]);
gdbstub.c:            GET_REG32(env->pc);
gdbstub.c:            GET_REG32(env->eba);
gdbstub.c:            GET_REG32(env->deba);
gdbstub.c:            GET_REG32(env->ie);
gdbstub.c:            GET_REG32(lm32_pic_get_im(env->pic_state));
gdbstub.c:            GET_REG32(lm32_pic_get_ip(env->pic_state));
gdbstub.c:        env->regs[n] = tmp;
gdbstub.c:            env->pc = tmp;
gdbstub.c:            env->eba = tmp;
gdbstub.c:            env->deba = tmp;
gdbstub.c:            env->ie = tmp;
gdbstub.c:            lm32_pic_set_im(env->pic_state, tmp);
gdbstub.c:            lm32_pic_set_ip(env->pic_state, tmp);
gdbstub.c:#define NUM_CORE_REGS (env->config->gdb_regmap.num_regs)
gdbstub.c:    const XtensaGdbReg *reg = env->config->gdb_regmap.reg + n;
gdbstub.c:    if (n < 0 || n >= env->config->gdb_regmap.num_regs) {
gdbstub.c:        GET_REG32(env->pc);
gdbstub.c:        GET_REG32(env->phys_regs[(reg->targno & 0xff) % env->config->nareg]);
gdbstub.c:        GET_REG32(env->sregs[reg->targno & 0xff]);
gdbstub.c:        GET_REG32(env->uregs[reg->targno & 0xff]);
gdbstub.c:        GET_REG32(env->regs[reg->targno & 0x0f]);
gdbstub.c:    const XtensaGdbReg *reg = env->config->gdb_regmap.reg + n;
gdbstub.c:    if (n < 0 || n >= env->config->gdb_regmap.num_regs) {
gdbstub.c:        env->pc = tmp;
gdbstub.c:        env->phys_regs[(reg->targno & 0xff) % env->config->nareg] = tmp;
gdbstub.c:        env->sregs[reg->targno & 0xff] = tmp;
gdbstub.c:        env->uregs[reg->targno & 0xff] = tmp;
gdbstub.c:        env->regs[reg->targno & 0x0f] = tmp;
gdbstub.c:    for (r = env->gdb_regs; r; r = r->next) {
gdbstub.c:    for (r = env->gdb_regs; r; r = r->next) {
gdbstub.c:    p = &env->gdb_regs;
gdbstub.c:        for (env = first_cpu; env != NULL; env = env->next_cpu) {
gdbstub.c:        for (env = first_cpu; env != NULL; env = env->next_cpu) {
gdbstub.c:        for (env = first_cpu; env != NULL; env = env->next_cpu) {
gdbstub.c:        for (env = first_cpu; env != NULL; env = env->next_cpu) {
gdbstub.c:    for (env = first_cpu; env != NULL; env = env->next_cpu) {
gdbstub.c:    return env->host_tid;
gdbstub.c:    return env->cpu_index + 1;
gdbstub.c:    for (env = first_cpu; env != NULL; env = env->next_cpu) {
gdbstub.c:                               "CPU#%d [%s]", env->cpu_index,
gdbstub.c:                               env->halted ? "halted " : "running");
gdbstub.c:        if (env->watchpoint_hit) {
gdbstub.c:            switch (env->watchpoint_hit->flags & BP_MEM_ACCESS) {
gdbstub.c:                     env->watchpoint_hit->vaddr);
gdbstub.c:            env->watchpoint_hit = NULL;
hw/ppc_oldworld.c:                ((qemu_irq *)env->irq_inputs)[PPC6xx_INPUT_INT];
hw/pxa2xx.c:            s->env->uncached_cpsr =
hw/pxa2xx.c:            s->env->cp15.c1_sys = 0;
hw/pxa2xx.c:            s->env->cp15.c1_coproc = 0;
hw/pxa2xx.c:            s->env->cp15.c2_base0 = 0;
hw/pxa2xx.c:            s->env->cp15.c3 = 0;
hw/pxa2xx.c:            memset(s->env->regs, 0, 4 * 15);
hw/pxa2xx.c:            s->env->regs[15] = s->pm_regs[PSPR >> 2];
hw/nseries.c:    s->cpu->env->GE = 0x5;
hw/nseries.c:        s->cpu->env->regs[15] = OMAP2_Q2_BASE + 0x400000;
hw/highbank.c:        env->regs[15] = SMP_BOOT_ADDR;
hw/petalogix_ml605_mmu.c:    env->pvr.regs[10] = 0x0e000000; /* virtex 6 */
hw/petalogix_ml605_mmu.c:    env->pvr.regs[5] |= PVR5_DCACHE_WRITEBACK_MASK;
hw/petalogix_ml605_mmu.c:    env->pvr.regs[0] |= PVR0_USE_FPU_MASK | PVR0_ENDI;
hw/petalogix_ml605_mmu.c:    env->pvr.regs[0] = (env->pvr.regs[0] & ~PVR0_VERSION_MASK) | (0x14 << 8);
hw/petalogix_ml605_mmu.c:    env->pvr.regs[2] ^= PVR2_USE_FPU2_MASK;
hw/petalogix_ml605_mmu.c:    env->pvr.regs[4] = 0xc56b8000;
hw/petalogix_ml605_mmu.c:    env->pvr.regs[5] = 0xc56be000;
hw/xtensa_sim.c:        env->sregs[PRID] = n;
hw/xtensa_sim.c:            env->pc = elf_entry;
hw/lm32_boards.c:    env->pc = (uint32_t)reset_info->bootstrap_pc;
hw/lm32_boards.c:    env->regs[R_R1] = (uint32_t)reset_info->hwsetup_base;
hw/lm32_boards.c:    env->regs[R_R2] = (uint32_t)reset_info->cmdline_base;
hw/lm32_boards.c:    env->regs[R_R3] = (uint32_t)reset_info->initrd_base;
hw/lm32_boards.c:    env->regs[R_R4] = (uint32_t)(reset_info->initrd_base +
hw/lm32_boards.c:    env->eba = reset_info->flash_base;
hw/lm32_boards.c:    env->deba = reset_info->flash_base;
hw/lm32_boards.c:    env->pic_state = lm32_pic_init(*cpu_irq);
hw/lm32_boards.c:        irq[i] = qdev_get_gpio_in(env->pic_state, i);
hw/lm32_boards.c:    env->juart_state = lm32_juart_init();
hw/lm32_boards.c:    env->pic_state = lm32_pic_init(*cpu_irq);
hw/lm32_boards.c:        irq[i] = qdev_get_gpio_in(env->pic_state, i);
hw/lm32_boards.c:    env->juart_state = lm32_juart_init();
hw/kvmvapic.c:    if (env->regs[R_ESP] == 0) {
hw/kvmvapic.c:    if (cpu_memory_rw_debug(env, env->segs[R_FS].base,
hw/kvmvapic.c:        kpcr.self != env->segs[R_FS].base) {
hw/kvmvapic.c:    apic_enable_vapic(env->apic_state, vapic_paddr);
hw/kvmvapic.c:    for (env = first_cpu; env != NULL; env = env->next_cpu) {
hw/kvmvapic.c:        info.apic = env->apic_state;
hw/kvmvapic.c:            rom_paddr = (env->segs[R_CS].base + env->eip) & ROM_BLOCK_MASK;
hw/kvmvapic.c:            patch_byte(env, env->eip - 2, 0x66);
hw/kvmvapic.c:            patch_byte(env, env->eip - 1, 0x90);
hw/kvmvapic.c:        if (update_rom_mapping(s, env, env->eip) < 0) {
hw/kvmvapic.c:            apic_poll_irq(env->apic_state);
hw/an5206.c:    env->vbr = 0;
hw/an5206.c:    env->mbar = AN5206_MBAR_ADDR | 1;
hw/an5206.c:    env->rambar0 = AN5206_RAMBAR_ADDR | 1;
hw/an5206.c:    env->pc = entry;
hw/kvm/clock.c:        for (penv = first_cpu; penv != NULL; penv = penv->next_cpu) {
hw/ppc405_uc.c:    dbsr = env->spr[SPR_40x_DBSR];
hw/ppc405_uc.c:    env->spr[SPR_40x_DBSR] = dbsr;
hw/ppc405_uc.c:    dbsr = env->spr[SPR_40x_DBSR];
hw/ppc405_uc.c:    env->spr[SPR_40x_DBSR] = dbsr;
hw/ppc405_uc.c:        ((qemu_irq *)env->irq_inputs)[PPC40x_INPUT_INT];
hw/ppc405_uc.c:        ((qemu_irq *)env->irq_inputs)[PPC40x_INPUT_CINT];
hw/ppc405_uc.c:        ((qemu_irq *)env->irq_inputs)[PPC40x_INPUT_INT];
hw/ppc405_uc.c:        ((qemu_irq *)env->irq_inputs)[PPC40x_INPUT_CINT];
hw/mips_r4k.c:    env->active_tc.PC = s->vector;
hw/mips_r4k.c:    reset_info->vector = env->active_tc.PC;
hw/mips_r4k.c:    i8259 = i8259_init(isa_bus, env->irq[2]);
hw/xen_machine_pv.c:    env->halted = 1;
hw/armv7m_nvic.c:        return cpu_single_env->cp15.c0_cpuid;
hw/armv7m_nvic.c:        return cpu_single_env->v7m.vecbase;
hw/armv7m_nvic.c:        cpu_single_env->v7m.vecbase = value & 0xffffff80;
hw/openpic.c:  return cpu_single_env->cpu_index;
hw/ppc440_bamboo.c:    ppcemb_tlb_t *tlb = &env->tlb.tlbe[0];
hw/ppc440_bamboo.c:    tlb = &env->tlb.tlbe[1];
hw/ppc440_bamboo.c:    env->gpr[1] = (16<<20) - 8;
hw/ppc440_bamboo.c:    env->gpr[3] = FDT_ADDR;
hw/ppc440_bamboo.c:    env->nip = entry;
hw/ppc440_bamboo.c:    irqs[PPCUIC_OUTPUT_INT] = ((qemu_irq *)env->irq_inputs)[PPC40x_INPUT_INT];
hw/ppc440_bamboo.c:    irqs[PPCUIC_OUTPUT_CINT] = ((qemu_irq *)env->irq_inputs)[PPC40x_INPUT_CINT];
hw/r2d.c:    env->pc = s->vector;
hw/r2d.c:    reset_info->vector = env->pc;
hw/mpc8544_guts.c:        value = env->spr[SPR_PVR];
hw/mpc8544_guts.c:        value = env->spr[SPR_E500_SVR];
hw/arm_boot.c:    env->regs[15] = info->smp_loader_start;
hw/arm_boot.c:    const struct arm_boot_info *info = env->boot_info;
hw/arm_boot.c:            env->regs[15] = info->entry & 0xfffffffe;
hw/arm_boot.c:            env->thumb = info->entry & 1;
hw/arm_boot.c:                env->regs[15] = info->loader_start;
hw/arm_boot.c:    for (; env; env = env->next_cpu) {
hw/arm_boot.c:        env->boot_info = info;
hw/s390-virtio.c:    if (env->halted) {
hw/s390-virtio.c:        env->halted = 0;
hw/s390-virtio.c:        env->exception_index = -1;
hw/s390-virtio.c:    if (env->halted == 0) {
hw/s390-virtio.c:        env->halted = 1;
hw/s390-virtio.c:        env->exception_index = EXCP_HLT;
hw/s390-virtio.c:        tmp_env->halted = 1;
hw/s390-virtio.c:        tmp_env->exception_index = EXCP_HLT;
hw/s390-virtio.c:        tmp_env->storage_keys = storage_keys;
hw/s390-virtio.c:        env->psw.addr = KERN_IMAGE_START;
hw/s390-virtio.c:        env->psw.mask = 0x0000000180000000ULL;
hw/s390-virtio.c:        env->psw.addr = ZIPL_START;
hw/s390-virtio.c:        env->psw.mask = 0x0000000180000000ULL;
hw/xics.c:    icp_set_cppr(spapr->icp, env->cpu_index, cppr);
hw/xics.c:    uint32_t xirr = icp_accept(spapr->icp->ss + env->cpu_index);
hw/xics.c:    icp_eoi(spapr->icp, env->cpu_index, xirr);
hw/xics.c:    for (env = first_cpu; env != NULL; env = env->next_cpu) {
hw/xics.c:        if (env->cpu_index > max_server_num) {
hw/xics.c:            max_server_num = env->cpu_index;
hw/xics.c:    for (env = first_cpu; env != NULL; env = env->next_cpu) {
hw/xics.c:        struct icp_server_state *ss = &icp->ss[env->cpu_index];
hw/xics.c:            ss->output = env->irq_inputs[POWER7_INPUT_INT];
hw/xics.c:            ss->output = env->irq_inputs[PPC970_INPUT_INT];
hw/leon3.c:    env->halted = 0;
hw/leon3.c:    env->pc     = s->entry;
hw/leon3.c:    env->npc    = s->entry + 4;
hw/leon3.c:    env->pil_in = pil_in;
hw/leon3.c:    if (env->pil_in && (env->interrupt_index == 0 ||
hw/leon3.c:                        (env->interrupt_index & ~15) == TT_EXTINT)) {
hw/leon3.c:            if (env->pil_in & (1 << i)) {
hw/leon3.c:                int old_interrupt = env->interrupt_index;
hw/leon3.c:                env->interrupt_index = TT_EXTINT | i;
hw/leon3.c:                if (old_interrupt != env->interrupt_index) {
hw/leon3.c:    } else if (!env->pil_in && (env->interrupt_index & ~15) == TT_EXTINT) {
hw/leon3.c:        trace_leon3_reset_irq(env->interrupt_index & 15);
hw/leon3.c:        env->interrupt_index = 0;
hw/leon3.c:    env->qemu_irq_ack = leon3_irq_manager;
hw/leon3.c:            env->pc = entry;
hw/leon3.c:            env->npc = entry + 4;
hw/ppc405_boards.c:        env->gpr[3] = bdloc;
hw/ppc405_boards.c:        env->gpr[4] = initrd_base;
hw/ppc405_boards.c:        env->gpr[5] = initrd_size;
hw/ppc405_boards.c:            env->gpr[6] = bdloc;
hw/ppc405_boards.c:            env->gpr[7] = bdloc + len;
hw/ppc405_boards.c:            env->gpr[6] = 0;
hw/ppc405_boards.c:            env->gpr[7] = 0;
hw/ppc405_boards.c:        env->nip = KERNEL_LOAD_ADDR;
hw/spapr.c:    for (env = first_cpu; env != NULL; env = env->next_cpu) {
hw/spapr.c:                                    cpu_to_be32(env->numa_node),
hw/spapr.c:                                    cpu_to_be32(env->cpu_index)};
hw/spapr.c:        if ((env->cpu_index % smt) != 0) {
hw/spapr.c:                 env->cpu_index);
hw/spapr.c:    for (env = first_cpu; env != NULL; env = env->next_cpu) {
hw/spapr.c:        int index = env->cpu_index;
hw/spapr.c:        _FDT((fdt_property_cell(fdt, "cpu-version", env->spr[SPR_PVR])));
hw/spapr.c:                                env->dcache_line_size)));
hw/spapr.c:                                env->icache_line_size)));
hw/spapr.c:        _FDT((fdt_property_cell(fdt, "ibm,slb-size", env->slb_nr)));
hw/spapr.c:        if (env->mmu_model & POWERPC_MMU_1TSEG) {
hw/spapr.c:        if (env->insns_flags & PPC_ALTIVEC) {
hw/spapr.c:            uint32_t vmx = (env->insns_flags2 & PPC2_VSX) ? 2 : 1;
hw/spapr.c:        if (env->insns_flags2 & PPC2_DFP) {
hw/spapr.c:    env->gpr[3] = spapr_hypercall(env, env->gpr[3], &env->gpr[4]);
hw/spapr.c:        env->hreset_vector = 0x60;
hw/spapr.c:        env->hreset_excp_prefix = 0;
hw/spapr.c:        env->gpr[3] = env->cpu_index;
hw/spapr.c:    for (env = first_cpu; env != NULL; env = env->next_cpu) {
hw/spapr.c:        env->external_htab = spapr->htab;
hw/spapr.c:        env->htab_base = -1;
hw/spapr.c:        env->htab_mask = spapr->htab_size - 1;
hw/spapr.c:        env->spr[SPR_SDR1] = (unsigned long)spapr->htab |
hw/spapr.c:        env->spr[SPR_HIOR] = 0;
hw/spapr.c:    for (env = first_cpu; env != NULL; env = env->next_cpu) {
hw/spapr.c:        env->halted = 1;
hw/cris-boot.c:    li = env->load_info;
hw/cris-boot.c:    env->pc = li->entry;
hw/cris-boot.c:        env->regs[8] = 0x56902387; /* RAM boot magic.  */
hw/cris-boot.c:        env->regs[9] = 0x40004000 + li->image_size;
hw/cris-boot.c:        env->regs[10] = 0x87109563;
hw/cris-boot.c:        env->regs[11] = 0x40000000;
hw/cris-boot.c:    env->load_info = li;
hw/mcf5208.c:    env->vbr = 0;
hw/mcf5208.c:    env->pc = entry;
hw/arm_mptimer.c:    if (cpu_single_env->cpu_index >= s->num_cpu) {
hw/arm_mptimer.c:                 s->num_cpu, cpu_single_env->cpu_index);
hw/arm_mptimer.c:    return cpu_single_env->cpu_index;
hw/omap1.c:                (s->env->halted << 6);	/* Quite useless... */
hw/omap1.c:    if (mpu->env->halted)
hw/mips_int.c:        env->CP0_Cause |= 1 << (irq + CP0Ca_IP);
hw/mips_int.c:        env->CP0_Cause &= ~(1 << (irq + CP0Ca_IP));
hw/mips_int.c:    if (env->CP0_Cause & CP0Ca_IP_mask) {
hw/mips_int.c:        env->irq[i] = qi[i];
hw/mips_int.c:    qemu_set_irq(env->irq[irq], level);
hw/microblaze_boot.c:    env->regs[5] = boot_info.cmdline;
hw/microblaze_boot.c:    env->regs[7] = boot_info.fdt;
hw/microblaze_boot.c:    env->sregs[SR_PC] = boot_info.bootstrap_pc;
hw/mips_jazz.c:    rc4030_opaque = rc4030_init(env->irq[6], env->irq[3], &rc4030, &dmas,
hw/mips_jazz.c:    i8259 = i8259_init(isa_bus, env->irq[4]);
hw/ppc_booke.c:                (env->spr[SPR_BOOKE_TSR] & TSR_DIS
hw/ppc_booke.c:                 && env->spr[SPR_BOOKE_TCR] & TCR_DIE));
hw/ppc_booke.c:                (env->spr[SPR_BOOKE_TSR] & TSR_WIS
hw/ppc_booke.c:                 && env->spr[SPR_BOOKE_TCR] & TCR_WIE));
hw/ppc_booke.c:                (env->spr[SPR_BOOKE_TSR] & TSR_FIS
hw/ppc_booke.c:                 && env->spr[SPR_BOOKE_TCR] & TCR_FIE));
hw/ppc_booke.c:    uint8_t fp = (env->spr[SPR_BOOKE_TCR] & TCR_FP_MASK) >> TCR_FP_SHIFT;
hw/ppc_booke.c:    if (tb_env->flags & PPC_TIMER_E500) {
hw/ppc_booke.c:        uint32_t fpext = (env->spr[SPR_BOOKE_TCR] & TCR_E500_FPEXT_MASK)
hw/ppc_booke.c:        fp = env->fit_period[fp];
hw/ppc_booke.c:    uint8_t wp = (env->spr[SPR_BOOKE_TCR] & TCR_WP_MASK) >> TCR_WP_SHIFT;
hw/ppc_booke.c:    if (tb_env->flags & PPC_TIMER_E500) {
hw/ppc_booke.c:        uint32_t wpext = (env->spr[SPR_BOOKE_TCR] & TCR_E500_WPEXT_MASK)
hw/ppc_booke.c:        wp = env->wdt_period[wp];
hw/ppc_booke.c:    ppc_tb_t *tb_env = env->tb_env;
hw/ppc_booke.c:    tb  = cpu_ppc_get_tb(tb_env, now, tb_env->tb_offset);
hw/ppc_booke.c:    *next = now + muldiv64(lapse, get_ticks_per_sec(), tb_env->tb_freq);
hw/ppc_booke.c:    env->spr[SPR_BOOKE_TSR] |= TSR_DIS;
hw/ppc_booke.c:    if (env->spr[SPR_BOOKE_TCR] & TCR_ARE) {
hw/ppc_booke.c:        cpu_ppc_store_decr(env, env->spr[SPR_BOOKE_DECAR]);
hw/ppc_booke.c:    tb_env = env->tb_env;
hw/ppc_booke.c:    booke_timer = tb_env->opaque;
hw/ppc_booke.c:    env->spr[SPR_BOOKE_TSR] |= TSR_FIS;
hw/ppc_booke.c:    tb_env = env->tb_env;
hw/ppc_booke.c:    booke_timer = tb_env->opaque;
hw/ppc_booke.c:    env->spr[SPR_BOOKE_TSR] &= ~val;
hw/ppc_booke.c:    ppc_tb_t *tb_env = env->tb_env;
hw/ppc_booke.c:    booke_timer_t *booke_timer = tb_env->opaque;
hw/ppc_booke.c:    tb_env = env->tb_env;
hw/ppc_booke.c:    env->spr[SPR_BOOKE_TCR] = val;
hw/ppc_booke.c:    env->tb_env = tb_env;
hw/ppc_booke.c:    tb_env->flags = flags | PPC_TIMER_BOOKE | PPC_DECR_ZERO_TRIGGERED;
hw/ppc_booke.c:    tb_env->tb_freq    = freq;
hw/ppc_booke.c:    tb_env->decr_freq  = freq;
hw/ppc_booke.c:    tb_env->opaque     = booke_timer;
hw/ppc_booke.c:    tb_env->decr_timer = qemu_new_timer_ns(vm_clock, &booke_decr_cb, env);
hw/xtensa_pic.c:    uint32_t old_ccount = env->sregs[CCOUNT];
hw/xtensa_pic.c:    env->sregs[CCOUNT] += d;
hw/xtensa_pic.c:    if (xtensa_option_enabled(env->config, XTENSA_OPTION_TIMER_INTERRUPT)) {
hw/xtensa_pic.c:        for (i = 0; i < env->config->nccompare; ++i) {
hw/xtensa_pic.c:            if (env->sregs[CCOMPARE + i] - old_ccount <= d) {
hw/xtensa_pic.c:    uint32_t int_set_enabled = env->sregs[INTSET] & env->sregs[INTENABLE];
hw/xtensa_pic.c:    if (env->halted) {
hw/xtensa_pic.c:                muldiv64(now - env->halt_clock,
hw/xtensa_pic.c:                    env->config->clock_freq_khz, 1000000));
hw/xtensa_pic.c:        env->halt_clock = now;
hw/xtensa_pic.c:    for (level = env->config->nlevel; level > minlevel; --level) {
hw/xtensa_pic.c:        if (env->config->level_mask[level] & int_set_enabled) {
hw/xtensa_pic.c:            env->pending_irq_level = level;
hw/xtensa_pic.c:                    env->pc, env->regs[0], env->sregs[PS],
hw/xtensa_pic.c:                    env->sregs[INTSET], env->sregs[INTENABLE],
hw/xtensa_pic.c:                    env->sregs[CCOUNT]);
hw/xtensa_pic.c:    env->pending_irq_level = 0;
hw/xtensa_pic.c:    if (irq >= env->config->ninterrupt) {
hw/xtensa_pic.c:            env->sregs[INTSET] |= irq_bit;
hw/xtensa_pic.c:        } else if (env->config->interrupt[irq].inttype == INTTYPE_LEVEL) {
hw/xtensa_pic.c:            env->sregs[INTSET] &= ~irq_bit;
hw/xtensa_pic.c:    qemu_set_irq(env->irq_inputs[env->config->timerint[id]], active);
hw/xtensa_pic.c:    uint32_t wake_ccount = env->sregs[CCOUNT] - 1;
hw/xtensa_pic.c:    for (i = 0; i < env->config->nccompare; ++i) {
hw/xtensa_pic.c:        if (env->sregs[CCOMPARE + i] - env->sregs[CCOUNT] <
hw/xtensa_pic.c:                wake_ccount - env->sregs[CCOUNT]) {
hw/xtensa_pic.c:            wake_ccount = env->sregs[CCOMPARE + i];
hw/xtensa_pic.c:    env->wake_ccount = wake_ccount;
hw/xtensa_pic.c:    qemu_mod_timer(env->ccompare_timer, env->halt_clock +
hw/xtensa_pic.c:            muldiv64(wake_ccount - env->sregs[CCOUNT],
hw/xtensa_pic.c:                1000000, env->config->clock_freq_khz));
hw/xtensa_pic.c:    if (env->halted) {
hw/xtensa_pic.c:        env->halt_clock = qemu_get_clock_ns(vm_clock);
hw/xtensa_pic.c:        xtensa_advance_ccount(env, env->wake_ccount - env->sregs[CCOUNT]);
hw/xtensa_pic.c:            env->sregs[CCOUNT] = env->wake_ccount + 1;
hw/xtensa_pic.c:    env->irq_inputs = (void **)qemu_allocate_irqs(
hw/xtensa_pic.c:            xtensa_set_irq, env, env->config->ninterrupt);
hw/xtensa_pic.c:    if (xtensa_option_enabled(env->config, XTENSA_OPTION_TIMER_INTERRUPT) &&
hw/xtensa_pic.c:            env->config->nccompare > 0) {
hw/xtensa_pic.c:        env->ccompare_timer =
hw/xtensa_pic.c:    if (extint < env->config->nextint) {
hw/xtensa_pic.c:        unsigned irq = env->config->extint[extint];
hw/xtensa_pic.c:        return env->irq_inputs[irq];
hw/alpha_typhoon.c:        ret = s->cchip.misc | (env->cpu_index & 3);
hw/alpha_typhoon.c:            env->alarm_timer = qemu_new_timer_ns(rtc_clock,
hw/mips_fulong2e.c:    stl_raw(p++, 0x3c070000 | (loaderparams.ram_size >> 16));      /* lui a3, high(env->ram_size) */
hw/mips_fulong2e.c:    stl_raw(p++, 0x34e70000 | (loaderparams.ram_size & 0xffff));   /* ori a3, a3, low(env->ram_size) */
hw/mips_fulong2e.c:        env->CP0_Status &= ~((1 << CP0St_BEV) | (1 << CP0St_ERL));
hw/mips_fulong2e.c:    pci_bus = bonito_init((qemu_irq *)&(env->irq[2]));
hw/mips_fulong2e.c:    i8259 = i8259_init(isa_bus, env->irq[5]);
hw/mips_mipssim.c:    env->active_tc.PC = s->vector & ~(target_ulong)1;
hw/mips_mipssim.c:        env->hflags |= MIPS_HFLAG_M16;
hw/mips_mipssim.c:    reset_info->vector = env->active_tc.PC;
hw/mips_mipssim.c:        env->active_tc.PC = (target_long)(int32_t)0xbfc00000;
hw/mips_mipssim.c:        serial_init(0x3f8, env->irq[4], 115200, serial_hds[0]);
hw/mips_mipssim.c:        mipsnet_init(0x4200, env->irq[2], &nd_table[0]);
hw/mips_timer.c:        idx = lfsr % (env->tlb->nb_tlb - env->CP0_Wired) + env->CP0_Wired;
hw/mips_timer.c:    wait = env->CP0_Compare - env->CP0_Count -
hw/mips_timer.c:    qemu_mod_timer(env->timer, next);
hw/mips_timer.c:    if (env->insn_flags & ISA_MIPS32R2) {
hw/mips_timer.c:        env->CP0_Cause |= 1 << CP0Ca_TI;
hw/mips_timer.c:    qemu_irq_raise(env->irq[(env->CP0_IntCtl >> CP0IntCtl_IPTI) & 0x7]);
hw/mips_timer.c:    if (env->CP0_Cause & (1 << CP0Ca_DC)) {
hw/mips_timer.c:        return env->CP0_Count;
hw/mips_timer.c:        if (qemu_timer_pending(env->timer)
hw/mips_timer.c:            && qemu_timer_expired(env->timer, now)) {
hw/mips_timer.c:        return env->CP0_Count +
hw/mips_timer.c:    if (env->CP0_Cause & (1 << CP0Ca_DC))
hw/mips_timer.c:        env->CP0_Count = count;
hw/mips_timer.c:        env->CP0_Count =
hw/mips_timer.c:    env->CP0_Compare = value;
hw/mips_timer.c:    if (!(env->CP0_Cause & (1 << CP0Ca_DC)))
hw/mips_timer.c:    if (env->insn_flags & ISA_MIPS32R2)
hw/mips_timer.c:        env->CP0_Cause &= ~(1 << CP0Ca_TI);
hw/mips_timer.c:    qemu_irq_lower(env->irq[(env->CP0_IntCtl >> CP0IntCtl_IPTI) & 0x7]);
hw/mips_timer.c:    cpu_mips_store_count(env, env->CP0_Count);
hw/mips_timer.c:    env->CP0_Count += (uint32_t)muldiv64(qemu_get_clock_ns(vm_clock),
hw/mips_timer.c:    if (env->CP0_Cause & (1 << CP0Ca_DC))
hw/mips_timer.c:    env->CP0_Count++;
hw/mips_timer.c:    env->CP0_Count--;
hw/mips_timer.c:    env->timer = qemu_new_timer_ns(vm_clock, &mips_timer_cb, env);
hw/mips_timer.c:    env->CP0_Compare = 0;
hw/ppce500_mpc8544ds.c:        for (env = first_cpu; env != NULL; env = env->next_cpu) {
hw/ppce500_mpc8544ds.c:            if (env->cpu_index == i) {
hw/ppce500_mpc8544ds.c:        snprintf(cpu_name, sizeof(cpu_name), "/cpus/PowerPC,8544@%x", env->cpu_index);
hw/ppce500_mpc8544ds.c:        qemu_devtree_setprop_cell(fdt, cpu_name, "reg", env->cpu_index);
hw/ppce500_mpc8544ds.c:                                  env->dcache_line_size);
hw/ppce500_mpc8544ds.c:                                  env->icache_line_size);
hw/ppce500_mpc8544ds.c:        if (env->cpu_index) {
hw/ppce500_mpc8544ds.c:    env->tlb_dirty = true;
hw/ppce500_mpc8544ds.c:    env->halted = 1;
hw/ppce500_mpc8544ds.c:    env->exception_index = EXCP_HLT;
hw/ppce500_mpc8544ds.c:    struct boot_info *bi = env->load_info;
hw/ppce500_mpc8544ds.c:    env->halted = 0;
hw/ppce500_mpc8544ds.c:    env->gpr[1] = (16<<20) - 8;
hw/ppce500_mpc8544ds.c:    env->gpr[3] = bi->dt_base;
hw/ppce500_mpc8544ds.c:    env->nip = bi->entry;
hw/ppce500_mpc8544ds.c:        input = (qemu_irq *)env->irq_inputs;
hw/ppce500_mpc8544ds.c:        env->spr[SPR_BOOKE_PIR] = env->cpu_index = i;
hw/ppce500_mpc8544ds.c:            env->load_info = boot_info;
hw/ppce500_mpc8544ds.c:        boot_info = env->load_info;
hw/sun4m.c:    if (env->pil_in && (env->interrupt_index == 0 ||
hw/sun4m.c:                        (env->interrupt_index & ~15) == TT_EXTINT)) {
hw/sun4m.c:            if (env->pil_in & (1 << i)) {
hw/sun4m.c:                int old_interrupt = env->interrupt_index;
hw/sun4m.c:                env->interrupt_index = TT_EXTINT | i;
hw/sun4m.c:                if (old_interrupt != env->interrupt_index) {
hw/sun4m.c:    } else if (!env->pil_in && (env->interrupt_index & ~15) == TT_EXTINT) {
hw/sun4m.c:        trace_sun4m_cpu_reset_interrupt(env->interrupt_index & 15);
hw/sun4m.c:        env->interrupt_index = 0;
hw/sun4m.c:    env->halted = 0;
hw/sun4m.c:        env->pil_in |= 1 << irq;
hw/sun4m.c:        env->pil_in &= ~(1 << irq);
hw/sun4m.c:    env->halted = 0;
hw/sun4m.c:    env->halted = 1;
hw/sun4m.c:        env->halted = 1;
hw/sun4m.c:    env->prom_addr = prom_addr;
hw/virtex_ml507.c:    ppcemb_tlb_t *tlb = &env->tlb.tlbe[0];
hw/virtex_ml507.c:    tlb = &env->tlb.tlbe[1];
hw/virtex_ml507.c:    irqs[PPCUIC_OUTPUT_INT] = ((qemu_irq *)env->irq_inputs)[PPC40x_INPUT_INT];
hw/virtex_ml507.c:    irqs[PPCUIC_OUTPUT_CINT] = ((qemu_irq *)env->irq_inputs)[PPC40x_INPUT_CINT];
hw/virtex_ml507.c:    struct boot_info *bi = env->load_info;
hw/virtex_ml507.c:    env->gpr[1] = (16<<20) - 8;
hw/virtex_ml507.c:    env->gpr[3] = bi->fdt;
hw/virtex_ml507.c:    env->nip = bi->bootstrap_pc;
hw/virtex_ml507.c:    env->gpr[6] = tswap32(EPAPR_MAGIC);
hw/virtex_ml507.c:    env->gpr[7] = bi->ima_size;
hw/virtex_ml507.c:    cpu_irq = (qemu_irq *) &env->irq_inputs[PPC40x_INPUT_INT];
hw/virtex_ml507.c:    env->load_info = &boot_info;
hw/spapr_hcall.c:    if ((pte_index * HASH_PTE_SIZE_64) & ~env->htab_mask) {
hw/spapr_hcall.c:        hpte = env->external_htab + (pte_index * HASH_PTE_SIZE_64);
hw/spapr_hcall.c:        hpte = env->external_htab + (pte_index * HASH_PTE_SIZE_64);
hw/spapr_hcall.c:    if ((ptex * HASH_PTE_SIZE_64) & ~env->htab_mask) {
hw/spapr_hcall.c:    hpte = env->external_htab + (ptex * HASH_PTE_SIZE_64);
hw/spapr_hcall.c:    if ((pte_index * HASH_PTE_SIZE_64) & ~env->htab_mask) {
hw/spapr_hcall.c:    hpte = env->external_htab + (pte_index * HASH_PTE_SIZE_64);
hw/spapr_hcall.c:    if (vpa % env->dcache_line_size) {
hw/spapr_hcall.c:    env->vpa = vpa;
hw/spapr_hcall.c:    tmp = ldub_phys(env->vpa + VPA_SHARED_PROC_OFFSET);
hw/spapr_hcall.c:    stb_phys(env->vpa + VPA_SHARED_PROC_OFFSET, tmp);
hw/spapr_hcall.c:    if (env->slb_shadow) {
hw/spapr_hcall.c:    if (env->dispatch_trace_log) {
hw/spapr_hcall.c:    env->vpa = 0;
hw/spapr_hcall.c:    if (!env->vpa) {
hw/spapr_hcall.c:    env->slb_shadow = addr;
hw/spapr_hcall.c:    env->slb_shadow = 0;
hw/spapr_hcall.c:    if (!env->vpa) {
hw/spapr_hcall.c:    env->dispatch_trace_log = addr;
hw/spapr_hcall.c:    env->dtl_size = size;
hw/spapr_hcall.c:    env->dispatch_trace_log = 0;
hw/spapr_hcall.c:    env->dtl_size = 0;
hw/spapr_hcall.c:    for (tenv = first_cpu; tenv; tenv = tenv->next_cpu) {
hw/spapr_hcall.c:        if (tenv->cpu_index == procno) {
hw/spapr_hcall.c:    env->msr |= (1ULL << MSR_EE);
hw/spapr_hcall.c:        env->halted = 1;
hw/ppce500_spin.c:    env->tlb_dirty = true;
hw/ppce500_spin.c:    stl_p(&curspin->pir, env->spr[SPR_PIR]);
hw/ppce500_spin.c:    env->nip = ldq_p(&curspin->addr) & (map_size - 1);
hw/ppce500_spin.c:    env->gpr[3] = ldq_p(&curspin->r3);
hw/ppce500_spin.c:    env->gpr[4] = 0;
hw/ppce500_spin.c:    env->gpr[5] = 0;
hw/ppce500_spin.c:    env->gpr[6] = 0;
hw/ppce500_spin.c:    env->gpr[7] = map_size;
hw/ppce500_spin.c:    env->gpr[8] = 0;
hw/ppce500_spin.c:    env->gpr[9] = 0;
hw/ppce500_spin.c:    env->halted = 0;
hw/ppce500_spin.c:    env->exception_index = -1;
hw/ppce500_spin.c:    env->stopped = 0;
hw/ppce500_spin.c:    for (env = first_cpu; env != NULL; env = env->next_cpu) {
hw/ppce500_spin.c:        if (env->cpu_index == env_idx) {
hw/ppce500_spin.c:    if (!env->cpu_index) {
hw/mips_malta.c:    env->mvp->CP0_MVPConf0 |= ((smp_cpus - 1) << CP0MVPC0_PVPE) |
hw/mips_malta.c:                         ((smp_cpus * env->nr_threads - 1) << CP0MVPC0_PTC);
hw/mips_malta.c:        env->CP0_Status &= ~((1 << CP0St_BEV) | (1 << CP0St_ERL));
hw/mips_malta.c:    malta_fpga_init(system_memory, FPGA_ADDRESS, env->irq[2], serial_hds[2]);
hw/mips_malta.c:    s->i8259 = i8259_init(isa_bus, env->irq[2]);
hw/spapr_rtas.c:    for (env = first_cpu; env; env = env->next_cpu) {
hw/spapr_rtas.c:        if (env->cpu_index != id) {
hw/spapr_rtas.c:        if (env->halted) {
hw/spapr_rtas.c:    for (env = first_cpu; env; env = env->next_cpu) {
hw/spapr_rtas.c:        if (env->cpu_index != id) {
hw/spapr_rtas.c:        if (!env->halted) {
hw/spapr_rtas.c:        env->msr = (1ULL << MSR_SF) | (1ULL << MSR_ME);
hw/spapr_rtas.c:        env->nip = start;
hw/spapr_rtas.c:        env->gpr[3] = r3;
hw/spapr_rtas.c:        env->halted = 0;
hw/sun4u.c:    uint32_t pil = env->pil_in |
hw/sun4u.c:                  (env->softint & ~(SOFTINT_TIMER | SOFTINT_STIMER));
hw/sun4u.c:    if (env->ivec_status & 0x20) {
hw/sun4u.c:    if (env->softint & (SOFTINT_TIMER | SOFTINT_STIMER)) {
hw/sun4u.c:    if (pil < (2 << env->psrpil)){
hw/sun4u.c:        if (env->interrupt_request & CPU_INTERRUPT_HARD) {
hw/sun4u.c:                           env->interrupt_index);
hw/sun4u.c:            env->interrupt_index = 0;
hw/sun4u.c:        for (i = 15; i > env->psrpil; i--) {
hw/sun4u.c:                int old_interrupt = env->interrupt_index;
hw/sun4u.c:                if (unlikely(env->tl > 0 && cpu_tsptr(env)->tt > new_interrupt
hw/sun4u.c:                                   env->tl, cpu_tsptr(env)->tt, new_interrupt);
hw/sun4u.c:                    env->interrupt_index = new_interrupt;
hw/sun4u.c:    } else if (env->interrupt_request & CPU_INTERRUPT_HARD) {
hw/sun4u.c:                       pil, env->pil_in, env->softint, env->interrupt_index);
hw/sun4u.c:        env->interrupt_index = 0;
hw/sun4u.c:    env->halted = 0;
hw/sun4u.c:        if (!(env->ivec_status & 0x20)) {
hw/sun4u.c:            env->halted = 0;
hw/sun4u.c:            env->interrupt_index = TT_IVEC;
hw/sun4u.c:            env->ivec_status |= 0x20;
hw/sun4u.c:            env->ivec_data[0] = (0x1f << 6) | irq;
hw/sun4u.c:            env->ivec_data[1] = 0;
hw/sun4u.c:            env->ivec_data[2] = 0;
hw/sun4u.c:        if (env->ivec_status & 0x20) {
hw/sun4u.c:            env->ivec_status &= ~0x20;
hw/sun4u.c:    cpu_timer_reset(env->tick);
hw/sun4u.c:    cpu_timer_reset(env->stick);
hw/sun4u.c:    cpu_timer_reset(env->hstick);
hw/sun4u.c:    env->gregs[1] = 0; // Memory start
hw/sun4u.c:    env->gregs[2] = ram_size; // Memory size
hw/sun4u.c:    env->gregs[3] = 0; // Machine description XXX
hw/sun4u.c:        env->pc = s->prom_addr + 0x20ULL;
hw/sun4u.c:        env->pc = s->prom_addr + 0x40ULL;
hw/sun4u.c:    env->npc = env->pc + 4;
hw/sun4u.c:    CPUTimer* timer = env->tick;
hw/sun4u.c:    env->softint |= SOFTINT_TIMER;
hw/sun4u.c:    CPUTimer* timer = env->stick;
hw/sun4u.c:    env->softint |= SOFTINT_STIMER;
hw/sun4u.c:    CPUTimer* timer = env->hstick;
hw/sun4u.c:    env->softint |= SOFTINT_STIMER;
hw/sun4u.c:    env->tick = cpu_timer_create("tick", env, tick_irq,
hw/sun4u.c:    env->stick = cpu_timer_create("stick", env, stick_irq,
hw/sun4u.c:    env->hstick = cpu_timer_create("hstick", env, hstick_irq,
hw/petalogix_s3adsp1800_mmu.c:    env->pvr.regs[10] = 0x0c000000; /* spartan 3a dsp family.  */
hw/milkymist.c:    env->pc = reset_info->bootstrap_pc;
hw/milkymist.c:    env->regs[R_R1] = reset_info->cmdline_base;
hw/milkymist.c:    env->regs[R_R2] = reset_info->initrd_base;
hw/milkymist.c:    env->regs[R_R3] = reset_info->initrd_base + reset_info->initrd_size;
hw/milkymist.c:    env->eba = reset_info->flash_base;
hw/milkymist.c:    env->deba = reset_info->flash_base;
hw/milkymist.c:    env->pic_state = lm32_pic_init(*cpu_irq);
hw/milkymist.c:        irq[i] = qdev_get_gpio_in(env->pic_state, i);
hw/milkymist.c:    env->juart_state = lm32_juart_init();
hw/ppc.c:    unsigned int old_pending = env->pending_interrupts;
hw/ppc.c:        env->pending_interrupts |= 1 << n_IRQ;
hw/ppc.c:        env->pending_interrupts &= ~(1 << n_IRQ);
hw/ppc.c:        if (env->pending_interrupts == 0)
hw/ppc.c:    if (old_pending != env->pending_interrupts) {
hw/ppc.c:                env->pending_interrupts, env->interrupt_request);
hw/ppc.c:    cur_level = (env->irq_input_state >> pin) & 1;
hw/ppc.c:                env->halted = 1;
hw/ppc.c:            env->irq_input_state |= 1 << pin;
hw/ppc.c:            env->irq_input_state &= ~(1 << pin);
hw/ppc.c:    env->irq_inputs = (void **)qemu_allocate_irqs(&ppc6xx_set_irq, env,
hw/ppc.c:    cur_level = (env->irq_input_state >> pin) & 1;
hw/ppc.c:                env->halted = 1;
hw/ppc.c:                env->halted = 0;
hw/ppc.c:            env->irq_input_state |= 1 << pin;
hw/ppc.c:            env->irq_input_state &= ~(1 << pin);
hw/ppc.c:    env->irq_inputs = (void **)qemu_allocate_irqs(&ppc970_set_irq, env,
hw/ppc.c:        env->irq_input_state |= 1 << pin;
hw/ppc.c:        env->irq_input_state &= ~(1 << pin);
hw/ppc.c:    env->irq_inputs = (void **)qemu_allocate_irqs(&power7_set_irq, env,
hw/ppc.c:    cur_level = (env->irq_input_state >> pin) & 1;
hw/ppc.c:                env->halted = 1;
hw/ppc.c:                env->halted = 0;
hw/ppc.c:            env->irq_input_state |= 1 << pin;
hw/ppc.c:            env->irq_input_state &= ~(1 << pin);
hw/ppc.c:    env->irq_inputs = (void **)qemu_allocate_irqs(&ppc40x_set_irq,
hw/ppc.c:    cur_level = (env->irq_input_state >> pin) & 1;
hw/ppc.c:            env->irq_input_state |= 1 << pin;
hw/ppc.c:            env->irq_input_state &= ~(1 << pin);
hw/ppc.c:    env->irq_inputs = (void **)qemu_allocate_irqs(&ppce500_set_irq,
hw/ppc.c:    return muldiv64(vmclk, tb_env->tb_freq, get_ticks_per_sec()) + tb_offset;
hw/ppc.c:    ppc_tb_t *tb_env = env->tb_env;
hw/ppc.c:        return env->spr[SPR_TBL];
hw/ppc.c:    tb = cpu_ppc_get_tb(tb_env, qemu_get_clock_ns(vm_clock), tb_env->tb_offset);
hw/ppc.c:    ppc_tb_t *tb_env = env->tb_env;
hw/ppc.c:    tb = cpu_ppc_get_tb(tb_env, qemu_get_clock_ns(vm_clock), tb_env->tb_offset);
hw/ppc.c:        return env->spr[SPR_TBU];
hw/ppc.c:    *tb_offsetp = value - muldiv64(vmclk, tb_env->tb_freq, get_ticks_per_sec());
hw/ppc.c:    ppc_tb_t *tb_env = env->tb_env;
hw/ppc.c:    tb = cpu_ppc_get_tb(tb_env, qemu_get_clock_ns(vm_clock), tb_env->tb_offset);
hw/ppc.c:                     &tb_env->tb_offset, tb | (uint64_t)value);
hw/ppc.c:    ppc_tb_t *tb_env = env->tb_env;
hw/ppc.c:    tb = cpu_ppc_get_tb(tb_env, qemu_get_clock_ns(vm_clock), tb_env->tb_offset);
hw/ppc.c:                     &tb_env->tb_offset, ((uint64_t)value << 32) | tb);
hw/ppc.c:    ppc_tb_t *tb_env = env->tb_env;
hw/ppc.c:    tb = cpu_ppc_get_tb(tb_env, qemu_get_clock_ns(vm_clock), tb_env->atb_offset);
hw/ppc.c:    ppc_tb_t *tb_env = env->tb_env;
hw/ppc.c:    tb = cpu_ppc_get_tb(tb_env, qemu_get_clock_ns(vm_clock), tb_env->atb_offset);
hw/ppc.c:    ppc_tb_t *tb_env = env->tb_env;
hw/ppc.c:    tb = cpu_ppc_get_tb(tb_env, qemu_get_clock_ns(vm_clock), tb_env->atb_offset);
hw/ppc.c:                     &tb_env->atb_offset, tb | (uint64_t)value);
hw/ppc.c:    ppc_tb_t *tb_env = env->tb_env;
hw/ppc.c:    tb = cpu_ppc_get_tb(tb_env, qemu_get_clock_ns(vm_clock), tb_env->atb_offset);
hw/ppc.c:                     &tb_env->atb_offset, ((uint64_t)value << 32) | tb);
hw/ppc.c:    ppc_tb_t *tb_env = env->tb_env;
hw/ppc.c:    if (tb_env->tb_freq != 0) {
hw/ppc.c:        tb = cpu_ppc_get_tb(tb_env, vmclk, tb_env->tb_offset);
hw/ppc.c:        atb = cpu_ppc_get_tb(tb_env, vmclk, tb_env->atb_offset);
hw/ppc.c:        cpu_ppc_store_tb(tb_env, vmclk, &tb_env->tb_offset, tb);
hw/ppc.c:        cpu_ppc_store_tb(tb_env, vmclk, &tb_env->atb_offset, atb);
hw/ppc.c:        tb_env->tb_freq = 0;
hw/ppc.c:    ppc_tb_t *tb_env = env->tb_env;
hw/ppc.c:    if (tb_env->tb_freq == 0) {
hw/ppc.c:        tb = tb_env->tb_offset;
hw/ppc.c:        atb = tb_env->atb_offset;
hw/ppc.c:        tb_env->tb_freq = tb_env->decr_freq;
hw/ppc.c:        cpu_ppc_store_tb(tb_env, vmclk, &tb_env->tb_offset, tb);
hw/ppc.c:        cpu_ppc_store_tb(tb_env, vmclk, &tb_env->atb_offset, atb);
hw/ppc.c:    ppc_tb_t *tb_env = env->tb_env;
hw/ppc.c:        decr = muldiv64(diff, tb_env->decr_freq, get_ticks_per_sec());
hw/ppc.c:    } else if (tb_env->flags & PPC_TIMER_BOOKE) {
hw/ppc.c:        decr = -muldiv64(-diff, tb_env->decr_freq, get_ticks_per_sec());
hw/ppc.c:    ppc_tb_t *tb_env = env->tb_env;
hw/ppc.c:        return env->spr[SPR_DECR];
hw/ppc.c:    return _cpu_ppc_load_decr(env, tb_env->decr_next);
hw/ppc.c:    ppc_tb_t *tb_env = env->tb_env;
hw/ppc.c:    return _cpu_ppc_load_decr(env, tb_env->hdecr_next);
hw/ppc.c:    ppc_tb_t *tb_env = env->tb_env;
hw/ppc.c:    diff = qemu_get_clock_ns(vm_clock) - tb_env->purr_start;
hw/ppc.c:    return tb_env->purr_load + muldiv64(diff, tb_env->tb_freq, get_ticks_per_sec());
hw/ppc.c:    ppc_tb_t *tb_env = env->tb_env;
hw/ppc.c:    next = now + muldiv64(value, get_ticks_per_sec(), tb_env->decr_freq);
hw/ppc.c:    if ((tb_env->flags & PPC_DECR_UNDERFLOW_TRIGGERED)
hw/ppc.c:    ppc_tb_t *tb_env = env->tb_env;
hw/ppc.c:    __cpu_ppc_store_decr(env, &tb_env->decr_next, tb_env->decr_timer,
hw/ppc.c:    ppc_tb_t *tb_env = env->tb_env;
hw/ppc.c:    if (tb_env->hdecr_timer != NULL) {
hw/ppc.c:        __cpu_ppc_store_decr(env, &tb_env->hdecr_next, tb_env->hdecr_timer,
hw/ppc.c:    ppc_tb_t *tb_env = env->tb_env;
hw/ppc.c:    tb_env->purr_load = value;
hw/ppc.c:    tb_env->purr_start = qemu_get_clock_ns(vm_clock);
hw/ppc.c:    ppc_tb_t *tb_env = env->tb_env;
hw/ppc.c:    tb_env->tb_freq = freq;
hw/ppc.c:    tb_env->decr_freq = freq;
hw/ppc.c:    env->tb_env = tb_env;
hw/ppc.c:    tb_env->flags = PPC_DECR_UNDERFLOW_TRIGGERED;
hw/ppc.c:    tb_env->decr_timer = qemu_new_timer_ns(vm_clock, &cpu_ppc_decr_cb, env);
hw/ppc.c:        tb_env->hdecr_timer = qemu_new_timer_ns(vm_clock, &cpu_ppc_hdecr_cb, env);
hw/ppc.c:        tb_env->hdecr_timer = NULL;
hw/ppc.c:    tb_env = env->tb_env;
hw/ppc.c:    ppc40x_timer = tb_env->opaque;
hw/ppc.c:    switch ((env->spr[SPR_40x_TCR] >> 24) & 0x3) {
hw/ppc.c:    next = now + muldiv64(next, get_ticks_per_sec(), tb_env->tb_freq);
hw/ppc.c:    env->spr[SPR_40x_TSR] |= 1 << 26;
hw/ppc.c:    if ((env->spr[SPR_40x_TCR] >> 23) & 0x1)
hw/ppc.c:           (int)((env->spr[SPR_40x_TCR] >> 23) & 0x1),
hw/ppc.c:           env->spr[SPR_40x_TCR], env->spr[SPR_40x_TSR]);
hw/ppc.c:    ppc40x_timer = tb_env->opaque;
hw/ppc.c:        !((env->spr[SPR_40x_TCR] >> 26) & 0x1) ||
hw/ppc.c:        (is_excp && !((env->spr[SPR_40x_TCR] >> 22) & 0x1))) {
hw/ppc.c:        qemu_del_timer(tb_env->decr_timer);
hw/ppc.c:                              get_ticks_per_sec(), tb_env->decr_freq);
hw/ppc.c:            next += tb_env->decr_next - now;
hw/ppc.c:        qemu_mod_timer(tb_env->decr_timer, next);
hw/ppc.c:        tb_env->decr_next = next;
hw/ppc.c:    tb_env = env->tb_env;
hw/ppc.c:    ppc40x_timer = tb_env->opaque;
hw/ppc.c:    env->spr[SPR_40x_TSR] |= 1 << 27;
hw/ppc.c:    if ((env->spr[SPR_40x_TCR] >> 26) & 0x1)
hw/ppc.c:           (int)((env->spr[SPR_40x_TCR] >> 22) & 0x1),
hw/ppc.c:           (int)((env->spr[SPR_40x_TCR] >> 26) & 0x1),
hw/ppc.c:           env->spr[SPR_40x_TCR], env->spr[SPR_40x_TSR],
hw/ppc.c:    tb_env = env->tb_env;
hw/ppc.c:    ppc40x_timer = tb_env->opaque;
hw/ppc.c:    switch ((env->spr[SPR_40x_TCR] >> 30) & 0x3) {
hw/ppc.c:    next = now + muldiv64(next, get_ticks_per_sec(), tb_env->decr_freq);
hw/ppc.c:           env->spr[SPR_40x_TCR], env->spr[SPR_40x_TSR]);
hw/ppc.c:    switch ((env->spr[SPR_40x_TSR] >> 30) & 0x3) {
hw/ppc.c:        env->spr[SPR_40x_TSR] |= 1 << 31;
hw/ppc.c:        env->spr[SPR_40x_TSR] |= 1 << 30;
hw/ppc.c:        if ((env->spr[SPR_40x_TCR] >> 27) & 0x1)
hw/ppc.c:        env->spr[SPR_40x_TSR] &= ~0x30000000;
hw/ppc.c:        env->spr[SPR_40x_TSR] |= env->spr[SPR_40x_TCR] & 0x30000000;
hw/ppc.c:        switch ((env->spr[SPR_40x_TCR] >> 28) & 0x3) {
hw/ppc.c:    tb_env = env->tb_env;
hw/ppc.c:    ppc40x_timer = tb_env->opaque;
hw/ppc.c:    ppc_tb_t *tb_env = env->tb_env;
hw/ppc.c:    tb_env->tb_freq = freq;
hw/ppc.c:    tb_env->decr_freq = freq;
hw/ppc.c:    env->tb_env = tb_env;
hw/ppc.c:    tb_env->flags = PPC_DECR_UNDERFLOW_TRIGGERED;
hw/ppc.c:    tb_env->tb_freq = freq;
hw/ppc.c:    tb_env->decr_freq = freq;
hw/ppc.c:    tb_env->opaque = ppc40x_timer;
hw/ppc.c:        tb_env->decr_timer = qemu_new_timer_ns(vm_clock, &cpu_4xx_pit_cb, env);
hw/ppc.c:    dcr = &dcr_env->dcrn[dcrn];
hw/ppc.c:    if (dcr_env->read_error != NULL)
hw/ppc.c:        return (*dcr_env->read_error)(dcrn);
hw/ppc.c:    dcr = &dcr_env->dcrn[dcrn];
hw/ppc.c:    if (dcr_env->write_error != NULL)
hw/ppc.c:        return (*dcr_env->write_error)(dcrn);
hw/ppc.c:    dcr_env = env->dcr_env;
hw/ppc.c:    dcr = &dcr_env->dcrn[dcrn];
hw/ppc.c:    dcr_env->read_error = read_error;
hw/ppc.c:    dcr_env->write_error = write_error;
hw/ppc.c:    env->dcr_env = dcr_env;
hw/dummy_m68k.c:    env->vbr = 0;
hw/dummy_m68k.c:    env->pc = entry;
hw/ppc_newworld.c:                ((qemu_irq *)env->irq_inputs)[PPC6xx_INPUT_INT];
hw/ppc_newworld.c:                ((qemu_irq *)env->irq_inputs)[PPC6xx_INPUT_INT];
hw/ppc_newworld.c:                ((qemu_irq *)env->irq_inputs)[PPC6xx_INPUT_MCP];
hw/ppc_newworld.c:                ((qemu_irq *)env->irq_inputs)[PPC6xx_INPUT_HRESET];
hw/ppc_newworld.c:                ((qemu_irq *)env->irq_inputs)[PPC970_INPUT_INT];
hw/ppc_newworld.c:                ((qemu_irq *)env->irq_inputs)[PPC970_INPUT_INT];
hw/ppc_newworld.c:                ((qemu_irq *)env->irq_inputs)[PPC970_INPUT_MCP];
hw/ppc_newworld.c:                ((qemu_irq *)env->irq_inputs)[PPC970_INPUT_HRESET];
hw/xtensa_lx60.c:        env->sregs[PRID] = n;
hw/xtensa_lx60.c:            env->regs[2] = tagptr;
hw/xtensa_lx60.c:            env->pc = elf_entry;
hw/pxa2xx_gpio.c:    if (s->cpu_env->halted && (mask & ~s->dir[bank] & pxa2xx_gpio_wake[bank]))
hw/pxa2xx_gpio.c:    qdev_prop_set_int32(dev, "ncpu", env->cpu_index);
hw/grlib.h:    env->irq_manager = dev;
hw/arm_gic.c:        return cpu_single_env->cpu_index;
hw/ppc_prep.c:        if (env->flags & POWERPC_FLAG_RTC_CLK) {
hw/pc.c:        smm_set(!!(env->hflags & HF_SMM_MASK), smm_arg);
hw/pc.c:    intno = apic_get_interrupt(env->apic_state);
hw/pc.c:    if (!apic_accept_pic_intr(env->apic_state)) {
hw/pc.c:    if (env->apic_state) {
hw/pc.c:            if (apic_accept_pic_intr(env->apic_state)) {
hw/pc.c:                apic_deliver_pic_intr(env->apic_state, level);
hw/pc.c:            env = env->next_cpu;
hw/pc.c:    return env->cpu_index == 0;
hw/pc.c:        return cpu_single_env->apic_state;
hw/pc.c:    env->halted = !cpu_is_bsp(env);
hw/pc.c:    if ((env->cpuid_features & CPUID_APIC) || smp_cpus > 1) {
hw/pc.c:        env->apic_state = apic_init(env, env->cpuid_apic_id);
hw/armv7m.c:    env->nvic = nvic;
hw/vmport.c:    eax = env->regs[R_EAX];
hw/vmport.c:    command = env->regs[R_ECX];
hw/vmport.c:    env->regs[R_EAX] = vmport_ioport_read(opaque, addr);
hw/vmport.c:    env->regs[R_EBX] = VMPORT_MAGIC;
hw/vmport.c:    env->regs[R_EBX] = 0x1177;
hw/vmport.c:    data[0] = env->regs[R_EAX]; data[1] = env->regs[R_EBX];
hw/vmport.c:    data[2] = env->regs[R_ECX]; data[3] = env->regs[R_EDX];
hw/vmport.c:    data[4] = env->regs[R_ESI]; data[5] = env->regs[R_EDI];
hw/vmport.c:    env->regs[R_EAX] = data[0]; env->regs[R_EBX] = data[1];
hw/vmport.c:    env->regs[R_ECX] = data[2]; env->regs[R_EDX] = data[3];
hw/vmport.c:    env->regs[R_ESI] = data[4]; env->regs[R_EDI] = data[5];
hw/axis_dev88.c:    qdev_prop_set_ptr(dev, "interrupt_vector", &env->interrupt_vector);
hw/pxa2xx_pic.c:    if (s->cpu_env->halted) {
kvm-all.c:    ret = kvm_vm_ioctl(s, KVM_CREATE_VCPU, env->cpu_index);
kvm-all.c:    env->kvm_fd = ret;
kvm-all.c:    env->kvm_state = s;
kvm-all.c:    env->kvm_vcpu_dirty = 1;
kvm-all.c:    env->kvm_run = mmap(NULL, mmap_size, PROT_READ | PROT_WRITE, MAP_SHARED,
kvm-all.c:                        env->kvm_fd, 0);
kvm-all.c:    if (env->kvm_run == MAP_FAILED) {
kvm-all.c:            (void *)env->kvm_run + s->coalesced_mmio * PAGE_SIZE;
kvm-all.c:    env->interrupt_request |= mask;
kvm-all.c:    if (!env->kvm_vcpu_dirty) {
kvm-all.c:        env->kvm_vcpu_dirty = 1;
kvm-all.c:    if (!env->kvm_vcpu_dirty) {
kvm-all.c:    env->kvm_vcpu_dirty = 0;
kvm-all.c:    env->kvm_vcpu_dirty = 0;
kvm-all.c:    struct kvm_run *run = env->kvm_run;
kvm-all.c:        env->exit_request = 0;
kvm-all.c:        if (env->kvm_vcpu_dirty) {
kvm-all.c:            env->kvm_vcpu_dirty = 0;
kvm-all.c:        if (env->exit_request) {
kvm-all.c:    env->exit_request = 0;
kvm-all.c:    ret = ioctl(env->kvm_fd, type, arg);
kvm-all.c:    QTAILQ_FOREACH(bp, &env->kvm_state->kvm_sw_breakpoints, entry) {
kvm-all.c:    return !QTAILQ_EMPTY(&env->kvm_state->kvm_sw_breakpoints);
kvm-all.c:    if (env->singlestep_enabled) {
kvm-all.c:        QTAILQ_INSERT_HEAD(&current_env->kvm_state->kvm_sw_breakpoints,
kvm-all.c:    for (env = first_cpu; env != NULL; env = env->next_cpu) {
kvm-all.c:        QTAILQ_REMOVE(&current_env->kvm_state->kvm_sw_breakpoints, bp, entry);
kvm-all.c:    for (env = first_cpu; env != NULL; env = env->next_cpu) {
kvm-all.c:    KVMState *s = current_env->kvm_state;
kvm-all.c:            for (env = first_cpu; env != NULL; env = env->next_cpu) {
kvm-all.c:    for (env = first_cpu; env != NULL; env = env->next_cpu) {
linux-user/vm86.c:    TaskState *ts = env->opaque;
linux-user/vm86.c:    target_v86->regs.eax = tswap32(env->regs[R_EAX]);
linux-user/vm86.c:    target_v86->regs.ebx = tswap32(env->regs[R_EBX]);
linux-user/vm86.c:    target_v86->regs.ecx = tswap32(env->regs[R_ECX]);
linux-user/vm86.c:    target_v86->regs.edx = tswap32(env->regs[R_EDX]);
linux-user/vm86.c:    target_v86->regs.esi = tswap32(env->regs[R_ESI]);
linux-user/vm86.c:    target_v86->regs.edi = tswap32(env->regs[R_EDI]);
linux-user/vm86.c:    target_v86->regs.ebp = tswap32(env->regs[R_EBP]);
linux-user/vm86.c:    target_v86->regs.esp = tswap32(env->regs[R_ESP]);
linux-user/vm86.c:    target_v86->regs.eip = tswap32(env->eip);
linux-user/vm86.c:    target_v86->regs.cs = tswap16(env->segs[R_CS].selector);
linux-user/vm86.c:    target_v86->regs.ss = tswap16(env->segs[R_SS].selector);
linux-user/vm86.c:    target_v86->regs.ds = tswap16(env->segs[R_DS].selector);
linux-user/vm86.c:    target_v86->regs.es = tswap16(env->segs[R_ES].selector);
linux-user/vm86.c:    target_v86->regs.fs = tswap16(env->segs[R_FS].selector);
linux-user/vm86.c:    target_v86->regs.gs = tswap16(env->segs[R_GS].selector);
linux-user/vm86.c:    set_flags(env->eflags, ts->v86flags, VIF_MASK | ts->v86mask);
linux-user/vm86.c:    target_v86->regs.eflags = tswap32(env->eflags);
linux-user/vm86.c:             env->eflags, env->segs[R_CS].selector, env->eip);
linux-user/vm86.c:    env->regs[R_EAX] = ts->vm86_saved_regs.eax;
linux-user/vm86.c:    env->regs[R_EBX] = ts->vm86_saved_regs.ebx;
linux-user/vm86.c:    env->regs[R_ECX] = ts->vm86_saved_regs.ecx;
linux-user/vm86.c:    env->regs[R_EDX] = ts->vm86_saved_regs.edx;
linux-user/vm86.c:    env->regs[R_ESI] = ts->vm86_saved_regs.esi;
linux-user/vm86.c:    env->regs[R_EDI] = ts->vm86_saved_regs.edi;
linux-user/vm86.c:    env->regs[R_EBP] = ts->vm86_saved_regs.ebp;
linux-user/vm86.c:    env->regs[R_ESP] = ts->vm86_saved_regs.esp;
linux-user/vm86.c:    env->eflags = ts->vm86_saved_regs.eflags;
linux-user/vm86.c:    env->eip = ts->vm86_saved_regs.eip;
linux-user/vm86.c:    env->regs[R_EAX] = retval;
linux-user/vm86.c:    TaskState *ts = env->opaque;
linux-user/vm86.c:    TaskState *ts = env->opaque;
linux-user/vm86.c:    env->eflags &= ~TF_MASK;
linux-user/vm86.c:    env->eflags &= ~AC_MASK;
linux-user/vm86.c:    TaskState *ts = env->opaque;
linux-user/vm86.c:    set_flags(env->eflags, eflags, SAFE_MASK);
linux-user/vm86.c:    TaskState *ts = env->opaque;
linux-user/vm86.c:    set_flags(env->eflags, flags, SAFE_MASK);
linux-user/vm86.c:    TaskState *ts = env->opaque;
linux-user/vm86.c:    flags = env->eflags & RETURN_MASK;
linux-user/vm86.c:    TaskState *ts = env->opaque;
linux-user/vm86.c:    if (env->segs[R_CS].selector == TARGET_BIOSSEG)
linux-user/vm86.c:    if (intno == 0x21 && is_revectored((env->regs[R_EAX] >> 8) & 0xff,
linux-user/vm86.c:    ssp = env->segs[R_SS].selector << 4;
linux-user/vm86.c:    sp = env->regs[R_ESP] & 0xffff;
linux-user/vm86.c:    vm_putw(ssp, sp - 4, env->segs[R_CS].selector);
linux-user/vm86.c:    vm_putw(ssp, sp - 6, env->eip);
linux-user/vm86.c:    ADD16(env->regs[R_ESP], -6);
linux-user/vm86.c:    env->eip = segoffs & 0xffff;
linux-user/vm86.c:    TaskState *ts = env->opaque;
linux-user/vm86.c:    csp = env->segs[R_CS].selector << 4;
linux-user/vm86.c:    ip = env->eip & 0xffff;
linux-user/vm86.c:    ssp = env->segs[R_SS].selector << 4;
linux-user/vm86.c:    sp = env->regs[R_ESP] & 0xffff;
linux-user/vm86.c:             env->segs[R_CS].selector, env->eip);
linux-user/vm86.c:            ADD16(env->regs[R_ESP], -4);
linux-user/vm86.c:            ADD16(env->regs[R_ESP], -2);
linux-user/vm86.c:        env->eip = ip;
linux-user/vm86.c:            ADD16(env->regs[R_ESP], 4);
linux-user/vm86.c:            ADD16(env->regs[R_ESP], 2);
linux-user/vm86.c:        env->eip = ip;
linux-user/vm86.c:        env->eip = ip;
linux-user/vm86.c:            ADD16(env->regs[R_ESP], 12);
linux-user/vm86.c:            ADD16(env->regs[R_ESP], 6);
linux-user/vm86.c:        env->eip = newip;
linux-user/vm86.c:        env->eip = ip;
linux-user/vm86.c:        env->eip = ip;
linux-user/vm86.c:    TaskState *ts = env->opaque;
linux-user/vm86.c:    ts->vm86_saved_regs.ebx = env->regs[R_EBX];
linux-user/vm86.c:    ts->vm86_saved_regs.ecx = env->regs[R_ECX];
linux-user/vm86.c:    ts->vm86_saved_regs.edx = env->regs[R_EDX];
linux-user/vm86.c:    ts->vm86_saved_regs.esi = env->regs[R_ESI];
linux-user/vm86.c:    ts->vm86_saved_regs.edi = env->regs[R_EDI];
linux-user/vm86.c:    ts->vm86_saved_regs.ebp = env->regs[R_EBP];
linux-user/vm86.c:    ts->vm86_saved_regs.esp = env->regs[R_ESP];
linux-user/vm86.c:    ts->vm86_saved_regs.eflags = env->eflags;
linux-user/vm86.c:    ts->vm86_saved_regs.eip  = env->eip;
linux-user/vm86.c:    ts->vm86_saved_regs.cs = env->segs[R_CS].selector;
linux-user/vm86.c:    ts->vm86_saved_regs.ss = env->segs[R_SS].selector;
linux-user/vm86.c:    ts->vm86_saved_regs.ds = env->segs[R_DS].selector;
linux-user/vm86.c:    ts->vm86_saved_regs.es = env->segs[R_ES].selector;
linux-user/vm86.c:    ts->vm86_saved_regs.fs = env->segs[R_FS].selector;
linux-user/vm86.c:    ts->vm86_saved_regs.gs = env->segs[R_GS].selector;
linux-user/vm86.c:    env->eflags = (env->eflags & ~SAFE_MASK) |
linux-user/vm86.c:    env->regs[R_EBX] = tswap32(target_v86->regs.ebx);
linux-user/vm86.c:    env->regs[R_ECX] = tswap32(target_v86->regs.ecx);
linux-user/vm86.c:    env->regs[R_EDX] = tswap32(target_v86->regs.edx);
linux-user/vm86.c:    env->regs[R_ESI] = tswap32(target_v86->regs.esi);
linux-user/vm86.c:    env->regs[R_EDI] = tswap32(target_v86->regs.edi);
linux-user/vm86.c:    env->regs[R_EBP] = tswap32(target_v86->regs.ebp);
linux-user/vm86.c:    env->regs[R_ESP] = tswap32(target_v86->regs.esp);
linux-user/vm86.c:    env->eip = tswap32(target_v86->regs.eip);
linux-user/vm86.c:             env->segs[R_CS].selector, env->eip);
linux-user/elfload.c:    int family = (thread_env->cpuid_version >> 8) & 0xff;
linux-user/elfload.c:    return thread_env->cpuid_features;
linux-user/elfload.c:    (*regs)[0] = env->regs[15];
linux-user/elfload.c:    (*regs)[1] = env->regs[14];
linux-user/elfload.c:    (*regs)[2] = env->regs[13];
linux-user/elfload.c:    (*regs)[3] = env->regs[12];
linux-user/elfload.c:    (*regs)[4] = env->regs[R_EBP];
linux-user/elfload.c:    (*regs)[5] = env->regs[R_EBX];
linux-user/elfload.c:    (*regs)[6] = env->regs[11];
linux-user/elfload.c:    (*regs)[7] = env->regs[10];
linux-user/elfload.c:    (*regs)[8] = env->regs[9];
linux-user/elfload.c:    (*regs)[9] = env->regs[8];
linux-user/elfload.c:    (*regs)[10] = env->regs[R_EAX];
linux-user/elfload.c:    (*regs)[11] = env->regs[R_ECX];
linux-user/elfload.c:    (*regs)[12] = env->regs[R_EDX];
linux-user/elfload.c:    (*regs)[13] = env->regs[R_ESI];
linux-user/elfload.c:    (*regs)[14] = env->regs[R_EDI];
linux-user/elfload.c:    (*regs)[15] = env->regs[R_EAX]; /* XXX */
linux-user/elfload.c:    (*regs)[16] = env->eip;
linux-user/elfload.c:    (*regs)[17] = env->segs[R_CS].selector & 0xffff;
linux-user/elfload.c:    (*regs)[18] = env->eflags;
linux-user/elfload.c:    (*regs)[19] = env->regs[R_ESP];
linux-user/elfload.c:    (*regs)[20] = env->segs[R_SS].selector & 0xffff;
linux-user/elfload.c:    (*regs)[21] = env->segs[R_FS].selector & 0xffff;
linux-user/elfload.c:    (*regs)[22] = env->segs[R_GS].selector & 0xffff;
linux-user/elfload.c:    (*regs)[23] = env->segs[R_DS].selector & 0xffff;
linux-user/elfload.c:    (*regs)[24] = env->segs[R_ES].selector & 0xffff;
linux-user/elfload.c:    (*regs)[25] = env->segs[R_FS].selector & 0xffff;
linux-user/elfload.c:    (*regs)[26] = env->segs[R_GS].selector & 0xffff;
linux-user/elfload.c:    (*regs)[0] = env->regs[R_EBX];
linux-user/elfload.c:    (*regs)[1] = env->regs[R_ECX];
linux-user/elfload.c:    (*regs)[2] = env->regs[R_EDX];
linux-user/elfload.c:    (*regs)[3] = env->regs[R_ESI];
linux-user/elfload.c:    (*regs)[4] = env->regs[R_EDI];
linux-user/elfload.c:    (*regs)[5] = env->regs[R_EBP];
linux-user/elfload.c:    (*regs)[6] = env->regs[R_EAX];
linux-user/elfload.c:    (*regs)[7] = env->segs[R_DS].selector & 0xffff;
linux-user/elfload.c:    (*regs)[8] = env->segs[R_ES].selector & 0xffff;
linux-user/elfload.c:    (*regs)[9] = env->segs[R_FS].selector & 0xffff;
linux-user/elfload.c:    (*regs)[10] = env->segs[R_GS].selector & 0xffff;
linux-user/elfload.c:    (*regs)[11] = env->regs[R_EAX]; /* XXX */
linux-user/elfload.c:    (*regs)[12] = env->eip;
linux-user/elfload.c:    (*regs)[13] = env->segs[R_CS].selector & 0xffff;
linux-user/elfload.c:    (*regs)[14] = env->eflags;
linux-user/elfload.c:    (*regs)[15] = env->regs[R_ESP];
linux-user/elfload.c:    (*regs)[16] = env->segs[R_SS].selector & 0xffff;
linux-user/elfload.c:    (*regs)[0] = tswapl(env->regs[0]);
linux-user/elfload.c:    (*regs)[1] = tswapl(env->regs[1]);
linux-user/elfload.c:    (*regs)[2] = tswapl(env->regs[2]);
linux-user/elfload.c:    (*regs)[3] = tswapl(env->regs[3]);
linux-user/elfload.c:    (*regs)[4] = tswapl(env->regs[4]);
linux-user/elfload.c:    (*regs)[5] = tswapl(env->regs[5]);
linux-user/elfload.c:    (*regs)[6] = tswapl(env->regs[6]);
linux-user/elfload.c:    (*regs)[7] = tswapl(env->regs[7]);
linux-user/elfload.c:    (*regs)[8] = tswapl(env->regs[8]);
linux-user/elfload.c:    (*regs)[9] = tswapl(env->regs[9]);
linux-user/elfload.c:    (*regs)[10] = tswapl(env->regs[10]);
linux-user/elfload.c:    (*regs)[11] = tswapl(env->regs[11]);
linux-user/elfload.c:    (*regs)[12] = tswapl(env->regs[12]);
linux-user/elfload.c:    (*regs)[13] = tswapl(env->regs[13]);
linux-user/elfload.c:    (*regs)[14] = tswapl(env->regs[14]);
linux-user/elfload.c:    (*regs)[15] = tswapl(env->regs[15]);
linux-user/elfload.c:    (*regs)[17] = tswapl(env->regs[0]); /* XXX */
linux-user/elfload.c:    (*regs)[0] = env->regs[0];
linux-user/elfload.c:    (*regs)[1] = env->regs[1];
linux-user/elfload.c:    (*regs)[2] = env->regs[2];
linux-user/elfload.c:    (*regs)[3] = env->regs[3];
linux-user/elfload.c:    (*regs)[4] = env->regs[4];
linux-user/elfload.c:    (*regs)[5] = env->regs[5];
linux-user/elfload.c:    (*regs)[6] = env->regs[6];
linux-user/elfload.c:    (*regs)[7] = env->regs[7];
linux-user/elfload.c:    (*regs)[8] = env->regs[8];
linux-user/elfload.c:    (*regs)[9] = env->regs[9];
linux-user/elfload.c:    (*regs)[10] = env->regs[10];
linux-user/elfload.c:    (*regs)[11] = env->regs[11];
linux-user/elfload.c:    (*regs)[12] = env->regs[12];
linux-user/elfload.c:    (*regs)[13] = env->regs[13];
linux-user/elfload.c:    (*regs)[14] = env->regs[14];
linux-user/elfload.c:    (*regs)[15] = env->regs[15];
linux-user/elfload.c:    (*regs)[16] = env->regs[16];
linux-user/elfload.c:    (*regs)[17] = env->regs[17];
linux-user/elfload.c:    (*regs)[18] = env->regs[18];
linux-user/elfload.c:    (*regs)[19] = env->regs[19];
linux-user/elfload.c:    (*regs)[20] = env->regs[20];
linux-user/elfload.c:    (*regs)[21] = env->regs[21];
linux-user/elfload.c:    (*regs)[22] = env->regs[22];
linux-user/elfload.c:    (*regs)[23] = env->regs[23];
linux-user/elfload.c:    (*regs)[24] = env->regs[24];
linux-user/elfload.c:    (*regs)[25] = env->regs[25];
linux-user/elfload.c:    (*regs)[26] = env->regs[26];
linux-user/elfload.c:    (*regs)[27] = env->regs[27];
linux-user/elfload.c:    (*regs)[28] = env->regs[28];
linux-user/elfload.c:    (*regs)[29] = env->regs[29];
linux-user/elfload.c:    (*regs)[30] = env->regs[30];
linux-user/elfload.c:    (*regs)[31] = env->regs[31];
linux-user/elfload.c:    (*regs)[33] = env->regs[0]; /* XXX */
linux-user/elfload.c:    for (i = 0; i < ARRAY_SIZE(env->gpr); i++) {
linux-user/elfload.c:        (*regs)[i] = tswapl(env->gpr[i]);
linux-user/elfload.c:    (*regs)[32] = tswapl(env->nip);
linux-user/elfload.c:    (*regs)[33] = tswapl(env->msr);
linux-user/elfload.c:    (*regs)[35] = tswapl(env->ctr);
linux-user/elfload.c:    (*regs)[36] = tswapl(env->lr);
linux-user/elfload.c:    (*regs)[37] = tswapl(env->xer);
linux-user/elfload.c:    for (i = 0; i < ARRAY_SIZE(env->crf); i++) {
linux-user/elfload.c:        ccr |= env->crf[i] << (32 - ((i + 1) * 4));
linux-user/elfload.c:    for (i = 1; i < ARRAY_SIZE(env->active_tc.gpr); i++) {
linux-user/elfload.c:        (*regs)[TARGET_EF_R0 + i] = tswapl(env->active_tc.gpr[i]);
linux-user/elfload.c:    (*regs)[TARGET_EF_LO] = tswapl(env->active_tc.LO[0]);
linux-user/elfload.c:    (*regs)[TARGET_EF_HI] = tswapl(env->active_tc.HI[0]);
linux-user/elfload.c:    (*regs)[TARGET_EF_CP0_EPC] = tswapl(env->active_tc.PC);
linux-user/elfload.c:    (*regs)[TARGET_EF_CP0_BADVADDR] = tswapl(env->CP0_BadVAddr);
linux-user/elfload.c:    (*regs)[TARGET_EF_CP0_STATUS] = tswapl(env->CP0_Status);
linux-user/elfload.c:    (*regs)[TARGET_EF_CP0_CAUSE] = tswapl(env->CP0_Cause);
linux-user/elfload.c:        (*regs)[pos++] = tswapl(env->regs[i]);
linux-user/elfload.c:        (*regs)[pos++] = tswapl(env->sregs[i]);
linux-user/elfload.c:        (*regs[i]) = tswapl(env->gregs[i]);
linux-user/elfload.c:    (*regs)[TARGET_REG_PC] = tswapl(env->pc);
linux-user/elfload.c:    (*regs)[TARGET_REG_PR] = tswapl(env->pr);
linux-user/elfload.c:    (*regs)[TARGET_REG_SR] = tswapl(env->sr);
linux-user/elfload.c:    (*regs)[TARGET_REG_GBR] = tswapl(env->gbr);
linux-user/elfload.c:    (*regs)[TARGET_REG_MACH] = tswapl(env->mach);
linux-user/elfload.c:    (*regs)[TARGET_REG_MACL] = tswapl(env->macl);
linux-user/elfload.c:    (*regs)[0] = tswapl(env->dregs[1]);
linux-user/elfload.c:    (*regs)[1] = tswapl(env->dregs[2]);
linux-user/elfload.c:    (*regs)[2] = tswapl(env->dregs[3]);
linux-user/elfload.c:    (*regs)[3] = tswapl(env->dregs[4]);
linux-user/elfload.c:    (*regs)[4] = tswapl(env->dregs[5]);
linux-user/elfload.c:    (*regs)[5] = tswapl(env->dregs[6]);
linux-user/elfload.c:    (*regs)[6] = tswapl(env->dregs[7]);
linux-user/elfload.c:    (*regs)[7] = tswapl(env->aregs[0]);
linux-user/elfload.c:    (*regs)[8] = tswapl(env->aregs[1]);
linux-user/elfload.c:    (*regs)[9] = tswapl(env->aregs[2]);
linux-user/elfload.c:    (*regs)[10] = tswapl(env->aregs[3]);
linux-user/elfload.c:    (*regs)[11] = tswapl(env->aregs[4]);
linux-user/elfload.c:    (*regs)[12] = tswapl(env->aregs[5]);
linux-user/elfload.c:    (*regs)[13] = tswapl(env->aregs[6]);
linux-user/elfload.c:    (*regs)[14] = tswapl(env->dregs[0]);
linux-user/elfload.c:    (*regs)[15] = tswapl(env->aregs[7]);
linux-user/elfload.c:    (*regs)[16] = tswapl(env->dregs[0]); /* FIXME: orig_d0 */
linux-user/elfload.c:    (*regs)[17] = tswapl(env->sr);
linux-user/elfload.c:    (*regs)[18] = tswapl(env->pc);
linux-user/elfload.c:    TaskState *ts = (TaskState *)env->opaque;
linux-user/elfload.c:    TaskState *ts = (TaskState *)env->opaque;
linux-user/elfload.c:    const TaskState *ts = (const TaskState *)env->opaque;
linux-user/signal.c:    TaskState *ts = env->opaque;
linux-user/signal.c:    TaskState *ts = env->opaque;
linux-user/signal.c:    TaskState *ts = (TaskState *)thread_env->opaque;
linux-user/signal.c:    TaskState *ts = env->opaque;
linux-user/signal.c:	err |= __put_user(env->segs[R_GS].selector, (unsigned int *)&sc->gs);
linux-user/signal.c:	err |= __put_user(env->segs[R_FS].selector, (unsigned int *)&sc->fs);
linux-user/signal.c:	err |= __put_user(env->segs[R_ES].selector, (unsigned int *)&sc->es);
linux-user/signal.c:	err |= __put_user(env->segs[R_DS].selector, (unsigned int *)&sc->ds);
linux-user/signal.c:	err |= __put_user(env->regs[R_EDI], &sc->edi);
linux-user/signal.c:	err |= __put_user(env->regs[R_ESI], &sc->esi);
linux-user/signal.c:	err |= __put_user(env->regs[R_EBP], &sc->ebp);
linux-user/signal.c:	err |= __put_user(env->regs[R_ESP], &sc->esp);
linux-user/signal.c:	err |= __put_user(env->regs[R_EBX], &sc->ebx);
linux-user/signal.c:	err |= __put_user(env->regs[R_EDX], &sc->edx);
linux-user/signal.c:	err |= __put_user(env->regs[R_ECX], &sc->ecx);
linux-user/signal.c:	err |= __put_user(env->regs[R_EAX], &sc->eax);
linux-user/signal.c:	err |= __put_user(env->exception_index, &sc->trapno);
linux-user/signal.c:	err |= __put_user(env->error_code, &sc->err);
linux-user/signal.c:	err |= __put_user(env->eip, &sc->eip);
linux-user/signal.c:	err |= __put_user(env->segs[R_CS].selector, (unsigned int *)&sc->cs);
linux-user/signal.c:	err |= __put_user(env->eflags, &sc->eflags);
linux-user/signal.c:	err |= __put_user(env->regs[R_ESP], &sc->esp_at_signal);
linux-user/signal.c:	err |= __put_user(env->segs[R_SS].selector, (unsigned int *)&sc->ss);
linux-user/signal.c:	err |= __put_user(env->cr[2], &sc->cr2);
linux-user/signal.c:	esp = env->regs[R_ESP];
linux-user/signal.c:        if ((env->segs[R_SS].selector & 0xffff) != __USER_DS &&
linux-user/signal.c:	env->regs[R_ESP] = frame_addr;
linux-user/signal.c:	env->eip = ka->_sa_handler;
linux-user/signal.c:	env->eflags &= ~TF_MASK;
linux-user/signal.c:	env->regs[R_ESP] = frame_addr;
linux-user/signal.c:	env->eip = ka->_sa_handler;
linux-user/signal.c:	env->eflags &= ~TF_MASK;
linux-user/signal.c:        env->regs[R_EDI] = tswapl(sc->edi);
linux-user/signal.c:        env->regs[R_ESI] = tswapl(sc->esi);
linux-user/signal.c:        env->regs[R_EBP] = tswapl(sc->ebp);
linux-user/signal.c:        env->regs[R_ESP] = tswapl(sc->esp);
linux-user/signal.c:        env->regs[R_EBX] = tswapl(sc->ebx);
linux-user/signal.c:        env->regs[R_EDX] = tswapl(sc->edx);
linux-user/signal.c:        env->regs[R_ECX] = tswapl(sc->ecx);
linux-user/signal.c:        env->eip = tswapl(sc->eip);
linux-user/signal.c:        env->eflags = (env->eflags & ~0x40DD5) | (tmpflags & 0x40DD5);
linux-user/signal.c:    abi_ulong frame_addr = env->regs[R_ESP] - 8;
linux-user/signal.c:        frame_addr = env->regs[R_ESP] - 4;
linux-user/signal.c:	__put_user(env->regs[0], &sc->arm_r0);
linux-user/signal.c:	__put_user(env->regs[1], &sc->arm_r1);
linux-user/signal.c:	__put_user(env->regs[2], &sc->arm_r2);
linux-user/signal.c:	__put_user(env->regs[3], &sc->arm_r3);
linux-user/signal.c:	__put_user(env->regs[4], &sc->arm_r4);
linux-user/signal.c:	__put_user(env->regs[5], &sc->arm_r5);
linux-user/signal.c:	__put_user(env->regs[6], &sc->arm_r6);
linux-user/signal.c:	__put_user(env->regs[7], &sc->arm_r7);
linux-user/signal.c:	__put_user(env->regs[8], &sc->arm_r8);
linux-user/signal.c:	__put_user(env->regs[9], &sc->arm_r9);
linux-user/signal.c:	__put_user(env->regs[10], &sc->arm_r10);
linux-user/signal.c:	__put_user(env->regs[11], &sc->arm_fp);
linux-user/signal.c:	__put_user(env->regs[12], &sc->arm_ip);
linux-user/signal.c:	__put_user(env->regs[13], &sc->arm_sp);
linux-user/signal.c:	__put_user(env->regs[14], &sc->arm_lr);
linux-user/signal.c:	__put_user(env->regs[15], &sc->arm_pc);
linux-user/signal.c:	env->regs[0] = usig;
linux-user/signal.c:	env->regs[13] = frame_addr;
linux-user/signal.c:	env->regs[14] = retcode;
linux-user/signal.c:	env->regs[15] = handler & (thumb ? ~1 : ~3);
linux-user/signal.c:        __put_user(float64_val(env->vfp.regs[i]), &vfpframe->ufp.fpregs[i]);
linux-user/signal.c:    __put_user(env->vfp.xregs[ARM_VFP_FPEXC], &vfpframe->ufp_exc.fpexc);
linux-user/signal.c:    __put_user(env->vfp.xregs[ARM_VFP_FPINST], &vfpframe->ufp_exc.fpinst);
linux-user/signal.c:    __put_user(env->vfp.xregs[ARM_VFP_FPINST2], &vfpframe->ufp_exc.fpinst2);
linux-user/signal.c:        __put_user(env->iwmmxt.regs[i], &iwmmxtframe->regs[i]);
linux-user/signal.c:    __put_user(env->vfp.xregs[ARM_IWMMXT_wCSSF], &iwmmxtframe->wcssf);
linux-user/signal.c:    __put_user(env->vfp.xregs[ARM_IWMMXT_wCASF], &iwmmxtframe->wcssf);
linux-user/signal.c:    __put_user(env->vfp.xregs[ARM_IWMMXT_wCGR0], &iwmmxtframe->wcgr0);
linux-user/signal.c:    __put_user(env->vfp.xregs[ARM_IWMMXT_wCGR1], &iwmmxtframe->wcgr1);
linux-user/signal.c:    __put_user(env->vfp.xregs[ARM_IWMMXT_wCGR2], &iwmmxtframe->wcgr2);
linux-user/signal.c:    __put_user(env->vfp.xregs[ARM_IWMMXT_wCGR3], &iwmmxtframe->wcgr3);
linux-user/signal.c:        env->regs[1] = info_addr;
linux-user/signal.c:        env->regs[2] = uc_addr;
linux-user/signal.c:        env->regs[1] = info_addr;
linux-user/signal.c:        env->regs[2] = uc_addr;
linux-user/signal.c:	__get_user_error(env->regs[0], &sc->arm_r0, err);
linux-user/signal.c:	__get_user_error(env->regs[1], &sc->arm_r1, err);
linux-user/signal.c:	__get_user_error(env->regs[2], &sc->arm_r2, err);
linux-user/signal.c:	__get_user_error(env->regs[3], &sc->arm_r3, err);
linux-user/signal.c:	__get_user_error(env->regs[4], &sc->arm_r4, err);
linux-user/signal.c:	__get_user_error(env->regs[5], &sc->arm_r5, err);
linux-user/signal.c:	__get_user_error(env->regs[6], &sc->arm_r6, err);
linux-user/signal.c:	__get_user_error(env->regs[7], &sc->arm_r7, err);
linux-user/signal.c:	__get_user_error(env->regs[8], &sc->arm_r8, err);
linux-user/signal.c:	__get_user_error(env->regs[9], &sc->arm_r9, err);
linux-user/signal.c:	__get_user_error(env->regs[10], &sc->arm_r10, err);
linux-user/signal.c:	__get_user_error(env->regs[11], &sc->arm_fp, err);
linux-user/signal.c:	__get_user_error(env->regs[12], &sc->arm_ip, err);
linux-user/signal.c:	__get_user_error(env->regs[13], &sc->arm_sp, err);
linux-user/signal.c:	__get_user_error(env->regs[14], &sc->arm_lr, err);
linux-user/signal.c:	__get_user_error(env->regs[15], &sc->arm_pc, err);
linux-user/signal.c:	if (env->regs[13] & 7)
linux-user/signal.c:        frame_addr = env->regs[13];
linux-user/signal.c:        return env->regs[0];
linux-user/signal.c:        __get_user(float64_val(env->vfp.regs[i]), &vfpframe->ufp.fpregs[i]);
linux-user/signal.c:    env->vfp.xregs[ARM_VFP_FPEXC] = fpexc;
linux-user/signal.c:    __get_user(env->vfp.xregs[ARM_VFP_FPINST], &vfpframe->ufp_exc.fpinst);
linux-user/signal.c:    __get_user(env->vfp.xregs[ARM_VFP_FPINST2], &vfpframe->ufp_exc.fpinst2);
linux-user/signal.c:        __get_user(env->iwmmxt.regs[i], &iwmmxtframe->regs[i]);
linux-user/signal.c:    __get_user(env->vfp.xregs[ARM_IWMMXT_wCSSF], &iwmmxtframe->wcssf);
linux-user/signal.c:    __get_user(env->vfp.xregs[ARM_IWMMXT_wCASF], &iwmmxtframe->wcssf);
linux-user/signal.c:    __get_user(env->vfp.xregs[ARM_IWMMXT_wCGR0], &iwmmxtframe->wcgr0);
linux-user/signal.c:    __get_user(env->vfp.xregs[ARM_IWMMXT_wCGR1], &iwmmxtframe->wcgr1);
linux-user/signal.c:    __get_user(env->vfp.xregs[ARM_IWMMXT_wCGR2], &iwmmxtframe->wcgr2);
linux-user/signal.c:    __get_user(env->vfp.xregs[ARM_IWMMXT_wCGR3], &iwmmxtframe->wcgr3);
linux-user/signal.c:	if (env->regs[13] & 7)
linux-user/signal.c:        frame_addr = env->regs[13];
linux-user/signal.c:	return env->regs[0];
linux-user/signal.c:	if (env->regs[13] & 7)
linux-user/signal.c:        frame_addr = env->regs[13];
linux-user/signal.c:	return env->regs[0];
linux-user/signal.c:	if (env->regs[13] & 7)
linux-user/signal.c:        frame_addr = env->regs[13];
linux-user/signal.c:	return env->regs[0];
linux-user/signal.c:	sp = env->regwptr[UREG_FP];
linux-user/signal.c:	err |= __put_user(env->psr, &si->si_regs.psr);
linux-user/signal.c:	err |= __put_user(env->pc, &si->si_regs.pc);
linux-user/signal.c:	err |= __put_user(env->npc, &si->si_regs.npc);
linux-user/signal.c:	err |= __put_user(env->y, &si->si_regs.y);
linux-user/signal.c:		err |= __put_user(env->gregs[i], &si->si_regs.u_regs[i]);
linux-user/signal.c:		err |= __put_user(env->regwptr[UREG_I0 + i], &si->si_regs.u_regs[i+8]);
linux-user/signal.c:	err |= __put_user(env->regwptr[UREG_SP], &sc->sigc_sp);
linux-user/signal.c:	err |= __put_user(env->pc, &sc->sigc_pc);
linux-user/signal.c:	err |= __put_user(env->npc, &sc->sigc_npc);
linux-user/signal.c:	err |= __put_user(env->psr, &sc->sigc_psr);
linux-user/signal.c:	err |= __put_user(env->gregs[1], &sc->sigc_g1);
linux-user/signal.c:	err |= __put_user(env->regwptr[UREG_O0], &sc->sigc_o0);
linux-user/signal.c:	//fprintf(stderr, "sf: %x pc %x fp %x sp %x\n", sf, env->pc, env->regwptr[UREG_FP], env->regwptr[UREG_SP]);
linux-user/signal.c:	  	err |= __put_user(env->regwptr[i + UREG_L0], &sf->ss.locals[i]);
linux-user/signal.c:	  	err |= __put_user(env->regwptr[i + UREG_I0], &sf->ss.ins[i]);
linux-user/signal.c:	env->regwptr[UREG_FP] = sf_addr;
linux-user/signal.c:	env->regwptr[UREG_I0] = sig;
linux-user/signal.c:	env->regwptr[UREG_I1] = sf_addr + 
linux-user/signal.c:	env->regwptr[UREG_I2] = sf_addr + 
linux-user/signal.c:	env->pc = ka->_sa_handler;
linux-user/signal.c:	env->npc = (env->pc + 4);
linux-user/signal.c:		env->regwptr[UREG_I7] = ka->sa_restorer;
linux-user/signal.c:		env->regwptr[UREG_I7] = sf_addr + 
linux-user/signal.c:        err = __copy_from_user(&env->fpr[0], &fpu->si_float_regs[0],
linux-user/signal.c:        err |= __get_user(env->fsr, &fpu->si_fsr);
linux-user/signal.c:        sf_addr = env->regwptr[UREG_FP];
linux-user/signal.c:	fprintf(stderr, "sf: %x pc %x fp %x sp %x\n", sf, env->pc, env->regwptr[UREG_FP], env->regwptr[UREG_SP]);
linux-user/signal.c:        env->psr = (up_psr & (PSR_ICC /* | PSR_EF */))
linux-user/signal.c:                  | (env->psr & ~(PSR_ICC /* | PSR_EF */));
linux-user/signal.c:	env->pc = pc;
linux-user/signal.c:	env->npc = npc;
linux-user/signal.c:        err |= __get_user(env->y, &sf->info.si_regs.y);
linux-user/signal.c:		err |= __get_user(env->gregs[i], &sf->info.si_regs.u_regs[i]);
linux-user/signal.c:		err |= __get_user(env->regwptr[i + UREG_I0], &sf->info.si_regs.u_regs[i+8]);
linux-user/signal.c:        return env->regwptr[0];
linux-user/signal.c:    ucp_addr = env->regwptr[UREG_I0];
linux-user/signal.c:    if (env->regwptr[UREG_I1]) {
linux-user/signal.c:    env->pc = pc;
linux-user/signal.c:    env->npc = npc;
linux-user/signal.c:    err |= __get_user(env->y, &((*grp)[MC_Y]));
linux-user/signal.c:    env->asi = (tstate >> 24) & 0xff;
linux-user/signal.c:    err |= __get_user(env->gregs[1], (&(*grp)[MC_G1]));
linux-user/signal.c:    err |= __get_user(env->gregs[2], (&(*grp)[MC_G2]));
linux-user/signal.c:    err |= __get_user(env->gregs[3], (&(*grp)[MC_G3]));
linux-user/signal.c:    err |= __get_user(env->gregs[4], (&(*grp)[MC_G4]));
linux-user/signal.c:    err |= __get_user(env->gregs[5], (&(*grp)[MC_G5]));
linux-user/signal.c:    err |= __get_user(env->gregs[6], (&(*grp)[MC_G6]));
linux-user/signal.c:    err |= __get_user(env->gregs[7], (&(*grp)[MC_G7]));
linux-user/signal.c:    err |= __get_user(env->regwptr[UREG_I0], (&(*grp)[MC_O0]));
linux-user/signal.c:    err |= __get_user(env->regwptr[UREG_I1], (&(*grp)[MC_O1]));
linux-user/signal.c:    err |= __get_user(env->regwptr[UREG_I2], (&(*grp)[MC_O2]));
linux-user/signal.c:    err |= __get_user(env->regwptr[UREG_I3], (&(*grp)[MC_O3]));
linux-user/signal.c:    err |= __get_user(env->regwptr[UREG_I4], (&(*grp)[MC_O4]));
linux-user/signal.c:    err |= __get_user(env->regwptr[UREG_I5], (&(*grp)[MC_O5]));
linux-user/signal.c:    err |= __get_user(env->regwptr[UREG_I6], (&(*grp)[MC_O6]));
linux-user/signal.c:    err |= __get_user(env->regwptr[UREG_I7], (&(*grp)[MC_O7]));
linux-user/signal.c:    w_addr = TARGET_STACK_BIAS+env->regwptr[UREG_I6];
linux-user/signal.c:    err |= __get_user(env->fprs, &(ucp->tuc_mcontext.mc_fpregs.mcfpu_fprs));
linux-user/signal.c:                err |= __get_user(env->fpr[i/2].l.lower, src);
linux-user/signal.c:                err |= __get_user(env->fpr[i/2].l.upper, src);
linux-user/signal.c:    err |= __get_user(env->fsr,
linux-user/signal.c:    err |= __get_user(env->gsr,
linux-user/signal.c:    ucp_addr = env->regwptr[UREG_I0];
linux-user/signal.c:    env->pc = env->npc;
linux-user/signal.c:    env->npc += 4;
linux-user/signal.c:    //    err |= __put_user(env->tstate, &((*grp)[MC_TSTATE]));
linux-user/signal.c:    err |= __put_user(env->pc, &((*grp)[MC_PC]));
linux-user/signal.c:    err |= __put_user(env->npc, &((*grp)[MC_NPC]));
linux-user/signal.c:    err |= __put_user(env->y, &((*grp)[MC_Y]));
linux-user/signal.c:    err |= __put_user(env->gregs[1], &((*grp)[MC_G1]));
linux-user/signal.c:    err |= __put_user(env->gregs[2], &((*grp)[MC_G2]));
linux-user/signal.c:    err |= __put_user(env->gregs[3], &((*grp)[MC_G3]));
linux-user/signal.c:    err |= __put_user(env->gregs[4], &((*grp)[MC_G4]));
linux-user/signal.c:    err |= __put_user(env->gregs[5], &((*grp)[MC_G5]));
linux-user/signal.c:    err |= __put_user(env->gregs[6], &((*grp)[MC_G6]));
linux-user/signal.c:    err |= __put_user(env->gregs[7], &((*grp)[MC_G7]));
linux-user/signal.c:    err |= __put_user(env->regwptr[UREG_I0], &((*grp)[MC_O0]));
linux-user/signal.c:    err |= __put_user(env->regwptr[UREG_I1], &((*grp)[MC_O1]));
linux-user/signal.c:    err |= __put_user(env->regwptr[UREG_I2], &((*grp)[MC_O2]));
linux-user/signal.c:    err |= __put_user(env->regwptr[UREG_I3], &((*grp)[MC_O3]));
linux-user/signal.c:    err |= __put_user(env->regwptr[UREG_I4], &((*grp)[MC_O4]));
linux-user/signal.c:    err |= __put_user(env->regwptr[UREG_I5], &((*grp)[MC_O5]));
linux-user/signal.c:    err |= __put_user(env->regwptr[UREG_I6], &((*grp)[MC_O6]));
linux-user/signal.c:    err |= __put_user(env->regwptr[UREG_I7], &((*grp)[MC_O7]));
linux-user/signal.c:    w_addr = TARGET_STACK_BIAS+env->regwptr[UREG_I6];
linux-user/signal.c:                err |= __put_user(env->fpr[i/2].l.lower, dst);
linux-user/signal.c:                err |= __put_user(env->fpr[i/2].l.upper, dst);
linux-user/signal.c:    err |= __put_user(env->fsr, &(mcp->mc_fpregs.mcfpu_fsr));
linux-user/signal.c:    err |= __put_user(env->gsr, &(mcp->mc_fpregs.mcfpu_gsr));
linux-user/signal.c:    err |= __put_user(env->fprs, &(mcp->mc_fpregs.mcfpu_fprs));
linux-user/signal.c:    env->active_tc.gpr[ 4] = sig;
linux-user/signal.c:    env->active_tc.gpr[ 5] = frame_addr
linux-user/signal.c:    env->active_tc.gpr[ 6] = frame_addr
linux-user/signal.c:    env->active_tc.gpr[29] = frame_addr;
linux-user/signal.c:    env->active_tc.gpr[31] = frame_addr
linux-user/signal.c:    env->active_tc.PC = env->active_tc.gpr[25] = ka->_sa_handler;
linux-user/signal.c:    frame_addr = env->active_tc.gpr[29];
linux-user/signal.c:    env->active_tc.PC = env->CP0_EPC;
linux-user/signal.c:    env->CP0_EPC = 0;
linux-user/signal.c:    __put_user(env->regs[0], &sc->regs.r0);
linux-user/signal.c:    __put_user(env->regs[1], &sc->regs.r1);
linux-user/signal.c:    __put_user(env->regs[2], &sc->regs.r2);
linux-user/signal.c:    __put_user(env->regs[3], &sc->regs.r3);
linux-user/signal.c:    __put_user(env->regs[4], &sc->regs.r4);
linux-user/signal.c:    __put_user(env->regs[5], &sc->regs.r5);
linux-user/signal.c:    __put_user(env->regs[6], &sc->regs.r6);
linux-user/signal.c:    __put_user(env->regs[7], &sc->regs.r7);
linux-user/signal.c:    __put_user(env->regs[8], &sc->regs.r8);
linux-user/signal.c:    __put_user(env->regs[9], &sc->regs.r9);
linux-user/signal.c:    __put_user(env->regs[10], &sc->regs.r10);
linux-user/signal.c:    __put_user(env->regs[11], &sc->regs.r11);
linux-user/signal.c:    __put_user(env->regs[12], &sc->regs.r12);
linux-user/signal.c:    __put_user(env->regs[13], &sc->regs.r13);
linux-user/signal.c:    __put_user(env->regs[14], &sc->regs.r14);
linux-user/signal.c:    __put_user(env->regs[15], &sc->regs.r15);
linux-user/signal.c:    __put_user(env->regs[16], &sc->regs.r16);
linux-user/signal.c:    __put_user(env->regs[17], &sc->regs.r17);
linux-user/signal.c:    __put_user(env->regs[18], &sc->regs.r18);
linux-user/signal.c:    __put_user(env->regs[19], &sc->regs.r19);
linux-user/signal.c:    __put_user(env->regs[20], &sc->regs.r20);
linux-user/signal.c:    __put_user(env->regs[21], &sc->regs.r21);
linux-user/signal.c:    __put_user(env->regs[22], &sc->regs.r22);
linux-user/signal.c:    __put_user(env->regs[23], &sc->regs.r23);
linux-user/signal.c:    __put_user(env->regs[24], &sc->regs.r24);
linux-user/signal.c:    __put_user(env->regs[25], &sc->regs.r25);
linux-user/signal.c:    __put_user(env->regs[26], &sc->regs.r26);
linux-user/signal.c:    __put_user(env->regs[27], &sc->regs.r27);
linux-user/signal.c:    __put_user(env->regs[28], &sc->regs.r28);
linux-user/signal.c:    __put_user(env->regs[29], &sc->regs.r29);
linux-user/signal.c:    __put_user(env->regs[30], &sc->regs.r30);
linux-user/signal.c:    __put_user(env->regs[31], &sc->regs.r31);
linux-user/signal.c:    __put_user(env->sregs[SR_PC], &sc->regs.pc);
linux-user/signal.c:    __get_user(env->regs[0], &sc->regs.r0);
linux-user/signal.c:    __get_user(env->regs[1], &sc->regs.r1);
linux-user/signal.c:    __get_user(env->regs[2], &sc->regs.r2);
linux-user/signal.c:    __get_user(env->regs[3], &sc->regs.r3);
linux-user/signal.c:    __get_user(env->regs[4], &sc->regs.r4);
linux-user/signal.c:    __get_user(env->regs[5], &sc->regs.r5);
linux-user/signal.c:    __get_user(env->regs[6], &sc->regs.r6);
linux-user/signal.c:    __get_user(env->regs[7], &sc->regs.r7);
linux-user/signal.c:    __get_user(env->regs[8], &sc->regs.r8);
linux-user/signal.c:    __get_user(env->regs[9], &sc->regs.r9);
linux-user/signal.c:    __get_user(env->regs[10], &sc->regs.r10);
linux-user/signal.c:    __get_user(env->regs[11], &sc->regs.r11);
linux-user/signal.c:    __get_user(env->regs[12], &sc->regs.r12);
linux-user/signal.c:    __get_user(env->regs[13], &sc->regs.r13);
linux-user/signal.c:    __get_user(env->regs[14], &sc->regs.r14);
linux-user/signal.c:    __get_user(env->regs[15], &sc->regs.r15);
linux-user/signal.c:    __get_user(env->regs[16], &sc->regs.r16);
linux-user/signal.c:    __get_user(env->regs[17], &sc->regs.r17);
linux-user/signal.c:    __get_user(env->regs[18], &sc->regs.r18);
linux-user/signal.c:    __get_user(env->regs[19], &sc->regs.r19);
linux-user/signal.c:    __get_user(env->regs[20], &sc->regs.r20);
linux-user/signal.c:    __get_user(env->regs[21], &sc->regs.r21);
linux-user/signal.c:    __get_user(env->regs[22], &sc->regs.r22);
linux-user/signal.c:    __get_user(env->regs[23], &sc->regs.r23);
linux-user/signal.c:    __get_user(env->regs[24], &sc->regs.r24);
linux-user/signal.c:    __get_user(env->regs[25], &sc->regs.r25);
linux-user/signal.c:    __get_user(env->regs[26], &sc->regs.r26);
linux-user/signal.c:    __get_user(env->regs[27], &sc->regs.r27);
linux-user/signal.c:    __get_user(env->regs[28], &sc->regs.r28);
linux-user/signal.c:    __get_user(env->regs[29], &sc->regs.r29);
linux-user/signal.c:    __get_user(env->regs[30], &sc->regs.r30);
linux-user/signal.c:    __get_user(env->regs[31], &sc->regs.r31);
linux-user/signal.c:    __get_user(env->sregs[SR_PC], &sc->regs.pc);
linux-user/signal.c:    abi_ulong sp = env->regs[1];
linux-user/signal.c:        env->regs[15] = ((unsigned long)ka->sa_restorer)-8;
linux-user/signal.c:        env->regs[15] = ((unsigned long)frame->tramp) - 8;
linux-user/signal.c:    env->regs[1] = frame_addr;
linux-user/signal.c:    env->regs[5] = sig; /* Arg 0: signum */
linux-user/signal.c:    env->regs[6] = 0;
linux-user/signal.c:    env->regs[7] = frame_addr += offsetof(typeof(*frame), uc);
linux-user/signal.c:    env->sregs[SR_PC] = (unsigned long)ka->_sa_handler;
linux-user/signal.c:    frame_addr = env->regs[R_SP];
linux-user/signal.c:    env->regs[14] = env->sregs[SR_PC];
linux-user/signal.c:    return env->regs[10];
linux-user/signal.c:	__put_user(env->regs[0], &sc->regs.r0);
linux-user/signal.c:	__put_user(env->regs[1], &sc->regs.r1);
linux-user/signal.c:	__put_user(env->regs[2], &sc->regs.r2);
linux-user/signal.c:	__put_user(env->regs[3], &sc->regs.r3);
linux-user/signal.c:	__put_user(env->regs[4], &sc->regs.r4);
linux-user/signal.c:	__put_user(env->regs[5], &sc->regs.r5);
linux-user/signal.c:	__put_user(env->regs[6], &sc->regs.r6);
linux-user/signal.c:	__put_user(env->regs[7], &sc->regs.r7);
linux-user/signal.c:	__put_user(env->regs[8], &sc->regs.r8);
linux-user/signal.c:	__put_user(env->regs[9], &sc->regs.r9);
linux-user/signal.c:	__put_user(env->regs[10], &sc->regs.r10);
linux-user/signal.c:	__put_user(env->regs[11], &sc->regs.r11);
linux-user/signal.c:	__put_user(env->regs[12], &sc->regs.r12);
linux-user/signal.c:	__put_user(env->regs[13], &sc->regs.r13);
linux-user/signal.c:	__put_user(env->regs[14], &sc->usp);
linux-user/signal.c:	__put_user(env->regs[15], &sc->regs.acr);
linux-user/signal.c:	__put_user(env->pregs[PR_MOF], &sc->regs.mof);
linux-user/signal.c:	__put_user(env->pregs[PR_SRP], &sc->regs.srp);
linux-user/signal.c:	__put_user(env->pc, &sc->regs.erp);
linux-user/signal.c:	__get_user(env->regs[0], &sc->regs.r0);
linux-user/signal.c:	__get_user(env->regs[1], &sc->regs.r1);
linux-user/signal.c:	__get_user(env->regs[2], &sc->regs.r2);
linux-user/signal.c:	__get_user(env->regs[3], &sc->regs.r3);
linux-user/signal.c:	__get_user(env->regs[4], &sc->regs.r4);
linux-user/signal.c:	__get_user(env->regs[5], &sc->regs.r5);
linux-user/signal.c:	__get_user(env->regs[6], &sc->regs.r6);
linux-user/signal.c:	__get_user(env->regs[7], &sc->regs.r7);
linux-user/signal.c:	__get_user(env->regs[8], &sc->regs.r8);
linux-user/signal.c:	__get_user(env->regs[9], &sc->regs.r9);
linux-user/signal.c:	__get_user(env->regs[10], &sc->regs.r10);
linux-user/signal.c:	__get_user(env->regs[11], &sc->regs.r11);
linux-user/signal.c:	__get_user(env->regs[12], &sc->regs.r12);
linux-user/signal.c:	__get_user(env->regs[13], &sc->regs.r13);
linux-user/signal.c:	__get_user(env->regs[14], &sc->usp);
linux-user/signal.c:	__get_user(env->regs[15], &sc->regs.acr);
linux-user/signal.c:	__get_user(env->pregs[PR_MOF], &sc->regs.mof);
linux-user/signal.c:	__get_user(env->pregs[PR_SRP], &sc->regs.srp);
linux-user/signal.c:	__get_user(env->pc, &sc->regs.erp);
linux-user/signal.c:	sp = (env->regs[R_SP] & ~3);
linux-user/signal.c:	env->regs[R_SP] = frame_addr;
linux-user/signal.c:	env->regs[10] = sig;
linux-user/signal.c:	env->pc = (unsigned long) ka->_sa_handler;
linux-user/signal.c:	env->pregs[PR_SRP] = frame_addr + offsetof(typeof(*frame), retcode);
linux-user/signal.c:	frame_addr = env->regs[R_SP];
linux-user/signal.c:	return env->regs[10];
linux-user/signal.c:    sp = env->regs[15];
linux-user/signal.c:    __put_user(env->psw.mask, &sregs->regs.psw.mask);
linux-user/signal.c:    __put_user(env->psw.addr, &sregs->regs.psw.addr);
linux-user/signal.c:        __put_user(env->regs[i], &sregs->regs.gprs[i]);
linux-user/signal.c:        __put_user(env->aregs[i], &sregs->regs.acrs[i]);
linux-user/signal.c:        __put_user(env->fregs[i].ll, &sregs->fpregs.fprs[i]);
linux-user/signal.c:            env->regs[14] = (unsigned long)
linux-user/signal.c:            env->regs[14] = (unsigned long)
linux-user/signal.c:    if (__put_user(env->regs[15], (abi_ulong *) frame)) {
linux-user/signal.c:    env->regs[15] = frame_addr;
linux-user/signal.c:    env->psw.addr = (target_ulong) ka->_sa_handler | PSW_ADDR_AMODE;
linux-user/signal.c:    env->regs[2] = sig; //map_signal(sig);
linux-user/signal.c:    env->regs[3] = frame_addr += offsetof(typeof(*frame), sc);
linux-user/signal.c:    env->regs[4] = 0; // FIXME: no clue... current->thread.trap_no;
linux-user/signal.c:    env->regs[5] = 0; // FIXME: no clue... current->thread.prot_addr;
linux-user/signal.c:    if (__put_user(env->regs[2], (int *) &frame->signo)) {
linux-user/signal.c:        env->regs[14] = (unsigned long) ka->sa_restorer | PSW_ADDR_AMODE;
linux-user/signal.c:        env->regs[14] = (unsigned long) frame->retcode | PSW_ADDR_AMODE;
linux-user/signal.c:    if (__put_user(env->regs[15], (abi_ulong *) frame)) {
linux-user/signal.c:    env->regs[15] = frame_addr;
linux-user/signal.c:    env->psw.addr = (target_ulong) ka->_sa_handler | PSW_ADDR_AMODE;
linux-user/signal.c:    env->regs[2] = sig; //map_signal(sig);
linux-user/signal.c:    env->regs[3] = frame_addr + offsetof(typeof(*frame), info);
linux-user/signal.c:    env->regs[4] = frame_addr + offsetof(typeof(*frame), uc);
linux-user/signal.c:        err |= __get_user(env->regs[i], &sc->regs.gprs[i]);
linux-user/signal.c:    err |= __get_user(env->psw.mask, &sc->regs.psw.mask);
linux-user/signal.c:    qemu_log("%s: sc->regs.psw.addr 0x%llx env->psw.addr 0x%llx\n",
linux-user/signal.c:             (unsigned long long)env->psw.addr);
linux-user/signal.c:    err |= __get_user(env->psw.addr, &sc->regs.psw.addr);
linux-user/signal.c:        err |= __get_user(env->aregs[i], &sc->regs.acrs[i]);
linux-user/signal.c:        err |= __get_user(env->fregs[i].ll, &sc->fpregs.fprs[i]);
linux-user/signal.c:    abi_ulong frame_addr = env->regs[15];
linux-user/signal.c:    return env->regs[2];
linux-user/signal.c:    abi_ulong frame_addr = env->regs[15];
linux-user/signal.c:    return env->regs[2];
linux-user/signal.c:    oldsp = env->gpr[1];
linux-user/signal.c:    target_ulong msr = env->msr;
linux-user/signal.c:    for (i = 0; i < ARRAY_SIZE(env->gpr); i++) {
linux-user/signal.c:        if (__put_user(env->gpr[i], &frame->mc_gregs[i])) {
linux-user/signal.c:    if (__put_user(env->nip, &frame->mc_gregs[TARGET_PT_NIP])
linux-user/signal.c:        || __put_user(env->ctr, &frame->mc_gregs[TARGET_PT_CTR])
linux-user/signal.c:        || __put_user(env->lr, &frame->mc_gregs[TARGET_PT_LNK])
linux-user/signal.c:        || __put_user(env->xer, &frame->mc_gregs[TARGET_PT_XER]))
linux-user/signal.c:    for (i = 0; i < ARRAY_SIZE(env->crf); i++) {
linux-user/signal.c:        ccr |= env->crf[i] << (32 - ((i + 1) * 4));
linux-user/signal.c:    if (env->insns_flags & PPC_ALTIVEC) {
linux-user/signal.c:        for (i = 0; i < ARRAY_SIZE(env->avr); i++) {
linux-user/signal.c:            ppc_avr_t *avr = &env->avr[i];
linux-user/signal.c:        if (__put_user((uint32_t)env->spr[SPR_VRSAVE],
linux-user/signal.c:    if (env->insns_flags & PPC_FLOAT) {
linux-user/signal.c:        for (i = 0; i < ARRAY_SIZE(env->fpr); i++) {
linux-user/signal.c:            if (__put_user(env->fpr[i], &frame->mc_fregs[i])) {
linux-user/signal.c:        if (__put_user((uint64_t) env->fpscr, &frame->mc_fregs[32]))
linux-user/signal.c:    if (env->insns_flags & PPC_SPE) {
linux-user/signal.c:        for (i = 0; i < ARRAY_SIZE(env->gpr); i++) {
linux-user/signal.c:            if (__put_user(env->gpr[i] >> 32, &frame->mc_vregs.spe[i])) {
linux-user/signal.c:        for (i = 0; i < ARRAY_SIZE(env->gprh); i++) {
linux-user/signal.c:            if (__put_user(env->gprh[i], &frame->mc_vregs.spe[i])) {
linux-user/signal.c:        if (__put_user(env->spe_fscr, &frame->mc_vregs.spe[32]))
linux-user/signal.c:        save_r2 = env->gpr[2];
linux-user/signal.c:    for (i = 0; i < ARRAY_SIZE(env->gpr); i++) {
linux-user/signal.c:        if (__get_user(env->gpr[i], &frame->mc_gregs[i])) {
linux-user/signal.c:    if (__get_user(env->nip, &frame->mc_gregs[TARGET_PT_NIP])
linux-user/signal.c:        || __get_user(env->ctr, &frame->mc_gregs[TARGET_PT_CTR])
linux-user/signal.c:        || __get_user(env->lr, &frame->mc_gregs[TARGET_PT_LNK])
linux-user/signal.c:        || __get_user(env->xer, &frame->mc_gregs[TARGET_PT_XER]))
linux-user/signal.c:    for (i = 0; i < ARRAY_SIZE(env->crf); i++) {
linux-user/signal.c:        env->crf[i] = (ccr >> (32 - ((i + 1) * 4))) & 0xf;
linux-user/signal.c:        env->gpr[2] = save_r2;
linux-user/signal.c:        env->msr = (env->msr & ~MSR_LE) | (msr & MSR_LE);
linux-user/signal.c:    if (env->insns_flags & PPC_ALTIVEC) {
linux-user/signal.c:        for (i = 0; i < ARRAY_SIZE(env->avr); i++) {
linux-user/signal.c:            ppc_avr_t *avr = &env->avr[i];
linux-user/signal.c:        if (__get_user(env->spr[SPR_VRSAVE],
linux-user/signal.c:    if (env->insns_flags & PPC_FLOAT) {
linux-user/signal.c:        for (i = 0; i < ARRAY_SIZE(env->fpr); i++) {
linux-user/signal.c:            if (__get_user(env->fpr[i], &frame->mc_fregs[i])) {
linux-user/signal.c:        env->fpscr = (uint32_t) fpscr;
linux-user/signal.c:    if (env->insns_flags & PPC_SPE) {
linux-user/signal.c:        for (i = 0; i < ARRAY_SIZE(env->gpr); i++) {
linux-user/signal.c:            env->gpr[i] = ((uint64_t)hi << 32) | ((uint32_t) env->gpr[i]);
linux-user/signal.c:        for (i = 0; i < ARRAY_SIZE(env->gprh); i++) {
linux-user/signal.c:            if (__get_user(env->gprh[i], &frame->mc_vregs.spe[i])) {
linux-user/signal.c:        if (__get_user(env->spe_fscr, &frame->mc_vregs.spe[32]))
linux-user/signal.c:    env->lr = (target_ulong) h2g(frame->mctx.tramp);
linux-user/signal.c:    env->fpscr = 0;
linux-user/signal.c:    err |= __put_user(env->gpr[1], (target_ulong *)(uintptr_t) newsp);
linux-user/signal.c:    env->gpr[1] = newsp;
linux-user/signal.c:    env->gpr[3] = signal;
linux-user/signal.c:    env->gpr[4] = (target_ulong) h2g(sc);
linux-user/signal.c:    env->nip = (target_ulong) ka->_sa_handler;
linux-user/signal.c:    env->msr &= ~MSR_LE;
linux-user/signal.c:    err |= __put_user(sas_ss_flags(env->gpr[1]),
linux-user/signal.c:    env->lr = (target_ulong) h2g(frame->tramp);
linux-user/signal.c:    env->fpscr = 0;
linux-user/signal.c:    err |= __put_user(env->gpr[1], (target_ulong *)(uintptr_t) newsp);
linux-user/signal.c:    env->gpr[1] = newsp;
linux-user/signal.c:    env->gpr[3] = (target_ulong) signal;
linux-user/signal.c:    env->gpr[4] = (target_ulong) h2g(&rt_sf->info);
linux-user/signal.c:    env->gpr[5] = (target_ulong) h2g(&rt_sf->uc);
linux-user/signal.c:    env->gpr[6] = (target_ulong) h2g(rt_sf);
linux-user/signal.c:    env->nip = (target_ulong) ka->_sa_handler;
linux-user/signal.c:    env->msr &= ~MSR_LE;
linux-user/signal.c:    sc_addr = env->gpr[1] + SIGNAL_FRAMESIZE;
linux-user/signal.c:    rt_sf_addr = env->gpr[1] + SIGNAL_FRAMESIZE + 16;
linux-user/signal.c:                   0, env->gpr[1]);
linux-user/signal.c:    err |= __put_user(env->aregs[7], &sc->sc_usp);
linux-user/signal.c:    err |= __put_user(env->dregs[0], &sc->sc_d0);
linux-user/signal.c:    err |= __put_user(env->dregs[1], &sc->sc_d1);
linux-user/signal.c:    err |= __put_user(env->aregs[0], &sc->sc_a0);
linux-user/signal.c:    err |= __put_user(env->aregs[1], &sc->sc_a1);
linux-user/signal.c:    err |= __put_user(env->sr, &sc->sc_sr);
linux-user/signal.c:    err |= __put_user(env->pc, &sc->sc_pc);
linux-user/signal.c:    err |= __get_user(env->aregs[7], &sc->sc_usp);
linux-user/signal.c:    err |= __get_user(env->dregs[1], &sc->sc_d1);
linux-user/signal.c:    err |= __get_user(env->aregs[0], &sc->sc_a0);
linux-user/signal.c:    err |= __get_user(env->aregs[1], &sc->sc_a1);
linux-user/signal.c:    err |= __get_user(env->pc, &sc->sc_pc);
linux-user/signal.c:    env->sr = (env->sr & 0xff00) | (temp & 0xff);
linux-user/signal.c:    env->aregs[7] = frame_addr;
linux-user/signal.c:    env->pc = ka->_sa_handler;
linux-user/signal.c:    err |= __put_user(env->dregs[0], &gregs[0]);
linux-user/signal.c:    err |= __put_user(env->dregs[1], &gregs[1]);
linux-user/signal.c:    err |= __put_user(env->dregs[2], &gregs[2]);
linux-user/signal.c:    err |= __put_user(env->dregs[3], &gregs[3]);
linux-user/signal.c:    err |= __put_user(env->dregs[4], &gregs[4]);
linux-user/signal.c:    err |= __put_user(env->dregs[5], &gregs[5]);
linux-user/signal.c:    err |= __put_user(env->dregs[6], &gregs[6]);
linux-user/signal.c:    err |= __put_user(env->dregs[7], &gregs[7]);
linux-user/signal.c:    err |= __put_user(env->aregs[0], &gregs[8]);
linux-user/signal.c:    err |= __put_user(env->aregs[1], &gregs[9]);
linux-user/signal.c:    err |= __put_user(env->aregs[2], &gregs[10]);
linux-user/signal.c:    err |= __put_user(env->aregs[3], &gregs[11]);
linux-user/signal.c:    err |= __put_user(env->aregs[4], &gregs[12]);
linux-user/signal.c:    err |= __put_user(env->aregs[5], &gregs[13]);
linux-user/signal.c:    err |= __put_user(env->aregs[6], &gregs[14]);
linux-user/signal.c:    err |= __put_user(env->aregs[7], &gregs[15]);
linux-user/signal.c:    err |= __put_user(env->pc, &gregs[16]);
linux-user/signal.c:    err |= __put_user(env->sr, &gregs[17]);
linux-user/signal.c:    err |= __get_user(env->dregs[0], &gregs[0]);
linux-user/signal.c:    err |= __get_user(env->dregs[1], &gregs[1]);
linux-user/signal.c:    err |= __get_user(env->dregs[2], &gregs[2]);
linux-user/signal.c:    err |= __get_user(env->dregs[3], &gregs[3]);
linux-user/signal.c:    err |= __get_user(env->dregs[4], &gregs[4]);
linux-user/signal.c:    err |= __get_user(env->dregs[5], &gregs[5]);
linux-user/signal.c:    err |= __get_user(env->dregs[6], &gregs[6]);
linux-user/signal.c:    err |= __get_user(env->dregs[7], &gregs[7]);
linux-user/signal.c:    err |= __get_user(env->aregs[0], &gregs[8]);
linux-user/signal.c:    err |= __get_user(env->aregs[1], &gregs[9]);
linux-user/signal.c:    err |= __get_user(env->aregs[2], &gregs[10]);
linux-user/signal.c:    err |= __get_user(env->aregs[3], &gregs[11]);
linux-user/signal.c:    err |= __get_user(env->aregs[4], &gregs[12]);
linux-user/signal.c:    err |= __get_user(env->aregs[5], &gregs[13]);
linux-user/signal.c:    err |= __get_user(env->aregs[6], &gregs[14]);
linux-user/signal.c:    err |= __get_user(env->aregs[7], &gregs[15]);
linux-user/signal.c:    err |= __get_user(env->pc, &gregs[16]);
linux-user/signal.c:    env->sr = (env->sr & 0xff00) | (temp & 0xff);
linux-user/signal.c:    *pd0 = env->dregs[0];
linux-user/signal.c:    err |= __put_user(sas_ss_flags(env->aregs[7]),
linux-user/signal.c:    env->aregs[7] = frame_addr;
linux-user/signal.c:    env->pc = ka->_sa_handler;
linux-user/signal.c:    abi_ulong frame_addr = env->aregs[7] - 4;
linux-user/signal.c:    abi_ulong frame_addr = env->aregs[7] - 4;
linux-user/signal.c:    err |= __put_user(env->pc, &sc->sc_pc);
linux-user/signal.c:        err |= __put_user(env->ir[i], &sc->sc_regs[i]);
linux-user/signal.c:        err |= __put_user(env->fir[i], &sc->sc_fpregs[i]);
linux-user/signal.c:    err |= __get_user(env->pc, &sc->sc_pc);
linux-user/signal.c:        err |= __get_user(env->ir[i], &sc->sc_regs[i]);
linux-user/signal.c:        err |= __get_user(env->fir[i], &sc->sc_fpregs[i]);
linux-user/signal.c:    abi_ulong sp = env->ir[IR_SP];
linux-user/signal.c:    env->ir[IR_RA] = r26;
linux-user/signal.c:    env->ir[IR_PV] = env->pc = ka->_sa_handler;
linux-user/signal.c:    env->ir[IR_A0] = sig;
linux-user/signal.c:    env->ir[IR_A1] = 0;
linux-user/signal.c:    env->ir[IR_A2] = frame_addr + offsetof(struct target_sigframe, sc);
linux-user/signal.c:    env->ir[IR_SP] = frame_addr;
linux-user/signal.c:    err |= __put_user(sas_ss_flags(env->ir[IR_SP]),
linux-user/signal.c:    env->ir[IR_RA] = r26;
linux-user/signal.c:    env->ir[IR_PV] = env->pc = ka->_sa_handler;
linux-user/signal.c:    env->ir[IR_A0] = sig;
linux-user/signal.c:    env->ir[IR_A1] = frame_addr + offsetof(struct target_rt_sigframe, info);
linux-user/signal.c:    env->ir[IR_A2] = frame_addr + offsetof(struct target_rt_sigframe, uc);
linux-user/signal.c:    env->ir[IR_SP] = frame_addr;
linux-user/signal.c:    abi_ulong sc_addr = env->ir[IR_A0];
linux-user/signal.c:    return env->ir[IR_V0];
linux-user/signal.c:    abi_ulong frame_addr = env->ir[IR_A0];
linux-user/signal.c:                       0, env->ir[IR_SP]) == -EFAULT) {
linux-user/signal.c:    return env->ir[IR_V0];
linux-user/signal.c:    TaskState *ts = cpu_env->opaque;
linux-user/signal.c:            if (env->eflags & VM_MASK)
linux-user/linuxload.c:    TaskState *ts = (TaskState *)thread_env->opaque;
linux-user/flatload.c: * create_flat_tables() parses the env- and arg-strings in new user
linux-user/m68k-sim.c:  env->dregs[0] = code;
linux-user/m68k-sim.c:      env->dregs[1] = errno;
linux-user/m68k-sim.c:      env->dregs[1] = 0;
linux-user/m68k-sim.c:    args = (uint32_t *)(unsigned long)(env->aregs[7] + 4);
linux-user/main.c:        thread_env->next_cpu = NULL;
linux-user/main.c:    env->running = 1;
linux-user/main.c:    env->running = 0;
linux-user/main.c:            env->regs[R_EAX] = do_syscall(env,
linux-user/main.c:                                          env->regs[R_EAX],
linux-user/main.c:                                          env->regs[R_EBX],
linux-user/main.c:                                          env->regs[R_ECX],
linux-user/main.c:                                          env->regs[R_EDX],
linux-user/main.c:                                          env->regs[R_ESI],
linux-user/main.c:                                          env->regs[R_EDI],
linux-user/main.c:                                          env->regs[R_EBP],
linux-user/main.c:            env->regs[R_EAX] = do_syscall(env,
linux-user/main.c:                                          env->regs[R_EAX],
linux-user/main.c:                                          env->regs[R_EDI],
linux-user/main.c:                                          env->regs[R_ESI],
linux-user/main.c:                                          env->regs[R_EDX],
linux-user/main.c:                                          env->regs[10],
linux-user/main.c:                                          env->regs[8],
linux-user/main.c:                                          env->regs[9],
linux-user/main.c:            env->eip = env->exception_next_eip;
linux-user/main.c:            if (env->eflags & VM_MASK) {
linux-user/main.c:            if (!(env->error_code & 1))
linux-user/main.c:            info._sifields._sigfault._addr = env->cr[2];
linux-user/main.c:            if (env->eflags & VM_MASK) {
linux-user/main.c:                info._sifields._sigfault._addr = env->eip;
linux-user/main.c:            if (env->eflags & VM_MASK) {
linux-user/main.c:                    info._sifields._sigfault._addr = env->eip;
linux-user/main.c:            if (env->eflags & VM_MASK) {
linux-user/main.c:            info._sifields._sigfault._addr = env->eip;
linux-user/main.c:            pc = env->segs[R_CS].base + env->eip;
linux-user/main.c:    addr = env->regs[2];
linux-user/main.c:    if (get_user_u64(oldval, env->regs[0])) {
linux-user/main.c:        env->cp15.c6_data = env->regs[0];
linux-user/main.c:    if (get_user_u64(newval, env->regs[1])) {
linux-user/main.c:        env->cp15.c6_data = env->regs[1];
linux-user/main.c:        env->cp15.c6_data = addr;
linux-user/main.c:            env->cp15.c6_data = addr;
linux-user/main.c:        env->regs[0] = 0;
linux-user/main.c:        env->regs[0] = -1;
linux-user/main.c:    /* XXX: check env->error_code */
linux-user/main.c:    info._sifields._sigfault._addr = env->cp15.c6_data;
linux-user/main.c:    switch (env->regs[15]) {
linux-user/main.c:        addr = env->regs[2];
linux-user/main.c:            val = ~env->regs[0];
linux-user/main.c:        if (val == env->regs[0]) {
linux-user/main.c:            val = env->regs[1];
linux-user/main.c:            env->regs[0] = 0;
linux-user/main.c:            env->regs[0] = -1;
linux-user/main.c:        env->regs[0] = env->cp15.c13_tls2;
linux-user/main.c:    addr = env->regs[14];
linux-user/main.c:        env->thumb = 1;
linux-user/main.c:    env->regs[15] = addr;
linux-user/main.c:    addr = env->exclusive_addr;
linux-user/main.c:    if (addr != env->exclusive_test) {
linux-user/main.c:    size = env->exclusive_info & 0xf;
linux-user/main.c:        env->cp15.c6_data = addr;
linux-user/main.c:    if (val != env->exclusive_val) {
linux-user/main.c:            env->cp15.c6_data = addr + 4;
linux-user/main.c:        if (val != env->exclusive_high) {
linux-user/main.c:    val = env->regs[(env->exclusive_info >> 8) & 0xf];
linux-user/main.c:        env->cp15.c6_data = addr;
linux-user/main.c:        val = env->regs[(env->exclusive_info >> 12) & 0xf];
linux-user/main.c:            env->cp15.c6_data = addr + 4;
linux-user/main.c:    env->regs[15] += 4;
linux-user/main.c:    env->regs[(env->exclusive_info >> 4) & 0xf] = rc;
linux-user/main.c:                TaskState *ts = env->opaque;
linux-user/main.c:                get_user_code_u32(opcode, env->regs[15], env->bswap_code);
linux-user/main.c:                    info._sifields._sigfault._addr = env->regs[15];
linux-user/main.c:                      info._sifields._sigfault._addr = env->regs[15];
linux-user/main.c:                      env->regs[15] += 4;
linux-user/main.c:                    env->regs[15] += 4;
linux-user/main.c:                env->eabi = 1;
linux-user/main.c:                    if (env->thumb) {
linux-user/main.c:                        get_user_code_u16(insn, env->regs[15], env->bswap_code);
linux-user/main.c:                        env->regs[15] += 2;
linux-user/main.c:                        get_user_code_u32(insn, env->regs[15], env->bswap_code);
linux-user/main.c:                        env->regs[15] += 4;
linux-user/main.c:                    if (env->thumb) {
linux-user/main.c:                        get_user_code_u16(insn, env->regs[15] - 2,
linux-user/main.c:                                          env->bswap_code);
linux-user/main.c:                        get_user_code_u32(insn, env->regs[15] - 4,
linux-user/main.c:                                          env->bswap_code);
linux-user/main.c:                    env->regs[0] = do_arm_semihosting (env);
linux-user/main.c:                           || (env->thumb && n == ARM_THUMB_SYSCALL)) {
linux-user/main.c:                    if (env->thumb || n == 0) {
linux-user/main.c:                        n = env->regs[7];
linux-user/main.c:                        env->eabi = 0;
linux-user/main.c:                            cpu_set_tls(env, env->regs[0]);
linux-user/main.c:                            env->regs[0] = 0;
linux-user/main.c:                            env->regs[0] = -TARGET_ENOSYS;
linux-user/main.c:                        env->regs[0] = do_syscall(env,
linux-user/main.c:                                                  env->regs[0],
linux-user/main.c:                                                  env->regs[1],
linux-user/main.c:                                                  env->regs[2],
linux-user/main.c:                                                  env->regs[3],
linux-user/main.c:                                                  env->regs[4],
linux-user/main.c:                                                  env->regs[5],
linux-user/main.c:            addr = env->cp15.c6_insn;
linux-user/main.c:            addr = env->cp15.c6_data;
linux-user/main.c:                /* XXX: check env->error_code */
linux-user/main.c:                addr = env->cp15.c6_data;
linux-user/main.c:                get_user_u32(insn, env->regs[31] - 4);
linux-user/main.c:                            cpu_set_tls(env, env->regs[0]);
linux-user/main.c:                            env->regs[0] = 0;
linux-user/main.c:                        env->regs[0] = do_syscall(env,
linux-user/main.c:                                                  env->regs[0],
linux-user/main.c:                                                  env->regs[1],
linux-user/main.c:                                                  env->regs[2],
linux-user/main.c:                                                  env->regs[3],
linux-user/main.c:                                                  env->regs[4],
linux-user/main.c:                                                  env->regs[5],
linux-user/main.c:            /* XXX: check env->error_code */
linux-user/main.c:            info._sifields._sigfault._addr = env->cp0.c4_faultaddr;
linux-user/main.c:    index = (index + cwp * 16) % (16 * env->nwindows);
linux-user/main.c:    if (index < 8 && env->cwp == env->nwindows - 1)
linux-user/main.c:        index += 16 * env->nwindows;
linux-user/main.c:    sp_ptr = env->regbase[get_reg_index(env, cwp1, 6)];
linux-user/main.c:        put_user_ual(env->regbase[get_reg_index(env, cwp1, 8 + i)], sp_ptr);
linux-user/main.c:    new_wim = ((env->wim >> 1) | (env->wim << (env->nwindows - 1))) &
linux-user/main.c:        ((1LL << env->nwindows) - 1);
linux-user/main.c:    save_window_offset(env, cpu_cwp_dec(env, env->cwp - 2));
linux-user/main.c:    env->wim = new_wim;
linux-user/main.c:    save_window_offset(env, cpu_cwp_dec(env, env->cwp - 2));
linux-user/main.c:    env->cansave++;
linux-user/main.c:    env->canrestore--;
linux-user/main.c:    new_wim = ((env->wim << 1) | (env->wim >> (env->nwindows - 1))) &
linux-user/main.c:        ((1LL << env->nwindows) - 1);
linux-user/main.c:    cwp1 = cpu_cwp_inc(env, env->cwp + 1);
linux-user/main.c:    sp_ptr = env->regbase[get_reg_index(env, cwp1, 6)];
linux-user/main.c:        get_user_ual(env->regbase[get_reg_index(env, cwp1, 8 + i)], sp_ptr);
linux-user/main.c:    env->canrestore++;
linux-user/main.c:    if (env->cleanwin < env->nwindows - 1)
linux-user/main.c:        env->cleanwin++;
linux-user/main.c:    env->cansave--;
linux-user/main.c:    env->wim = new_wim;
linux-user/main.c:        cwp1 = cpu_cwp_inc(env, env->cwp + offset);
linux-user/main.c:        if (env->wim & (1 << cwp1))
linux-user/main.c:        if (env->canrestore == 0)
linux-user/main.c:        env->cansave++;
linux-user/main.c:        env->canrestore--;
linux-user/main.c:    cwp1 = cpu_cwp_inc(env, env->cwp + 1);
linux-user/main.c:    env->wim = 1 << cwp1;
linux-user/main.c:            ret = do_syscall (env, env->gregs[1],
linux-user/main.c:                              env->regwptr[0], env->regwptr[1],
linux-user/main.c:                              env->regwptr[2], env->regwptr[3],
linux-user/main.c:                              env->regwptr[4], env->regwptr[5],
linux-user/main.c:                env->xcc |= PSR_CARRY;
linux-user/main.c:                env->psr |= PSR_CARRY;
linux-user/main.c:                env->xcc &= ~PSR_CARRY;
linux-user/main.c:                env->psr &= ~PSR_CARRY;
linux-user/main.c:            env->regwptr[0] = ret;
linux-user/main.c:            env->pc = env->npc;
linux-user/main.c:            env->npc = env->npc + 4;
linux-user/main.c:            env->pc = env->npc;
linux-user/main.c:            env->npc = env->npc + 4;
linux-user/main.c:                /* XXX: check env->error_code */
linux-user/main.c:                info._sifields._sigfault._addr = env->mmuregs[4];
linux-user/main.c:                /* XXX: check env->error_code */
linux-user/main.c:                    info._sifields._sigfault._addr = env->dmmuregs[4];
linux-user/main.c:                info._sifields._sigfault._addr = env->pc;
linux-user/main.c:    addr = env->reserve_ea;
linux-user/main.c:        int reg = env->reserve_info & 0x1f;
linux-user/main.c:        int size = (env->reserve_info >> 5) & 0xf;
linux-user/main.c:        if (addr == env->reserve_addr) {
linux-user/main.c:            if (!segv && val == env->reserve_val) {
linux-user/main.c:                val = env->gpr[reg];
linux-user/main.c:        env->crf[0] = (stored << 1) | xer_so;
linux-user/main.c:        env->reserve_addr = (target_ulong)-1;
linux-user/main.c:        env->nip += 4;
linux-user/main.c:                      env->spr[SPR_DAR]);
linux-user/main.c:            switch (env->error_code & 0xFF000000) {
linux-user/main.c:                          env->error_code);
linux-user/main.c:            info._sifields._sigfault._addr = env->nip;
linux-user/main.c:                      "\n", env->spr[SPR_SRR0]);
linux-user/main.c:            switch (env->error_code & 0xFF000000) {
linux-user/main.c:                          env->error_code);
linux-user/main.c:            info._sifields._sigfault._addr = env->nip - 4;
linux-user/main.c:            info._sifields._sigfault._addr = env->nip - 4;
linux-user/main.c:            switch (env->error_code & ~0xF) {
linux-user/main.c:                switch (env->error_code & 0xF) {
linux-user/main.c:                              env->error_code);
linux-user/main.c:                switch (env->error_code & 0xF) {
linux-user/main.c:                              env->error_code & 0xF);
linux-user/main.c:                switch (env->error_code & 0xF) {
linux-user/main.c:                              env->error_code & 0xF);
linux-user/main.c:                          env->error_code);
linux-user/main.c:            info._sifields._sigfault._addr = env->nip - 4;
linux-user/main.c:            info._sifields._sigfault._addr = env->nip - 4;
linux-user/main.c:            info._sifields._sigfault._addr = env->nip - 4;
linux-user/main.c:            info._sifields._sigfault._addr = env->nip - 4;
linux-user/main.c:            info._sifields._sigfault._addr = env->nip - 4;
linux-user/main.c:            env->crf[0] &= ~0x1;
linux-user/main.c:            ret = do_syscall(env, env->gpr[0], env->gpr[3], env->gpr[4],
linux-user/main.c:                             env->gpr[5], env->gpr[6], env->gpr[7],
linux-user/main.c:                             env->gpr[8], 0, 0);
linux-user/main.c:                env->crf[0] |= 0x1;
linux-user/main.c:            env->gpr[3] = ret;
linux-user/main.c:                info._sifields._sigfault._addr = env->nip;
linux-user/main.c:    addr = env->lladdr;
linux-user/main.c:        reg = env->llreg & 0x1f;
linux-user/main.c:        d = (env->llreg & 0x20) != 0;
linux-user/main.c:            if (val != env->llval) {
linux-user/main.c:                env->active_tc.gpr[reg] = 0;
linux-user/main.c:                    segv = put_user_u64(env->llnewval, addr);
linux-user/main.c:                    segv = put_user_u32(env->llnewval, addr);
linux-user/main.c:                    env->active_tc.gpr[reg] = 1;
linux-user/main.c:    env->lladdr = -1;
linux-user/main.c:        env->active_tc.PC += 4;
linux-user/main.c:            syscall_num = env->active_tc.gpr[2] - 4000;
linux-user/main.c:            env->active_tc.PC += 4;
linux-user/main.c:                sp_reg = env->active_tc.gpr[29];
linux-user/main.c:                ret = do_syscall(env, env->active_tc.gpr[2],
linux-user/main.c:                                 env->active_tc.gpr[4],
linux-user/main.c:                                 env->active_tc.gpr[5],
linux-user/main.c:                                 env->active_tc.gpr[6],
linux-user/main.c:                                 env->active_tc.gpr[7],
linux-user/main.c:                env->active_tc.gpr[7] = 1; /* error flag */
linux-user/main.c:                env->active_tc.gpr[7] = 0; /* error flag */
linux-user/main.c:            env->active_tc.gpr[2] = ret;
linux-user/main.c:            /* XXX: check env->error_code */
linux-user/main.c:            info._sifields._sigfault._addr = env->CP0_BadVAddr;
linux-user/main.c:                info._sifields._sigfault._addr = env->active_tc.PC;
linux-user/main.c:            env->pc += 2;
linux-user/main.c:                             env->gregs[3],
linux-user/main.c:                             env->gregs[4],
linux-user/main.c:                             env->gregs[5],
linux-user/main.c:                             env->gregs[6],
linux-user/main.c:                             env->gregs[7],
linux-user/main.c:                             env->gregs[0],
linux-user/main.c:                             env->gregs[1],
linux-user/main.c:            env->gregs[0] = ret;
linux-user/main.c:            info._sifields._sigfault._addr = env->tea;
linux-user/main.c:                /* XXX: check env->error_code */
linux-user/main.c:                info._sifields._sigfault._addr = env->pregs[PR_EDA];
linux-user/main.c:                             env->regs[9], 
linux-user/main.c:                             env->regs[10], 
linux-user/main.c:                             env->regs[11], 
linux-user/main.c:                             env->regs[12], 
linux-user/main.c:                             env->regs[13], 
linux-user/main.c:                             env->pregs[7], 
linux-user/main.c:                             env->pregs[11],
linux-user/main.c:            env->regs[10] = ret;
linux-user/main.c:                /* XXX: check env->error_code */
linux-user/main.c:            env->regs[14] += 4;
linux-user/main.c:                             env->regs[12], 
linux-user/main.c:                             env->regs[5], 
linux-user/main.c:                             env->regs[6], 
linux-user/main.c:                             env->regs[7], 
linux-user/main.c:                             env->regs[8], 
linux-user/main.c:                             env->regs[9], 
linux-user/main.c:                             env->regs[10],
linux-user/main.c:            env->regs[3] = ret;
linux-user/main.c:            env->sregs[SR_PC] = env->regs[14];
linux-user/main.c:            env->regs[17] = env->sregs[SR_PC] + 4;
linux-user/main.c:            if (env->iflags & D_FLAG) {
linux-user/main.c:                env->sregs[SR_ESR] |= 1 << 12;
linux-user/main.c:                env->sregs[SR_PC] -= 4;
linux-user/main.c:            env->iflags &= ~(IMM_FLAG | D_FLAG);
linux-user/main.c:            switch (env->sregs[SR_ESR] & 31) {
linux-user/main.c:                    if (env->sregs[SR_FSR] & FSR_IO) {
linux-user/main.c:                    if (env->sregs[SR_FSR] & FSR_DZ) {
linux-user/main.c:                            env->sregs[SR_ESR] & ESR_EC_MASK);
linux-user/main.c:    TaskState *ts = env->opaque;
linux-user/main.c:                    nr = lduw(env->pc + 2);
linux-user/main.c:                    env->pc += 4;
linux-user/main.c:            env->pc += 4;
linux-user/main.c:            do_m68k_semihosting(env, env->dregs[0]);
linux-user/main.c:            info._sifields._sigfault._addr = env->pc;
linux-user/main.c:                n = env->dregs[0];
linux-user/main.c:                env->pc += 2;
linux-user/main.c:                env->dregs[0] = do_syscall(env,
linux-user/main.c:                                          env->dregs[1],
linux-user/main.c:                                          env->dregs[2],
linux-user/main.c:                                          env->dregs[3],
linux-user/main.c:                                          env->dregs[4],
linux-user/main.c:                                          env->dregs[5],
linux-user/main.c:                                          env->aregs[0],
linux-user/main.c:                /* XXX: check env->error_code */
linux-user/main.c:                info._sifields._sigfault._addr = env->mmu.ar;
linux-user/main.c:    addr = env->lock_addr;
linux-user/main.c:    tmp = env->lock_st_addr;
linux-user/main.c:    env->lock_addr = -1;
linux-user/main.c:    env->lock_st_addr = 0;
linux-user/main.c:        if (val == env->lock_value) {
linux-user/main.c:            tmp = env->ir[reg];
linux-user/main.c:    env->ir[reg] = ret;
linux-user/main.c:    env->pc += 4;
linux-user/main.c:        env->intr_flag = 0;
linux-user/main.c:            env->lock_addr = -1;
linux-user/main.c:            info.si_code = (page_get_flags(env->trap_arg0) & PAGE_VALID
linux-user/main.c:            info._sifields._sigfault._addr = env->trap_arg0;
linux-user/main.c:            env->lock_addr = -1;
linux-user/main.c:            info._sifields._sigfault._addr = env->trap_arg0;
linux-user/main.c:            env->lock_addr = -1;
linux-user/main.c:            info._sifields._sigfault._addr = env->pc;
linux-user/main.c:            env->lock_addr = -1;
linux-user/main.c:            info._sifields._sigfault._addr = env->pc;
linux-user/main.c:            env->lock_addr = -1;
linux-user/main.c:            switch (env->error_code) {
linux-user/main.c:                info._sifields._sigfault._addr = env->pc;
linux-user/main.c:                info._sifields._sigfault._addr = env->pc;
linux-user/main.c:                trapnr = env->ir[IR_V0];
linux-user/main.c:                                    env->ir[IR_A0], env->ir[IR_A1],
linux-user/main.c:                                    env->ir[IR_A2], env->ir[IR_A3],
linux-user/main.c:                                    env->ir[IR_A4], env->ir[IR_A5],
linux-user/main.c:                if (env->ir[IR_V0] == 0) {
linux-user/main.c:                    env->ir[IR_V0] = sysret;
linux-user/main.c:                    env->ir[IR_V0] = (sysret < 0 ? -sysret : sysret);
linux-user/main.c:                    env->ir[IR_A3] = (sysret < 0);
linux-user/main.c:                switch (env->ir[IR_A0]) {
linux-user/main.c:                info._sifields._sigfault._addr = env->pc;
linux-user/main.c:                env->lock_addr = -1;
linux-user/main.c:            do_store_exclusive(env, env->error_code, trapnr - EXCP_STL_C);
linux-user/main.c:                int n = env->int_svc_code;
linux-user/main.c:                    n = env->regs[1];
linux-user/main.c:                env->psw.addr += env->int_svc_ilc;
linux-user/main.c:                env->regs[2] = do_syscall(env, n,
linux-user/main.c:                           env->regs[2],
linux-user/main.c:                           env->regs[3],
linux-user/main.c:                           env->regs[4],
linux-user/main.c:                           env->regs[5],
linux-user/main.c:                           env->regs[6],
linux-user/main.c:                           env->regs[7],
linux-user/main.c:                /* XXX: check env->error_code */
linux-user/main.c:                info._sifields._sigfault._addr = env->__excp_addr;
linux-user/main.c:                fprintf(stderr,"specification exception insn 0x%08x%04x\n", ldl(env->psw.addr), lduw(env->psw.addr + 4));
linux-user/main.c:                info._sifields._sigfault._addr = env->__excp_addr;
linux-user/main.c:    env->opaque = ts;
linux-user/main.c:    env->cr[0] = CR0_PG_MASK | CR0_WP_MASK | CR0_PE_MASK;
linux-user/main.c:    env->hflags |= HF_PE_MASK;
linux-user/main.c:    if (env->cpuid_features & CPUID_SSE) {
linux-user/main.c:        env->cr[4] |= CR4_OSFXSR_MASK;
linux-user/main.c:        env->hflags |= HF_OSFXSR_MASK;
linux-user/main.c:    if (!(env->cpuid_ext2_features & CPUID_EXT2_LM)) {
linux-user/main.c:    env->cr[4] |= CR4_PAE_MASK;
linux-user/main.c:    env->efer |= MSR_EFER_LMA | MSR_EFER_LME;
linux-user/main.c:    env->hflags |= HF_LMA_MASK;
linux-user/main.c:    env->eflags |= IF_MASK;
linux-user/main.c:    env->regs[R_EAX] = regs->rax;
linux-user/main.c:    env->regs[R_EBX] = regs->rbx;
linux-user/main.c:    env->regs[R_ECX] = regs->rcx;
linux-user/main.c:    env->regs[R_EDX] = regs->rdx;
linux-user/main.c:    env->regs[R_ESI] = regs->rsi;
linux-user/main.c:    env->regs[R_EDI] = regs->rdi;
linux-user/main.c:    env->regs[R_EBP] = regs->rbp;
linux-user/main.c:    env->regs[R_ESP] = regs->rsp;
linux-user/main.c:    env->eip = regs->rip;
linux-user/main.c:    env->regs[R_EAX] = regs->eax;
linux-user/main.c:    env->regs[R_EBX] = regs->ebx;
linux-user/main.c:    env->regs[R_ECX] = regs->ecx;
linux-user/main.c:    env->regs[R_EDX] = regs->edx;
linux-user/main.c:    env->regs[R_ESI] = regs->esi;
linux-user/main.c:    env->regs[R_EDI] = regs->edi;
linux-user/main.c:    env->regs[R_EBP] = regs->ebp;
linux-user/main.c:    env->regs[R_ESP] = regs->esp;
linux-user/main.c:    env->eip = regs->eip;
linux-user/main.c:    env->idt.limit = 511;
linux-user/main.c:    env->idt.limit = 255;
linux-user/main.c:    env->idt.base = target_mmap(0, sizeof(uint64_t) * (env->idt.limit + 1),
linux-user/main.c:    idt_table = g2h(env->idt.base);
linux-user/main.c:        env->gdt.base = target_mmap(0, sizeof(uint64_t) * TARGET_GDT_ENTRIES,
linux-user/main.c:        env->gdt.limit = sizeof(uint64_t) * TARGET_GDT_ENTRIES - 1;
linux-user/main.c:        gdt_table = g2h(env->gdt.base);
linux-user/main.c:    env->segs[R_FS].selector = 0;
linux-user/main.c:            env->regs[i] = regs->uregs[i];
linux-user/main.c:            env->bswap_code = 1;
linux-user/main.c:            env->regs[i] = regs->uregs[i];
linux-user/main.c:	env->pc = regs->pc;
linux-user/main.c:	env->npc = regs->npc;
linux-user/main.c:        env->y = regs->y;
linux-user/main.c:            env->gregs[i] = regs->u_regs[i];
linux-user/main.c:            env->regwptr[i] = regs->u_regs[i + 8];
linux-user/main.c:        env->msr &= ~((target_ulong)1 << MSR_SF);
linux-user/main.c:        env->msr |= (target_ulong)1 << MSR_SF;
linux-user/main.c:        env->nip = regs->nip;
linux-user/main.c:            env->gpr[i] = regs->gpr[i];
linux-user/main.c:        env->pc = regs->pc;
linux-user/main.c:        env->dregs[0] = regs->d0;
linux-user/main.c:        env->dregs[1] = regs->d1;
linux-user/main.c:        env->dregs[2] = regs->d2;
linux-user/main.c:        env->dregs[3] = regs->d3;
linux-user/main.c:        env->dregs[4] = regs->d4;
linux-user/main.c:        env->dregs[5] = regs->d5;
linux-user/main.c:        env->dregs[6] = regs->d6;
linux-user/main.c:        env->dregs[7] = regs->d7;
linux-user/main.c:        env->aregs[0] = regs->a0;
linux-user/main.c:        env->aregs[1] = regs->a1;
linux-user/main.c:        env->aregs[2] = regs->a2;
linux-user/main.c:        env->aregs[3] = regs->a3;
linux-user/main.c:        env->aregs[4] = regs->a4;
linux-user/main.c:        env->aregs[5] = regs->a5;
linux-user/main.c:        env->aregs[6] = regs->a6;
linux-user/main.c:        env->aregs[7] = regs->usp;
linux-user/main.c:        env->sr = regs->sr;
linux-user/main.c:        env->regs[0] = regs->r0;
linux-user/main.c:        env->regs[1] = regs->r1;
linux-user/main.c:        env->regs[2] = regs->r2;
linux-user/main.c:        env->regs[3] = regs->r3;
linux-user/main.c:        env->regs[4] = regs->r4;
linux-user/main.c:        env->regs[5] = regs->r5;
linux-user/main.c:        env->regs[6] = regs->r6;
linux-user/main.c:        env->regs[7] = regs->r7;
linux-user/main.c:        env->regs[8] = regs->r8;
linux-user/main.c:        env->regs[9] = regs->r9;
linux-user/main.c:        env->regs[10] = regs->r10;
linux-user/main.c:        env->regs[11] = regs->r11;
linux-user/main.c:        env->regs[12] = regs->r12;
linux-user/main.c:        env->regs[13] = regs->r13;
linux-user/main.c:        env->regs[14] = regs->r14;
linux-user/main.c:        env->regs[15] = regs->r15;	    
linux-user/main.c:        env->regs[16] = regs->r16;	    
linux-user/main.c:        env->regs[17] = regs->r17;	    
linux-user/main.c:        env->regs[18] = regs->r18;	    
linux-user/main.c:        env->regs[19] = regs->r19;	    
linux-user/main.c:        env->regs[20] = regs->r20;	    
linux-user/main.c:        env->regs[21] = regs->r21;	    
linux-user/main.c:        env->regs[22] = regs->r22;	    
linux-user/main.c:        env->regs[23] = regs->r23;	    
linux-user/main.c:        env->regs[24] = regs->r24;	    
linux-user/main.c:        env->regs[25] = regs->r25;	    
linux-user/main.c:        env->regs[26] = regs->r26;	    
linux-user/main.c:        env->regs[27] = regs->r27;	    
linux-user/main.c:        env->regs[28] = regs->r28;	    
linux-user/main.c:        env->regs[29] = regs->r29;	    
linux-user/main.c:        env->regs[30] = regs->r30;	    
linux-user/main.c:        env->regs[31] = regs->r31;	    
linux-user/main.c:        env->sregs[SR_PC] = regs->pc;
linux-user/main.c:            env->active_tc.gpr[i] = regs->regs[i];
linux-user/main.c:        env->active_tc.PC = regs->cp0_epc & ~(target_ulong)1;
linux-user/main.c:            env->hflags |= MIPS_HFLAG_M16;
linux-user/main.c:            env->gregs[i] = regs->regs[i];
linux-user/main.c:        env->pc = regs->pc;
linux-user/main.c:            env->ir[i] = ((abi_ulong *)regs)[i];
linux-user/main.c:        env->ir[IR_SP] = regs->usp;
linux-user/main.c:        env->pc = regs->pc;
linux-user/main.c:	    env->regs[0] = regs->r0;
linux-user/main.c:	    env->regs[1] = regs->r1;
linux-user/main.c:	    env->regs[2] = regs->r2;
linux-user/main.c:	    env->regs[3] = regs->r3;
linux-user/main.c:	    env->regs[4] = regs->r4;
linux-user/main.c:	    env->regs[5] = regs->r5;
linux-user/main.c:	    env->regs[6] = regs->r6;
linux-user/main.c:	    env->regs[7] = regs->r7;
linux-user/main.c:	    env->regs[8] = regs->r8;
linux-user/main.c:	    env->regs[9] = regs->r9;
linux-user/main.c:	    env->regs[10] = regs->r10;
linux-user/main.c:	    env->regs[11] = regs->r11;
linux-user/main.c:	    env->regs[12] = regs->r12;
linux-user/main.c:	    env->regs[13] = regs->r13;
linux-user/main.c:	    env->regs[14] = info->start_stack;
linux-user/main.c:	    env->regs[15] = regs->acr;	    
linux-user/main.c:	    env->pc = regs->erp;
linux-user/main.c:                env->regs[i] = regs->gprs[i];
linux-user/main.c:            env->psw.mask = regs->psw.mask;
linux-user/main.c:            env->psw.addr = regs->psw.addr;
linux-user/cpu-uname.c:     * to test by CPU id, compare cpu_env->cp15.c0_cpuid to ARM_CPUID_*
linux-user/syscall.c:        env->ldt.base = target_mmap(0,
linux-user/syscall.c:        if (env->ldt.base == -1)
linux-user/syscall.c:        memset(g2h(env->ldt.base), 0,
linux-user/syscall.c:        env->ldt.limit = 0xffff;
linux-user/syscall.c:        ldt_table = g2h(env->ldt.base);
linux-user/syscall.c:    uint64_t *gdt_table = g2h(env->gdt.base);
linux-user/syscall.c:    uint64_t *gdt_table = g2h(env->gdt.base);
linux-user/syscall.c:        env->segs[idx].base = addr;
linux-user/syscall.c:        val = env->segs[idx].base;
linux-user/syscall.c:    ts = (TaskState *)thread_env->opaque;
linux-user/syscall.c:    env->host_tid = info->tid;
linux-user/syscall.c:        TaskState *parent_ts = (TaskState *)env->opaque;
linux-user/syscall.c:        new_env->opaque = ts;
linux-user/syscall.c:            ts = (TaskState *)env->opaque;
m68k-semi.c:    args = env->dregs[1];
m68k-semi.c:    args = env->dregs[1];
m68k-semi.c:        gdb_exit(env, env->dregs[0]);
m68k-semi.c:        exit(env->dregs[0]);
m68k-semi.c:        TaskState *ts = env->opaque;
m68k-semi.c:        env->dregs[1] = ts->heap_limit;
m68k-semi.c:        env->aregs[7] = ts->stack_base;
m68k-semi.c:        env->dregs[1] = ram_size;
m68k-semi.c:        env->aregs[7] = ram_size;
monitor.c:    for(env = first_cpu; env != NULL; env = env->next_cpu) {
monitor.c:        if (env->cpu_index == cpu_index) {
monitor.c:                if ((env->efer & MSR_EFER_LMA) &&
monitor.c:                    (env->segs[R_CS].flags & DESC_L_MASK))
monitor.c:                if (!(env->segs[R_CS].flags & DESC_B_MASK))
monitor.c:    pgd = env->cr[3] & ~0xfff;
monitor.c:            if ((pde & PG_PSE_MASK) && (env->cr[4] & CR4_PSE_MASK)) {
monitor.c:    pdp_addr = env->cr[3] & ~0x1f;
monitor.c:    pml4_addr = env->cr[3] & 0x3fffffffff000ULL;
monitor.c:    if (!(env->cr[0] & CR0_PG_MASK)) {
monitor.c:    if (env->cr[4] & CR4_PAE_MASK) {
monitor.c:        if (env->hflags & HF_LMA_MASK) {
monitor.c:    pgd = env->cr[3] & ~0xfff;
monitor.c:            if ((pde & PG_PSE_MASK) && (env->cr[4] & CR4_PSE_MASK)) {
monitor.c:    pdp_addr = env->cr[3] & ~0x1f;
monitor.c:    pml4_addr = env->cr[3] & 0x3fffffffff000ULL;
monitor.c:    if (!(env->cr[0] & CR0_PG_MASK)) {
monitor.c:    if (env->cr[4] & CR4_PAE_MASK) {
monitor.c:        if (env->hflags & HF_LMA_MASK) {
monitor.c:        print_tlb (mon, i, &env->itlb[i]);
monitor.c:        print_tlb (mon, i, &env->utlb[i]);
monitor.c:        for (env = first_cpu; env != NULL; env = env->next_cpu) {
monitor.c:            if (env->numa_node == i) {
monitor.c:                monitor_printf(mon, " %d", env->cpu_index);
monitor.c:    for (cenv = first_cpu; cenv != NULL; cenv = cenv->next_cpu) {
monitor.c:        if (cenv->cpu_index == cpu_index) {
monitor.c:    return env->eip + env->segs[R_CS].base;
monitor.c:        u |= env->crf[i] << (32 - (4 * i));
monitor.c:    return env->msr;
monitor.c:    return env->xer;
monitor.c:    return env->regwptr[val];
softmmu_header.h:    if (unlikely(env->tlb_table[mmu_idx][page_index].ADDR_READ !=
softmmu_header.h:        uintptr_t hostaddr = addr + env->tlb_table[mmu_idx][page_index].addend;
softmmu_header.h:    if (unlikely(env->tlb_table[mmu_idx][page_index].ADDR_READ !=
softmmu_header.h:        uintptr_t hostaddr = addr + env->tlb_table[mmu_idx][page_index].addend;
softmmu_header.h:    if (unlikely(env->tlb_table[mmu_idx][page_index].addr_write !=
softmmu_header.h:        uintptr_t hostaddr = addr + env->tlb_table[mmu_idx][page_index].addend;
softmmu_template.h:    env->mem_io_pc = retaddr;
softmmu_template.h:    env->mem_io_vaddr = addr;
softmmu_template.h:    tlb_addr = env->tlb_table[mmu_idx][index].ADDR_READ;
softmmu_template.h:            ioaddr = env->iotlb[mmu_idx][index];
softmmu_template.h:            addend = env->tlb_table[mmu_idx][index].addend;
softmmu_template.h:    tlb_addr = env->tlb_table[mmu_idx][index].ADDR_READ;
softmmu_template.h:            ioaddr = env->iotlb[mmu_idx][index];
softmmu_template.h:            uintptr_t addend = env->tlb_table[mmu_idx][index].addend;
softmmu_template.h:    env->mem_io_vaddr = addr;
softmmu_template.h:    env->mem_io_pc = retaddr;
softmmu_template.h:    tlb_addr = env->tlb_table[mmu_idx][index].addr_write;
softmmu_template.h:            ioaddr = env->iotlb[mmu_idx][index];
softmmu_template.h:            addend = env->tlb_table[mmu_idx][index].addend;
softmmu_template.h:    tlb_addr = env->tlb_table[mmu_idx][index].addr_write;
softmmu_template.h:            ioaddr = env->iotlb[mmu_idx][index];
softmmu_template.h:            uintptr_t addend = env->tlb_table[mmu_idx][index].addend;
target-alpha/cpu.h:    if (env->pal_mode) {
target-alpha/cpu.h:    } else if (env->ps & PS_USER_MODE) {
target-alpha/cpu.h:    *pc = env->pc;
target-alpha/cpu.h:    if (env->pal_mode) {
target-alpha/cpu.h:        flags = env->ps & PS_USER_MODE;
target-alpha/cpu.h:    if (env->fen) {
target-alpha/cpu.h:    flags |= env->amask << TB_FLAGS_AMASK_SHIFT;
target-alpha/cpu.h:        env->ir[IR_SP] = newsp;
target-alpha/cpu.h:    env->ir[IR_V0] = 0;
target-alpha/cpu.h:    env->ir[IR_A3] = 0;
target-alpha/cpu.h:    env->unique = newtls;
target-alpha/cpu.h:    return env->interrupt_request & (CPU_INTERRUPT_HARD
target-alpha/cpu.h:    env->pc = tb->pc;
target-alpha/helper.c:    t = env->fpcr_exc_status;
target-alpha/helper.c:    t = env->fpcr_exc_mask;
target-alpha/helper.c:    switch (env->fpcr_dyn_round) {
target-alpha/helper.c:    if (env->fp_status.flush_inputs_to_zero) {
target-alpha/helper.c:    if (env->fpcr_dnod) {
target-alpha/helper.c:    if (env->fpcr_undz) {
target-alpha/helper.c:    env->fpcr_exc_status = t;
target-alpha/helper.c:    env->fpcr_exc_mask = t;
target-alpha/helper.c:    env->fpcr_dyn_round = t;
target-alpha/helper.c:    env->fpcr_dnod = (val & FPCR_DNOD) != 0;
target-alpha/helper.c:    env->fpcr_undz = (val & FPCR_UNDZ) != 0;
target-alpha/helper.c:    env->fpcr_flush_to_zero = env->fpcr_dnod & env->fpcr_undz;
target-alpha/helper.c:    env->fp_status.flush_inputs_to_zero = (val & FPCR_DNZ) != 0;
target-alpha/helper.c:    env->exception_index = EXCP_MMFAULT;
target-alpha/helper.c:    env->trap_arg0 = address;
target-alpha/helper.c:    i0 = env->ir[8];
target-alpha/helper.c:    i1 = env->ir[9];
target-alpha/helper.c:    i2 = env->ir[10];
target-alpha/helper.c:    i3 = env->ir[11];
target-alpha/helper.c:    i4 = env->ir[12];
target-alpha/helper.c:    i5 = env->ir[13];
target-alpha/helper.c:    i6 = env->ir[14];
target-alpha/helper.c:    i7 = env->ir[25];
target-alpha/helper.c:    env->ir[8]  = env->shadow[0];
target-alpha/helper.c:    env->ir[9]  = env->shadow[1];
target-alpha/helper.c:    env->ir[10] = env->shadow[2];
target-alpha/helper.c:    env->ir[11] = env->shadow[3];
target-alpha/helper.c:    env->ir[12] = env->shadow[4];
target-alpha/helper.c:    env->ir[13] = env->shadow[5];
target-alpha/helper.c:    env->ir[14] = env->shadow[6];
target-alpha/helper.c:    env->ir[25] = env->shadow[7];
target-alpha/helper.c:    env->shadow[0] = i0;
target-alpha/helper.c:    env->shadow[1] = i1;
target-alpha/helper.c:    env->shadow[2] = i2;
target-alpha/helper.c:    env->shadow[3] = i3;
target-alpha/helper.c:    env->shadow[4] = i4;
target-alpha/helper.c:    env->shadow[5] = i5;
target-alpha/helper.c:    env->shadow[6] = i6;
target-alpha/helper.c:    env->shadow[7] = i7;
target-alpha/helper.c:    pt = env->ptbr;
target-alpha/helper.c:        env->exception_index = EXCP_MMFAULT;
target-alpha/helper.c:        env->trap_arg0 = addr;
target-alpha/helper.c:        env->trap_arg1 = fail;
target-alpha/helper.c:        env->trap_arg2 = (rw == 2 ? -1 : rw);
target-alpha/helper.c:    int i = env->exception_index;
target-alpha/helper.c:                 ++count, name, env->error_code, env->pc, env->ir[IR_SP]);
target-alpha/helper.c:    env->exception_index = -1;
target-alpha/helper.c:        i = env->error_code;
target-alpha/helper.c:    env->exc_addr = env->pc | env->pal_mode;
target-alpha/helper.c:    env->pc = env->palbr + i;
target-alpha/helper.c:    if (!env->pal_mode) {
target-alpha/helper.c:        env->pal_mode = 1;
target-alpha/helper.c:                env->pc, env->ps);
target-alpha/helper.c:                    linux_reg_names[i], env->ir[i]);
target-alpha/helper.c:                env->lock_addr, env->lock_value);
target-alpha/helper.c:                    *((uint64_t *)(&env->fir[i])));
target-alpha/helper.c:    env->exception_index = excp;
target-alpha/helper.c:    env->error_code = error;
target-alpha/helper.c:    env->exception_index = excp;
target-alpha/helper.c:    env->error_code = error;
target-alpha/helper.c:    env->trap_arg0 = exc;
target-alpha/helper.c:    env->trap_arg1 = mask;
target-alpha/sys_helper.c:    return (((uint64_t)env->pcc_ofs << 32)
target-alpha/sys_helper.c:    env->pc = a & ~3;
target-alpha/sys_helper.c:    env->intr_flag = 0;
target-alpha/sys_helper.c:    env->lock_addr = -1;
target-alpha/sys_helper.c:        env->pal_mode = 0;
target-alpha/sys_helper.c:        env->alarm_expire = expire;
target-alpha/sys_helper.c:        qemu_mod_timer(env->alarm_timer, expire);
target-alpha/sys_helper.c:        qemu_del_timer(env->alarm_timer);
target-alpha/cpu.c:    env->ps = PS_USER_MODE;
target-alpha/cpu.c:    env->lock_addr = -1;
target-alpha/cpu.c:    env->fen = 1;
target-alpha/fpu_helper.c:#define FP_STATUS (env->fp_status)
target-alpha/fpu_helper.c:        env->fpcr_exc_status |= exc;
target-alpha/fpu_helper.c:        exc &= ~env->fpcr_exc_mask;
target-alpha/fpu_helper.c:        if (frac != 0 && !env->fp_status.flush_inputs_to_zero) {
target-alpha/fpu_helper.c:        if (frac != 0 && !env->fp_status.flush_inputs_to_zero) {
target-alpha/mem_helper.c:    env->lock_addr = p;
target-alpha/mem_helper.c:    return env->lock_value = (int32_t)ldl_phys(p);
target-alpha/mem_helper.c:    env->lock_addr = p;
target-alpha/mem_helper.c:    return env->lock_value = ldq_phys(p);
target-alpha/mem_helper.c:    if (p == env->lock_addr) {
target-alpha/mem_helper.c:        if (old == (int32_t)env->lock_value) {
target-alpha/mem_helper.c:    env->lock_addr = -1;
target-alpha/mem_helper.c:    if (p == env->lock_addr) {
target-alpha/mem_helper.c:        if (old == env->lock_value) {
target-alpha/mem_helper.c:    env->lock_addr = -1;
target-alpha/mem_helper.c:    pc = env->pc;
target-alpha/mem_helper.c:    env->trap_arg0 = addr;
target-alpha/mem_helper.c:    env->trap_arg1 = insn >> 26;                /* opcode */
target-alpha/mem_helper.c:    env->trap_arg2 = (insn >> 21) & 31;         /* dest regno */
target-alpha/mem_helper.c:    env->exception_index = EXCP_UNALIGN;
target-alpha/mem_helper.c:    env->error_code = 0;
target-alpha/mem_helper.c:    env->trap_arg0 = addr;
target-alpha/mem_helper.c:    env->trap_arg1 = is_write;
target-alpha/translate.c:            && !ctx->env->singlestep_enabled
target-alpha/translate.c:                tcg_gen_movi_i64(cpu_ir[rc], ctx->env->implver);
target-alpha/translate.c:        if (unlikely(!QTAILQ_EMPTY(&env->breakpoints))) {
target-alpha/translate.c:            QTAILQ_FOREACH(bp, &env->breakpoints, entry) {
target-alpha/translate.c:                || env->singlestep_enabled)) {
target-alpha/translate.c:        if (env->singlestep_enabled) {
target-alpha/translate.c:    env->implver = implver;
target-alpha/translate.c:    env->amask = amask;
target-alpha/translate.c:    env->pc = gen_opc_pc[pc_pos];
target-arm/neon_helper.c:#define SET_QC() env->vfp.xregs[ARM_VFP_FPSCR] = CPSR_Q
target-arm/neon_helper.c:    uint64_t zm0 = float64_val(env->vfp.regs[rm]);
target-arm/neon_helper.c:    uint64_t zm1 = float64_val(env->vfp.regs[rm + 1]);
target-arm/neon_helper.c:    uint64_t zd0 = float64_val(env->vfp.regs[rd]);
target-arm/neon_helper.c:    uint64_t zd1 = float64_val(env->vfp.regs[rd + 1]);
target-arm/neon_helper.c:    env->vfp.regs[rm] = make_float64(m0);
target-arm/neon_helper.c:    env->vfp.regs[rm + 1] = make_float64(m1);
target-arm/neon_helper.c:    env->vfp.regs[rd] = make_float64(d0);
target-arm/neon_helper.c:    env->vfp.regs[rd + 1] = make_float64(d1);
target-arm/neon_helper.c:    uint64_t zm0 = float64_val(env->vfp.regs[rm]);
target-arm/neon_helper.c:    uint64_t zm1 = float64_val(env->vfp.regs[rm + 1]);
target-arm/neon_helper.c:    uint64_t zd0 = float64_val(env->vfp.regs[rd]);
target-arm/neon_helper.c:    uint64_t zd1 = float64_val(env->vfp.regs[rd + 1]);
target-arm/neon_helper.c:    env->vfp.regs[rm] = make_float64(m0);
target-arm/neon_helper.c:    env->vfp.regs[rm + 1] = make_float64(m1);
target-arm/neon_helper.c:    env->vfp.regs[rd] = make_float64(d0);
target-arm/neon_helper.c:    env->vfp.regs[rd + 1] = make_float64(d1);
target-arm/neon_helper.c:    uint64_t zm0 = float64_val(env->vfp.regs[rm]);
target-arm/neon_helper.c:    uint64_t zm1 = float64_val(env->vfp.regs[rm + 1]);
target-arm/neon_helper.c:    uint64_t zd0 = float64_val(env->vfp.regs[rd]);
target-arm/neon_helper.c:    uint64_t zd1 = float64_val(env->vfp.regs[rd + 1]);
target-arm/neon_helper.c:    env->vfp.regs[rm] = make_float64(m0);
target-arm/neon_helper.c:    env->vfp.regs[rm + 1] = make_float64(m1);
target-arm/neon_helper.c:    env->vfp.regs[rd] = make_float64(d0);
target-arm/neon_helper.c:    env->vfp.regs[rd + 1] = make_float64(d1);
target-arm/neon_helper.c:    uint64_t zm = float64_val(env->vfp.regs[rm]);
target-arm/neon_helper.c:    uint64_t zd = float64_val(env->vfp.regs[rd]);
target-arm/neon_helper.c:    env->vfp.regs[rm] = make_float64(m0);
target-arm/neon_helper.c:    env->vfp.regs[rd] = make_float64(d0);
target-arm/neon_helper.c:    uint64_t zm = float64_val(env->vfp.regs[rm]);
target-arm/neon_helper.c:    uint64_t zd = float64_val(env->vfp.regs[rd]);
target-arm/neon_helper.c:    env->vfp.regs[rm] = make_float64(m0);
target-arm/neon_helper.c:    env->vfp.regs[rd] = make_float64(d0);
target-arm/neon_helper.c:    uint64_t zm0 = float64_val(env->vfp.regs[rm]);
target-arm/neon_helper.c:    uint64_t zm1 = float64_val(env->vfp.regs[rm + 1]);
target-arm/neon_helper.c:    uint64_t zd0 = float64_val(env->vfp.regs[rd]);
target-arm/neon_helper.c:    uint64_t zd1 = float64_val(env->vfp.regs[rd + 1]);
target-arm/neon_helper.c:    env->vfp.regs[rm] = make_float64(m0);
target-arm/neon_helper.c:    env->vfp.regs[rm + 1] = make_float64(m1);
target-arm/neon_helper.c:    env->vfp.regs[rd] = make_float64(d0);
target-arm/neon_helper.c:    env->vfp.regs[rd + 1] = make_float64(d1);
target-arm/neon_helper.c:    uint64_t zm0 = float64_val(env->vfp.regs[rm]);
target-arm/neon_helper.c:    uint64_t zm1 = float64_val(env->vfp.regs[rm + 1]);
target-arm/neon_helper.c:    uint64_t zd0 = float64_val(env->vfp.regs[rd]);
target-arm/neon_helper.c:    uint64_t zd1 = float64_val(env->vfp.regs[rd + 1]);
target-arm/neon_helper.c:    env->vfp.regs[rm] = make_float64(m0);
target-arm/neon_helper.c:    env->vfp.regs[rm + 1] = make_float64(m1);
target-arm/neon_helper.c:    env->vfp.regs[rd] = make_float64(d0);
target-arm/neon_helper.c:    env->vfp.regs[rd + 1] = make_float64(d1);
target-arm/neon_helper.c:    uint64_t zm0 = float64_val(env->vfp.regs[rm]);
target-arm/neon_helper.c:    uint64_t zm1 = float64_val(env->vfp.regs[rm + 1]);
target-arm/neon_helper.c:    uint64_t zd0 = float64_val(env->vfp.regs[rd]);
target-arm/neon_helper.c:    uint64_t zd1 = float64_val(env->vfp.regs[rd + 1]);
target-arm/neon_helper.c:    env->vfp.regs[rm] = make_float64(m0);
target-arm/neon_helper.c:    env->vfp.regs[rm + 1] = make_float64(m1);
target-arm/neon_helper.c:    env->vfp.regs[rd] = make_float64(d0);
target-arm/neon_helper.c:    env->vfp.regs[rd + 1] = make_float64(d1);
target-arm/neon_helper.c:    uint64_t zm = float64_val(env->vfp.regs[rm]);
target-arm/neon_helper.c:    uint64_t zd = float64_val(env->vfp.regs[rd]);
target-arm/neon_helper.c:    env->vfp.regs[rm] = make_float64(m0);
target-arm/neon_helper.c:    env->vfp.regs[rd] = make_float64(d0);
target-arm/neon_helper.c:    uint64_t zm = float64_val(env->vfp.regs[rm]);
target-arm/neon_helper.c:    uint64_t zd = float64_val(env->vfp.regs[rd]);
target-arm/neon_helper.c:    env->vfp.regs[rm] = make_float64(m0);
target-arm/neon_helper.c:    env->vfp.regs[rd] = make_float64(d0);
target-arm/op_helper.c:    env->exception_index = tt;
target-arm/op_helper.c:    table = (uint64_t *)&env->vfp.regs[rn];
target-arm/op_helper.c:        raise_exception(env->exception_index);
target-arm/op_helper.c:        env->QF = 1;
target-arm/op_helper.c:        env->QF = 1;
target-arm/op_helper.c:        env->QF = 1;
target-arm/op_helper.c:        env->QF = 1;
target-arm/op_helper.c:        env->QF = 1;
target-arm/op_helper.c:        env->QF = 1;
target-arm/op_helper.c:        env->QF = 1;
target-arm/op_helper.c:        env->QF = 1;
target-arm/op_helper.c:        env->QF = 1;
target-arm/op_helper.c:        env->QF = 1;
target-arm/op_helper.c:        env->QF = 1;
target-arm/op_helper.c:    env->exception_index = EXCP_HLT;
target-arm/op_helper.c:    env->halted = 1;
target-arm/op_helper.c:    env->exception_index = excp;
target-arm/op_helper.c:        val = env->banked_r13[0];
target-arm/op_helper.c:        val = env->banked_r14[0];
target-arm/op_helper.c:               && (env->uncached_cpsr & 0x1f) == ARM_CPU_MODE_FIQ) {
target-arm/op_helper.c:        val = env->usr_regs[regno - 8];
target-arm/op_helper.c:        val = env->regs[regno];
target-arm/op_helper.c:        env->banked_r13[0] = val;
target-arm/op_helper.c:        env->banked_r14[0] = val;
target-arm/op_helper.c:               && (env->uncached_cpsr & 0x1f) == ARM_CPU_MODE_FIQ) {
target-arm/op_helper.c:        env->usr_regs[regno - 8] = val;
target-arm/op_helper.c:        env->regs[regno] = val;
target-arm/op_helper.c:    env->NF = env->ZF = result;
target-arm/op_helper.c:    env->CF = result < a;
target-arm/op_helper.c:    env->VF = (a ^ b ^ -1) & (a ^ result);
target-arm/op_helper.c:    if (!env->CF) {
target-arm/op_helper.c:        env->CF = result < a;
target-arm/op_helper.c:        env->CF = result <= a;
target-arm/op_helper.c:    env->VF = (a ^ b ^ -1) & (a ^ result);
target-arm/op_helper.c:    env->NF = env->ZF = result;
target-arm/op_helper.c:    env->NF = env->ZF = result;
target-arm/op_helper.c:    env->CF = a >= b;
target-arm/op_helper.c:    env->VF = (a ^ b) & (a ^ result);
target-arm/op_helper.c:    if (!env->CF) {
target-arm/op_helper.c:        env->CF = a > b;
target-arm/op_helper.c:        env->CF = a >= b;
target-arm/op_helper.c:    env->VF = (a ^ b) & (a ^ result);
target-arm/op_helper.c:    env->NF = env->ZF = result;
target-arm/op_helper.c:            env->CF = x & 1;
target-arm/op_helper.c:            env->CF = 0;
target-arm/op_helper.c:        env->CF = (x >> (32 - shift)) & 1;
target-arm/op_helper.c:            env->CF = (x >> 31) & 1;
target-arm/op_helper.c:            env->CF = 0;
target-arm/op_helper.c:        env->CF = (x >> (shift - 1)) & 1;
target-arm/op_helper.c:        env->CF = (x >> 31) & 1;
target-arm/op_helper.c:        env->CF = (x >> (shift - 1)) & 1;
target-arm/op_helper.c:            env->CF = (x >> 31) & 1;
target-arm/op_helper.c:        env->CF = (x >> (shift - 1)) & 1;
target-arm/iwmmxt_helper.c:    env->iwmmxt.cregs[ARM_IWMMXT_wCASF] =			\
target-arm/iwmmxt_helper.c:    env->iwmmxt.cregs[ARM_IWMMXT_wCASF] =			\
target-arm/iwmmxt_helper.c:    env->iwmmxt.cregs[ARM_IWMMXT_wCASF] =			\
target-arm/iwmmxt_helper.c:    env->iwmmxt.cregs[ARM_IWMMXT_wCASF] =			\
target-arm/iwmmxt_helper.c:    env->iwmmxt.cregs[ARM_IWMMXT_wCASF] =			\
target-arm/iwmmxt_helper.c:    env->iwmmxt.cregs[ARM_IWMMXT_wCASF] = NZBIT64(x >> 0);	\
target-arm/iwmmxt_helper.c:    env->iwmmxt.cregs[ARM_IWMMXT_wCASF] =			\
target-arm/iwmmxt_helper.c:    env->iwmmxt.cregs[ARM_IWMMXT_wCASF] =			\
target-arm/iwmmxt_helper.c:    env->iwmmxt.cregs[ARM_IWMMXT_wCASF] = NZBIT64(x >> 0);	\
target-arm/iwmmxt_helper.c:    env->iwmmxt.cregs[ARM_IWMMXT_wCASF] =			\
target-arm/iwmmxt_helper.c:    env->iwmmxt.cregs[ARM_IWMMXT_wCASF] =			\
target-arm/iwmmxt_helper.c:    env->iwmmxt.cregs[ARM_IWMMXT_wCASF] =			\
target-arm/iwmmxt_helper.c:    env->iwmmxt.cregs[ARM_IWMMXT_wCASF] =                                 \
target-arm/iwmmxt_helper.c:    env->iwmmxt.cregs[ARM_IWMMXT_wCASF] =                               \
target-arm/iwmmxt_helper.c:    env->iwmmxt.cregs[ARM_IWMMXT_wCASF] =
target-arm/iwmmxt_helper.c:    env->iwmmxt.cregs[ARM_IWMMXT_wCASF] =
target-arm/iwmmxt_helper.c:    env->iwmmxt.cregs[ARM_IWMMXT_wCASF] = NZBIT64(x);
target-arm/iwmmxt_helper.c:    env->iwmmxt.cregs[ARM_IWMMXT_wCASF] =
target-arm/iwmmxt_helper.c:    env->iwmmxt.cregs[ARM_IWMMXT_wCASF] =
target-arm/iwmmxt_helper.c:    env->iwmmxt.cregs[ARM_IWMMXT_wCASF] = NZBIT64(x);
target-arm/iwmmxt_helper.c:    env->iwmmxt.cregs[ARM_IWMMXT_wCASF] =
target-arm/iwmmxt_helper.c:    env->iwmmxt.cregs[ARM_IWMMXT_wCASF] =
target-arm/iwmmxt_helper.c:    env->iwmmxt.cregs[ARM_IWMMXT_wCASF] = NZBIT64(x);
target-arm/iwmmxt_helper.c:    env->iwmmxt.cregs[ARM_IWMMXT_wCASF] =
target-arm/iwmmxt_helper.c:    env->iwmmxt.cregs[ARM_IWMMXT_wCASF] =
target-arm/iwmmxt_helper.c:    env->iwmmxt.cregs[ARM_IWMMXT_wCASF] = NZBIT64(x);
target-arm/iwmmxt_helper.c:    env->iwmmxt.cregs[ARM_IWMMXT_wCASF] =
target-arm/iwmmxt_helper.c:    env->iwmmxt.cregs[ARM_IWMMXT_wCASF] =
target-arm/iwmmxt_helper.c:    env->iwmmxt.cregs[ARM_IWMMXT_wCASF] =
target-arm/iwmmxt_helper.c:    env->iwmmxt.cregs[ARM_IWMMXT_wCASF] =
target-arm/iwmmxt_helper.c:    env->iwmmxt.cregs[ARM_IWMMXT_wCASF] =
target-arm/iwmmxt_helper.c:    env->iwmmxt.cregs[ARM_IWMMXT_wCASF] =
target-arm/iwmmxt_helper.c:    env->iwmmxt.cregs[ARM_IWMMXT_wCASF] =
target-arm/cpu.h:  env->cp15.c13_tls2 = newtls;
target-arm/cpu.h:    ZF = (env->ZF == 0);
target-arm/cpu.h:    return (env->NF & 0x80000000) | (ZF << 30)
target-arm/cpu.h:        | (env->CF << 29) | ((env->VF & 0x80000000) >> 3) | (env->QF << 27)
target-arm/cpu.h:        | (env->thumb << 24) | ((env->condexec_bits & 3) << 25)
target-arm/cpu.h:        | ((env->condexec_bits & 0xfc) << 8)
target-arm/cpu.h:        | env->v7m.exception;
target-arm/cpu.h:        env->ZF = (~val) & CPSR_Z;
target-arm/cpu.h:        env->NF = val;
target-arm/cpu.h:        env->CF = (val >> 29) & 1;
target-arm/cpu.h:        env->VF = (val << 3) & 0x80000000;
target-arm/cpu.h:        env->QF = ((val & CPSR_Q) != 0);
target-arm/cpu.h:        env->thumb = ((val & (1 << 24)) != 0);
target-arm/cpu.h:        env->condexec_bits &= ~3;
target-arm/cpu.h:        env->condexec_bits |= (val >> 25) & 3;
target-arm/cpu.h:        env->condexec_bits &= 3;
target-arm/cpu.h:        env->condexec_bits |= (val >> 8) & 0xfc;
target-arm/cpu.h:        env->v7m.exception = val & 0x1ff;
target-arm/cpu.h:    return (env->features & (1u << feature)) != 0;
target-arm/cpu.h:#define ARM_CPUID(env) (env->cp15.c0_cpuid)
target-arm/cpu.h:    return (env->uncached_cpsr & CPSR_M) == ARM_CPU_MODE_USR ? 1 : 0;
target-arm/cpu.h:        env->regs[13] = newsp;
target-arm/cpu.h:    env->regs[0] = 0;
target-arm/cpu.h:    *pc = env->regs[15];
target-arm/cpu.h:    *flags = (env->thumb << ARM_TBFLAG_THUMB_SHIFT)
target-arm/cpu.h:        | (env->vfp.vec_len << ARM_TBFLAG_VECLEN_SHIFT)
target-arm/cpu.h:        | (env->vfp.vec_stride << ARM_TBFLAG_VECSTRIDE_SHIFT)
target-arm/cpu.h:        | (env->condexec_bits << ARM_TBFLAG_CONDEXEC_SHIFT)
target-arm/cpu.h:        | (env->bswap_code << ARM_TBFLAG_BSWAP_CODE_SHIFT);
target-arm/cpu.h:        privmode = !((env->v7m.exception == 0) && (env->v7m.control & 1));
target-arm/cpu.h:        privmode = (env->uncached_cpsr & CPSR_M) != ARM_CPU_MODE_USR;
target-arm/cpu.h:    if (env->vfp.xregs[ARM_VFP_FPEXC] & (1 << 30)) {
target-arm/cpu.h:    return env->interrupt_request &
target-arm/cpu.h:    env->regs[15] = tb->pc;
target-arm/helper.c:        stfq_le_p(buf, env->vfp.regs[reg]);
target-arm/helper.c:            stfq_le_p(buf, env->vfp.regs[(reg - 32) * 2]);
target-arm/helper.c:            stfq_le_p(buf + 8, env->vfp.regs[(reg - 32) * 2 + 1]);
target-arm/helper.c:    case 0: stl_p(buf, env->vfp.xregs[ARM_VFP_FPSID]); return 4;
target-arm/helper.c:    case 1: stl_p(buf, env->vfp.xregs[ARM_VFP_FPSCR]); return 4;
target-arm/helper.c:    case 2: stl_p(buf, env->vfp.xregs[ARM_VFP_FPEXC]); return 4;
target-arm/helper.c:        env->vfp.regs[reg] = ldfq_le_p(buf);
target-arm/helper.c:            env->vfp.regs[(reg - 32) * 2] = ldfq_le_p(buf);
target-arm/helper.c:            env->vfp.regs[(reg - 32) * 2 + 1] = ldfq_le_p(buf + 8);
target-arm/helper.c:    case 0: env->vfp.xregs[ARM_VFP_FPSID] = ldl_p(buf); return 4;
target-arm/helper.c:    case 1: env->vfp.xregs[ARM_VFP_FPSCR] = ldl_p(buf); return 4;
target-arm/helper.c:    case 2: env->vfp.xregs[ARM_VFP_FPEXC] = ldl_p(buf) & (1 << 30); return 4;
target-arm/helper.c:    env->cpu_model_str = cpu_model;
target-arm/helper.c:    ZF = (env->ZF == 0);
target-arm/helper.c:    return env->uncached_cpsr | (env->NF & 0x80000000) | (ZF << 30) |
target-arm/helper.c:        (env->CF << 29) | ((env->VF & 0x80000000) >> 3) | (env->QF << 27)
target-arm/helper.c:        | (env->thumb << 5) | ((env->condexec_bits & 3) << 25)
target-arm/helper.c:        | ((env->condexec_bits & 0xfc) << 8)
target-arm/helper.c:        | (env->GE << 16);
target-arm/helper.c:        env->ZF = (~val) & CPSR_Z;
target-arm/helper.c:        env->NF = val;
target-arm/helper.c:        env->CF = (val >> 29) & 1;
target-arm/helper.c:        env->VF = (val << 3) & 0x80000000;
target-arm/helper.c:        env->QF = ((val & CPSR_Q) != 0);
target-arm/helper.c:        env->thumb = ((val & CPSR_T) != 0);
target-arm/helper.c:        env->condexec_bits &= ~3;
target-arm/helper.c:        env->condexec_bits |= (val >> 25) & 3;
target-arm/helper.c:        env->condexec_bits &= 3;
target-arm/helper.c:        env->condexec_bits |= (val >> 8) & 0xfc;
target-arm/helper.c:        env->GE = (val >> 16) & 0xf;
target-arm/helper.c:    if ((env->uncached_cpsr ^ val) & mask & CPSR_M) {
target-arm/helper.c:    env->uncached_cpsr = (env->uncached_cpsr & ~mask) | (val & mask);
target-arm/helper.c:    env->exception_index = -1;
target-arm/helper.c:        env->exception_index = EXCP_PREFETCH_ABORT;
target-arm/helper.c:        env->cp15.c6_insn = address;
target-arm/helper.c:        env->exception_index = EXCP_DATA_ABORT;
target-arm/helper.c:        env->cp15.c6_data = address;
target-arm/helper.c:    old_mode = env->uncached_cpsr & CPSR_M;
target-arm/helper.c:        memcpy (env->fiq_regs, env->regs + 8, 5 * sizeof(uint32_t));
target-arm/helper.c:        memcpy (env->regs + 8, env->usr_regs, 5 * sizeof(uint32_t));
target-arm/helper.c:        memcpy (env->usr_regs, env->regs + 8, 5 * sizeof(uint32_t));
target-arm/helper.c:        memcpy (env->regs + 8, env->fiq_regs, 5 * sizeof(uint32_t));
target-arm/helper.c:    env->banked_r13[i] = env->regs[13];
target-arm/helper.c:    env->banked_r14[i] = env->regs[14];
target-arm/helper.c:    env->banked_spsr[i] = env->spsr;
target-arm/helper.c:    env->regs[13] = env->banked_r13[i];
target-arm/helper.c:    env->regs[14] = env->banked_r14[i];
target-arm/helper.c:    env->spsr = env->banked_spsr[i];
target-arm/helper.c:    env->regs[13] -= 4;
target-arm/helper.c:    stl_phys(env->regs[13], val);
target-arm/helper.c:    val = ldl_phys(env->regs[13]);
target-arm/helper.c:    env->regs[13] += 4;
target-arm/helper.c:    if (env->v7m.current_sp != process) {
target-arm/helper.c:        tmp = env->v7m.other_sp;
target-arm/helper.c:        env->v7m.other_sp = env->regs[13];
target-arm/helper.c:        env->regs[13] = tmp;
target-arm/helper.c:        env->v7m.current_sp = process;
target-arm/helper.c:    type = env->regs[15];
target-arm/helper.c:    if (env->v7m.exception != 0)
target-arm/helper.c:        armv7m_nvic_complete_irq(env->nvic, env->v7m.exception);
target-arm/helper.c:    env->regs[0] = v7m_pop(env);
target-arm/helper.c:    env->regs[1] = v7m_pop(env);
target-arm/helper.c:    env->regs[2] = v7m_pop(env);
target-arm/helper.c:    env->regs[3] = v7m_pop(env);
target-arm/helper.c:    env->regs[12] = v7m_pop(env);
target-arm/helper.c:    env->regs[14] = v7m_pop(env);
target-arm/helper.c:    env->regs[15] = v7m_pop(env);
target-arm/helper.c:        env->regs[13] |= 4;
target-arm/helper.c:    if (env->v7m.current_sp)
target-arm/helper.c:    if (env->v7m.exception == 0)
target-arm/helper.c:    switch (env->exception_index) {
target-arm/helper.c:        armv7m_nvic_set_pending(env->nvic, ARMV7M_EXCP_USAGE);
target-arm/helper.c:        env->regs[15] += 2;
target-arm/helper.c:        armv7m_nvic_set_pending(env->nvic, ARMV7M_EXCP_SVC);
target-arm/helper.c:        armv7m_nvic_set_pending(env->nvic, ARMV7M_EXCP_MEM);
target-arm/helper.c:            nr = arm_lduw_code(env->regs[15], env->bswap_code) & 0xff;
target-arm/helper.c:                env->regs[15] += 2;
target-arm/helper.c:                env->regs[0] = do_arm_semihosting(env);
target-arm/helper.c:        armv7m_nvic_set_pending(env->nvic, ARMV7M_EXCP_DEBUG);
target-arm/helper.c:        env->v7m.exception = armv7m_nvic_acknowledge_irq(env->nvic);
target-arm/helper.c:        cpu_abort(env, "Unhandled exception 0x%x\n", env->exception_index);
target-arm/helper.c:    if (env->regs[13] & 4) {
target-arm/helper.c:        env->regs[13] -= 4;
target-arm/helper.c:    v7m_push(env, env->regs[15]);
target-arm/helper.c:    v7m_push(env, env->regs[14]);
target-arm/helper.c:    v7m_push(env, env->regs[12]);
target-arm/helper.c:    v7m_push(env, env->regs[3]);
target-arm/helper.c:    v7m_push(env, env->regs[2]);
target-arm/helper.c:    v7m_push(env, env->regs[1]);
target-arm/helper.c:    v7m_push(env, env->regs[0]);
target-arm/helper.c:    env->condexec_bits = 0;
target-arm/helper.c:    env->regs[14] = lr;
target-arm/helper.c:    addr = ldl_phys(env->v7m.vecbase + env->v7m.exception * 4);
target-arm/helper.c:    env->regs[15] = addr & 0xfffffffe;
target-arm/helper.c:    env->thumb = addr & 1;
target-arm/helper.c:    switch (env->exception_index) {
target-arm/helper.c:        if (env->thumb)
target-arm/helper.c:            if (env->thumb) {
target-arm/helper.c:                mask = arm_lduw_code(env->regs[15] - 2, env->bswap_code) & 0xff;
target-arm/helper.c:                mask = arm_ldl_code(env->regs[15] - 4, env->bswap_code)
target-arm/helper.c:            if (((mask == 0x123456 && !env->thumb)
target-arm/helper.c:                    || (mask == 0xab && env->thumb))
target-arm/helper.c:                  && (env->uncached_cpsr & CPSR_M) != ARM_CPU_MODE_USR) {
target-arm/helper.c:                env->regs[0] = do_arm_semihosting(env);
target-arm/helper.c:        if (env->thumb && semihosting_enabled) {
target-arm/helper.c:            mask = arm_lduw_code(env->regs[15], env->bswap_code) & 0xff;
target-arm/helper.c:                  && (env->uncached_cpsr & CPSR_M) != ARM_CPU_MODE_USR) {
target-arm/helper.c:                env->regs[15] += 2;
target-arm/helper.c:                env->regs[0] = do_arm_semihosting(env);
target-arm/helper.c:        env->cp15.c5_insn = 2;
target-arm/helper.c:        cpu_abort(env, "Unhandled exception 0x%x\n", env->exception_index);
target-arm/helper.c:    if (env->cp15.c1_sys & (1 << 13)) {
target-arm/helper.c:    env->spsr = cpsr_read(env);
target-arm/helper.c:    env->condexec_bits = 0;
target-arm/helper.c:    env->uncached_cpsr = (env->uncached_cpsr & ~CPSR_M) | new_mode;
target-arm/helper.c:    env->uncached_cpsr |= mask;
target-arm/helper.c:        env->thumb = (env->cp15.c1_sys & (1 << 30)) != 0;
target-arm/helper.c:    env->regs[14] = env->regs[15] + offset;
target-arm/helper.c:    env->regs[15] = addr;
target-arm/helper.c:    env->interrupt_request |= CPU_INTERRUPT_EXITTB;
target-arm/helper.c:      switch ((env->cp15.c1_sys >> 8) & 3) {
target-arm/helper.c:    if (address & env->cp15.c2_mask)
target-arm/helper.c:        table = env->cp15.c2_base1 & 0xffffc000;
target-arm/helper.c:        table = env->cp15.c2_base0 & env->cp15.c2_base_mask;
target-arm/helper.c:    domain_prot = (env->cp15.c3 >> (domain * 2)) & 3;
target-arm/helper.c:    domain_prot = (env->cp15.c3 >> (domain * 2)) & 3;
target-arm/helper.c:        if ((env->cp15.c1_sys & (1 << 29)) && (ap & 1) == 0) {
target-arm/helper.c:	base = env->cp15.c6_region[n];
target-arm/helper.c:	mask = env->cp15.c5_insn;
target-arm/helper.c:	mask = env->cp15.c5_data;
target-arm/helper.c:        address += env->cp15.c13_fcse;
target-arm/helper.c:    if ((env->cp15.c1_sys & 1) == 0) {
target-arm/helper.c:    } else if (env->cp15.c1_sys & (1 << 23)) {
target-arm/helper.c:        env->cp15.c5_insn = ret;
target-arm/helper.c:        env->cp15.c6_insn = address;
target-arm/helper.c:        env->exception_index = EXCP_PREFETCH_ABORT;
target-arm/helper.c:        env->cp15.c5_data = ret;
target-arm/helper.c:            env->cp15.c5_data |= (1 << 11);
target-arm/helper.c:        env->cp15.c6_data = address;
target-arm/helper.c:        env->exception_index = EXCP_DATA_ABORT;
target-arm/helper.c:    if (env->cp[cp_num].cp_write)
target-arm/helper.c:        env->cp[cp_num].cp_write(env->cp[cp_num].opaque,
target-arm/helper.c:    if (env->cp[cp_num].cp_read)
target-arm/helper.c:        return env->cp[cp_num].cp_read(env->cp[cp_num].opaque,
target-arm/helper.c:            env->cp15.c0_cssel = val & 0xf;
target-arm/helper.c:            env->cp15.c1_scr = val;
target-arm/helper.c:                env->cp15.c1_sys = val;
target-arm/helper.c:                env->cp15.c1_xscaleauxcr = val;
target-arm/helper.c:            if (env->cp15.c1_coproc != val) {
target-arm/helper.c:                env->cp15.c1_coproc = val;
target-arm/helper.c:                env->cp15.c2_data = val;
target-arm/helper.c:                env->cp15.c2_insn = val;
target-arm/helper.c:		env->cp15.c2_base0 = val;
target-arm/helper.c:		env->cp15.c2_base1 = val;
target-arm/helper.c:                env->cp15.c2_control = val;
target-arm/helper.c:		env->cp15.c2_mask = ~(((uint32_t)0xffffffffu) >> val);
target-arm/helper.c:                env->cp15.c2_base_mask = ~((uint32_t)0x3fffu >> val);
target-arm/helper.c:        env->cp15.c3 = val;
target-arm/helper.c:            env->cp15.c5_data = val;
target-arm/helper.c:            env->cp15.c5_insn = val;
target-arm/helper.c:            env->cp15.c5_data = val;
target-arm/helper.c:            env->cp15.c5_insn = val;
target-arm/helper.c:            env->cp15.c6_region[crm] = val;
target-arm/helper.c:                env->cp15.c6_data = val;
target-arm/helper.c:                env->cp15.c6_insn = val;
target-arm/helper.c:        env->cp15.c15_i_max = 0x000;
target-arm/helper.c:        env->cp15.c15_i_min = 0xff0;
target-arm/helper.c:                    env->cp15.c7_par = val & 0xfffff6ff;
target-arm/helper.c:                    env->cp15.c7_par = val & 0xfffff1ff;
target-arm/helper.c:                        env->cp15.c7_par = (phys_addr & 0xff000000) | 1 << 1;
target-arm/helper.c:                        env->cp15.c7_par = phys_addr & 0xfffff000;
target-arm/helper.c:                    env->cp15.c7_par = ((ret & (10 << 1)) >> 5) |
target-arm/helper.c:		    env->cp15.c9_data = val;
target-arm/helper.c:		    env->cp15.c9_insn = val;
target-arm/helper.c:                env->cp15.c9_pmcr &= ~0x39;
target-arm/helper.c:                env->cp15.c9_pmcr |= (val & 0x39);
target-arm/helper.c:                env->cp15.c9_pmcnten |= val;
target-arm/helper.c:                env->cp15.c9_pmcnten &= ~val;
target-arm/helper.c:                env->cp15.c9_pmovsr &= ~val;
target-arm/helper.c:                env->cp15.c9_pmxevtyper = val & 0xff;
target-arm/helper.c:                env->cp15.c9_pmuserenr = val & 1;
target-arm/helper.c:                env->cp15.c9_pminten |= val;
target-arm/helper.c:                env->cp15.c9_pminten &= ~val;
target-arm/helper.c:            if (env->cp15.c13_fcse != val)
target-arm/helper.c:            env->cp15.c13_fcse = val;
target-arm/helper.c:            if (env->cp15.c13_context != val
target-arm/helper.c:            env->cp15.c13_context = val;
target-arm/helper.c:                if (env->cp15.c15_cpar != (val & 0x3fff)) {
target-arm/helper.c:                    env->cp15.c15_cpar = val & 0x3fff;
target-arm/helper.c:                env->cp15.c15_ticonfig = val & 0xe7;
target-arm/helper.c:                env->cp15.c0_cpuid = (val & (1 << 5)) ? /* OS_TYPE bit */
target-arm/helper.c:                env->cp15.c15_i_max = val;
target-arm/helper.c:                env->cp15.c15_i_min = val;
target-arm/helper.c:                env->cp15.c15_threadid = val & 0xffff;
target-arm/helper.c:                    env->cp15.c15_power_control = val;
target-arm/helper.c:                    env->cp15.c15_diagnostic = val;
target-arm/helper.c:                    env->cp15.c15_power_diagnostic = val;
target-arm/helper.c:                    return env->cp15.c0_cpuid;
target-arm/helper.c:		    return env->cp15.c0_cachetype;
target-arm/helper.c:                        int mpidr = env->cpu_index;
target-arm/helper.c:                return env->cp15.c0_c1[op2];
target-arm/helper.c:                return env->cp15.c0_c2[op2];
target-arm/helper.c:                return env->cp15.c0_ccsid[env->cp15.c0_cssel];
target-arm/helper.c:                return env->cp15.c0_clid;
target-arm/helper.c:            return env->cp15.c0_cssel;
target-arm/helper.c:            return env->cp15.c1_scr;
target-arm/helper.c:            return env->cp15.c1_sys;
target-arm/helper.c:                return env->cp15.c1_xscaleauxcr;
target-arm/helper.c:            return env->cp15.c1_coproc;
target-arm/helper.c:                return env->cp15.c2_data;
target-arm/helper.c:                return env->cp15.c2_insn;
target-arm/helper.c:		return env->cp15.c2_base0;
target-arm/helper.c:		return env->cp15.c2_base1;
target-arm/helper.c:                return env->cp15.c2_control;
target-arm/helper.c:        return env->cp15.c3;
target-arm/helper.c:                return simple_mpu_ap_bits(env->cp15.c5_data);
target-arm/helper.c:            return env->cp15.c5_data;
target-arm/helper.c:                return simple_mpu_ap_bits(env->cp15.c5_insn);
target-arm/helper.c:            return env->cp15.c5_insn;
target-arm/helper.c:            return env->cp15.c5_data;
target-arm/helper.c:            return env->cp15.c5_insn;
target-arm/helper.c:            return env->cp15.c6_region[crm];
target-arm/helper.c:		return env->cp15.c6_data;
target-arm/helper.c:		    return env->cp15.c6_insn;
target-arm/helper.c:		    return env->cp15.c6_insn;
target-arm/helper.c:            return env->cp15.c7_par;
target-arm/helper.c:        env->ZF = 0;
target-arm/helper.c:                    return env->cp15.c9_data;
target-arm/helper.c:                    return env->cp15.c9_insn;
target-arm/helper.c:                return env->cp15.c9_pmcr;
target-arm/helper.c:                return env->cp15.c9_pmcnten;
target-arm/helper.c:                return env->cp15.c9_pmovsr;
target-arm/helper.c:                return env->cp15.c9_pmxevtyper;
target-arm/helper.c:                return env->cp15.c9_pmuserenr;
target-arm/helper.c:                return env->cp15.c9_pminten;
target-arm/helper.c:            return env->cp15.c13_fcse;
target-arm/helper.c:            return env->cp15.c13_context;
target-arm/helper.c:                return env->cp15.c15_cpar;
target-arm/helper.c:                return env->cp15.c15_ticonfig;
target-arm/helper.c:                return env->cp15.c15_i_max;
target-arm/helper.c:                return env->cp15.c15_i_min;
target-arm/helper.c:                return env->cp15.c15_threadid;
target-arm/helper.c:                    return env->cp15.c15_config_base_address;
target-arm/helper.c:                    return env->cp15.c15_power_control;
target-arm/helper.c:                    return env->cp15.c15_diagnostic;
target-arm/helper.c:                    return env->cp15.c15_power_diagnostic;
target-arm/helper.c:    if ((env->uncached_cpsr & CPSR_M) == mode) {
target-arm/helper.c:        env->regs[13] = val;
target-arm/helper.c:        env->banked_r13[bank_number(env, mode)] = val;
target-arm/helper.c:    if ((env->uncached_cpsr & CPSR_M) == mode) {
target-arm/helper.c:        return env->regs[13];
target-arm/helper.c:        return env->banked_r13[bank_number(env, mode)];
target-arm/helper.c:        return env->v7m.current_sp ? env->v7m.other_sp : env->regs[13];
target-arm/helper.c:        return env->v7m.current_sp ? env->regs[13] : env->v7m.other_sp;
target-arm/helper.c:        return (env->uncached_cpsr & CPSR_I) != 0;
target-arm/helper.c:        return env->v7m.basepri;
target-arm/helper.c:        return (env->uncached_cpsr & CPSR_F) != 0;
target-arm/helper.c:        return env->v7m.control;
target-arm/helper.c:        if (env->v7m.current_sp)
target-arm/helper.c:            env->v7m.other_sp = val;
target-arm/helper.c:            env->regs[13] = val;
target-arm/helper.c:        if (env->v7m.current_sp)
target-arm/helper.c:            env->regs[13] = val;
target-arm/helper.c:            env->v7m.other_sp = val;
target-arm/helper.c:            env->uncached_cpsr |= CPSR_I;
target-arm/helper.c:            env->uncached_cpsr &= ~CPSR_I;
target-arm/helper.c:        env->v7m.basepri = val & 0xff;
target-arm/helper.c:        if (val != 0 && (val < env->v7m.basepri || env->v7m.basepri == 0))
target-arm/helper.c:            env->v7m.basepri = val;
target-arm/helper.c:            env->uncached_cpsr |= CPSR_F;
target-arm/helper.c:            env->uncached_cpsr &= ~CPSR_F;
target-arm/helper.c:        env->v7m.control = val & 3;
target-arm/helper.c:    env->cp[cpnum].cp_read = cp_read;
target-arm/helper.c:    env->cp[cpnum].cp_write = cp_write;
target-arm/helper.c:    env->cp[cpnum].opaque = opaque;
target-arm/helper.c:    fpscr = (env->vfp.xregs[ARM_VFP_FPSCR] & 0xffc8ffff)
target-arm/helper.c:            | (env->vfp.vec_len << 16)
target-arm/helper.c:            | (env->vfp.vec_stride << 20);
target-arm/helper.c:    i = get_float_exception_flags(&env->vfp.fp_status);
target-arm/helper.c:    i |= get_float_exception_flags(&env->vfp.standard_fp_status);
target-arm/helper.c:    changed = env->vfp.xregs[ARM_VFP_FPSCR];
target-arm/helper.c:    env->vfp.xregs[ARM_VFP_FPSCR] = (val & 0xffc8ffff);
target-arm/helper.c:    env->vfp.vec_len = (val >> 16) & 7;
target-arm/helper.c:    env->vfp.vec_stride = (val >> 20) & 3;
target-arm/helper.c:        set_float_rounding_mode(i, &env->vfp.fp_status);
target-arm/helper.c:        set_flush_to_zero((val & (1 << 24)) != 0, &env->vfp.fp_status);
target-arm/helper.c:        set_flush_inputs_to_zero((val & (1 << 24)) != 0, &env->vfp.fp_status);
target-arm/helper.c:        set_default_nan_mode((val & (1 << 25)) != 0, &env->vfp.fp_status);
target-arm/helper.c:    set_float_exception_flags(i, &env->vfp.fp_status);
target-arm/helper.c:    set_float_exception_flags(0, &env->vfp.standard_fp_status);
target-arm/helper.c:    return float32_sqrt(a, &env->vfp.fp_status);
target-arm/helper.c:    return float64_sqrt(a, &env->vfp.fp_status);
target-arm/helper.c:    switch(type ## _compare_quiet(a, b, &env->vfp.fp_status)) { \
target-arm/helper.c:    env->vfp.xregs[ARM_VFP_FPSCR] = (flags << 28) \
target-arm/helper.c:        | (env->vfp.xregs[ARM_VFP_FPSCR] & 0x0fffffff); \
target-arm/helper.c:    switch(type ## _compare(a, b, &env->vfp.fp_status)) { \
target-arm/helper.c:    env->vfp.xregs[ARM_VFP_FPSCR] = (flags << 28) \
target-arm/helper.c:        | (env->vfp.xregs[ARM_VFP_FPSCR] & 0x0fffffff); \
target-arm/helper.c:    float64 r = float32_to_float64(x, &env->vfp.fp_status);
target-arm/helper.c:    float32 r =  float64_to_float32(x, &env->vfp.fp_status);
target-arm/helper.c:    int ieee = (env->vfp.xregs[ARM_VFP_FPSCR] & (1 << 26)) == 0;
target-arm/helper.c:    int ieee = (env->vfp.xregs[ARM_VFP_FPSCR] & (1 << 26)) == 0;
target-arm/helper.c:    return do_fcvt_f16_to_f32(a, env, &env->vfp.standard_fp_status);
target-arm/helper.c:    return do_fcvt_f32_to_f16(a, env, &env->vfp.standard_fp_status);
target-arm/helper.c:    return do_fcvt_f16_to_f32(a, env, &env->vfp.fp_status);
target-arm/helper.c:    return do_fcvt_f32_to_f16(a, env, &env->vfp.fp_status);
target-arm/helper.c:    float_status *s = &env->vfp.standard_fp_status;
target-arm/helper.c:    float_status *s = &env->vfp.standard_fp_status;
target-arm/helper.c:    float_status dummy_status = env->vfp.standard_fp_status;
target-arm/helper.c:    float_status *s = &env->vfp.standard_fp_status;
target-arm/helper.c:    float_status dummy_status = env->vfp.standard_fp_status;
target-arm/helper.c:    float_status *s = &env->vfp.standard_fp_status;
target-arm/helper.c:    if (env->teecr != val) {
target-arm/helper.c:        env->teecr = val;
target-arm/cpu.c:        qemu_log("CPU Reset (CPU %d)\n", env->cpu_index);
target-arm/cpu.c:    env->cp15.c15_config_base_address = cpu->reset_cbar;
target-arm/cpu.c:    env->cp15.c0_cpuid = cpu->midr;
target-arm/cpu.c:    env->vfp.xregs[ARM_VFP_FPSID] = cpu->reset_fpsid;
target-arm/cpu.c:    env->vfp.xregs[ARM_VFP_MVFR0] = cpu->mvfr0;
target-arm/cpu.c:    env->vfp.xregs[ARM_VFP_MVFR1] = cpu->mvfr1;
target-arm/cpu.c:    env->cp15.c0_cachetype = cpu->ctr;
target-arm/cpu.c:    env->cp15.c1_sys = cpu->reset_sctlr;
target-arm/cpu.c:    env->cp15.c0_c1[0] = cpu->id_pfr0;
target-arm/cpu.c:    env->cp15.c0_c1[1] = cpu->id_pfr1;
target-arm/cpu.c:    env->cp15.c0_c1[2] = cpu->id_dfr0;
target-arm/cpu.c:    env->cp15.c0_c1[3] = cpu->id_afr0;
target-arm/cpu.c:    env->cp15.c0_c1[4] = cpu->id_mmfr0;
target-arm/cpu.c:    env->cp15.c0_c1[5] = cpu->id_mmfr1;
target-arm/cpu.c:    env->cp15.c0_c1[6] = cpu->id_mmfr2;
target-arm/cpu.c:    env->cp15.c0_c1[7] = cpu->id_mmfr3;
target-arm/cpu.c:    env->cp15.c0_c2[0] = cpu->id_isar0;
target-arm/cpu.c:    env->cp15.c0_c2[1] = cpu->id_isar1;
target-arm/cpu.c:    env->cp15.c0_c2[2] = cpu->id_isar2;
target-arm/cpu.c:    env->cp15.c0_c2[3] = cpu->id_isar3;
target-arm/cpu.c:    env->cp15.c0_c2[4] = cpu->id_isar4;
target-arm/cpu.c:    env->cp15.c0_c2[5] = cpu->id_isar5;
target-arm/cpu.c:    env->cp15.c15_i_min = 0xff0;
target-arm/cpu.c:    env->cp15.c0_clid = cpu->clidr;
target-arm/cpu.c:    memcpy(env->cp15.c0_ccsid, cpu->ccsidr, ARRAY_SIZE(cpu->ccsidr));
target-arm/cpu.c:        env->iwmmxt.cregs[ARM_IWMMXT_wCID] = 0x69051000 | 'Q';
target-arm/cpu.c:    env->uncached_cpsr = ARM_CPU_MODE_USR;
target-arm/cpu.c:    env->vfp.xregs[ARM_VFP_FPEXC] = 1 << 30;
target-arm/cpu.c:        env->cp15.c15_cpar = 3;
target-arm/cpu.c:        env->cp15.c15_cpar = 1;
target-arm/cpu.c:    env->uncached_cpsr = ARM_CPU_MODE_SVC | CPSR_A | CPSR_F | CPSR_I;
target-arm/cpu.c:        env->uncached_cpsr &= ~CPSR_I;
target-arm/cpu.c:            env->regs[13] = ldl_p(rom);
target-arm/cpu.c:            env->thumb = pc & 1;
target-arm/cpu.c:            env->regs[15] = pc & ~1;
target-arm/cpu.c:    env->vfp.xregs[ARM_VFP_FPEXC] = 0;
target-arm/cpu.c:    env->cp15.c2_base_mask = 0xffffc000u;
target-arm/cpu.c:    env->cp15.c9_pmcr = (cpu->midr & 0xff000000);
target-arm/cpu.c:    set_flush_to_zero(1, &env->vfp.standard_fp_status);
target-arm/cpu.c:    set_flush_inputs_to_zero(1, &env->vfp.standard_fp_status);
target-arm/cpu.c:    set_default_nan_mode(1, &env->vfp.standard_fp_status);
target-arm/cpu.c:                              &env->vfp.fp_status);
target-arm/cpu.c:                              &env->vfp.standard_fp_status);
target-arm/cpu.c:    env->features |= 1u << feature;
target-arm/machine.c:        qemu_put_be32(f, env->regs[i]);
target-arm/machine.c:    qemu_put_be32(f, env->spsr);
target-arm/machine.c:        qemu_put_be32(f, env->banked_spsr[i]);
target-arm/machine.c:        qemu_put_be32(f, env->banked_r13[i]);
target-arm/machine.c:        qemu_put_be32(f, env->banked_r14[i]);
target-arm/machine.c:        qemu_put_be32(f, env->usr_regs[i]);
target-arm/machine.c:        qemu_put_be32(f, env->fiq_regs[i]);
target-arm/machine.c:    qemu_put_be32(f, env->cp15.c0_cpuid);
target-arm/machine.c:    qemu_put_be32(f, env->cp15.c0_cachetype);
target-arm/machine.c:    qemu_put_be32(f, env->cp15.c0_cssel);
target-arm/machine.c:    qemu_put_be32(f, env->cp15.c1_sys);
target-arm/machine.c:    qemu_put_be32(f, env->cp15.c1_coproc);
target-arm/machine.c:    qemu_put_be32(f, env->cp15.c1_xscaleauxcr);
target-arm/machine.c:    qemu_put_be32(f, env->cp15.c1_scr);
target-arm/machine.c:    qemu_put_be32(f, env->cp15.c2_base0);
target-arm/machine.c:    qemu_put_be32(f, env->cp15.c2_base1);
target-arm/machine.c:    qemu_put_be32(f, env->cp15.c2_control);
target-arm/machine.c:    qemu_put_be32(f, env->cp15.c2_mask);
target-arm/machine.c:    qemu_put_be32(f, env->cp15.c2_base_mask);
target-arm/machine.c:    qemu_put_be32(f, env->cp15.c2_data);
target-arm/machine.c:    qemu_put_be32(f, env->cp15.c2_insn);
target-arm/machine.c:    qemu_put_be32(f, env->cp15.c3);
target-arm/machine.c:    qemu_put_be32(f, env->cp15.c5_insn);
target-arm/machine.c:    qemu_put_be32(f, env->cp15.c5_data);
target-arm/machine.c:        qemu_put_be32(f, env->cp15.c6_region[i]);
target-arm/machine.c:    qemu_put_be32(f, env->cp15.c6_insn);
target-arm/machine.c:    qemu_put_be32(f, env->cp15.c6_data);
target-arm/machine.c:    qemu_put_be32(f, env->cp15.c7_par);
target-arm/machine.c:    qemu_put_be32(f, env->cp15.c9_insn);
target-arm/machine.c:    qemu_put_be32(f, env->cp15.c9_data);
target-arm/machine.c:    qemu_put_be32(f, env->cp15.c9_pmcr);
target-arm/machine.c:    qemu_put_be32(f, env->cp15.c9_pmcnten);
target-arm/machine.c:    qemu_put_be32(f, env->cp15.c9_pmovsr);
target-arm/machine.c:    qemu_put_be32(f, env->cp15.c9_pmxevtyper);
target-arm/machine.c:    qemu_put_be32(f, env->cp15.c9_pmuserenr);
target-arm/machine.c:    qemu_put_be32(f, env->cp15.c9_pminten);
target-arm/machine.c:    qemu_put_be32(f, env->cp15.c13_fcse);
target-arm/machine.c:    qemu_put_be32(f, env->cp15.c13_context);
target-arm/machine.c:    qemu_put_be32(f, env->cp15.c13_tls1);
target-arm/machine.c:    qemu_put_be32(f, env->cp15.c13_tls2);
target-arm/machine.c:    qemu_put_be32(f, env->cp15.c13_tls3);
target-arm/machine.c:    qemu_put_be32(f, env->cp15.c15_cpar);
target-arm/machine.c:    qemu_put_be32(f, env->cp15.c15_power_control);
target-arm/machine.c:    qemu_put_be32(f, env->cp15.c15_diagnostic);
target-arm/machine.c:    qemu_put_be32(f, env->cp15.c15_power_diagnostic);
target-arm/machine.c:    qemu_put_be32(f, env->features);
target-arm/machine.c:            u.d = env->vfp.regs[i];
target-arm/machine.c:            qemu_put_be32(f, env->vfp.xregs[i]);
target-arm/machine.c:        qemu_put_be32(f, env->vfp.vec_len);
target-arm/machine.c:        qemu_put_be32(f, env->vfp.vec_stride);
target-arm/machine.c:                u.d = env->vfp.regs[i];
target-arm/machine.c:            qemu_put_be64(f, env->iwmmxt.regs[i]);
target-arm/machine.c:            qemu_put_be32(f, env->iwmmxt.cregs[i]);
target-arm/machine.c:        qemu_put_be32(f, env->v7m.other_sp);
target-arm/machine.c:        qemu_put_be32(f, env->v7m.vecbase);
target-arm/machine.c:        qemu_put_be32(f, env->v7m.basepri);
target-arm/machine.c:        qemu_put_be32(f, env->v7m.control);
target-arm/machine.c:        qemu_put_be32(f, env->v7m.current_sp);
target-arm/machine.c:        qemu_put_be32(f, env->v7m.exception);
target-arm/machine.c:        qemu_put_be32(f, env->teecr);
target-arm/machine.c:        qemu_put_be32(f, env->teehbr);
target-arm/machine.c:        env->regs[i] = qemu_get_be32(f);
target-arm/machine.c:    env->uncached_cpsr = val & CPSR_M;
target-arm/machine.c:    env->spsr = qemu_get_be32(f);
target-arm/machine.c:        env->banked_spsr[i] = qemu_get_be32(f);
target-arm/machine.c:        env->banked_r13[i] = qemu_get_be32(f);
target-arm/machine.c:        env->banked_r14[i] = qemu_get_be32(f);
target-arm/machine.c:        env->usr_regs[i] = qemu_get_be32(f);
target-arm/machine.c:        env->fiq_regs[i] = qemu_get_be32(f);
target-arm/machine.c:    env->cp15.c0_cpuid = qemu_get_be32(f);
target-arm/machine.c:    env->cp15.c0_cachetype = qemu_get_be32(f);
target-arm/machine.c:    env->cp15.c0_cssel = qemu_get_be32(f);
target-arm/machine.c:    env->cp15.c1_sys = qemu_get_be32(f);
target-arm/machine.c:    env->cp15.c1_coproc = qemu_get_be32(f);
target-arm/machine.c:    env->cp15.c1_xscaleauxcr = qemu_get_be32(f);
target-arm/machine.c:    env->cp15.c1_scr = qemu_get_be32(f);
target-arm/machine.c:    env->cp15.c2_base0 = qemu_get_be32(f);
target-arm/machine.c:    env->cp15.c2_base1 = qemu_get_be32(f);
target-arm/machine.c:    env->cp15.c2_control = qemu_get_be32(f);
target-arm/machine.c:    env->cp15.c2_mask = qemu_get_be32(f);
target-arm/machine.c:    env->cp15.c2_base_mask = qemu_get_be32(f);
target-arm/machine.c:    env->cp15.c2_data = qemu_get_be32(f);
target-arm/machine.c:    env->cp15.c2_insn = qemu_get_be32(f);
target-arm/machine.c:    env->cp15.c3 = qemu_get_be32(f);
target-arm/machine.c:    env->cp15.c5_insn = qemu_get_be32(f);
target-arm/machine.c:    env->cp15.c5_data = qemu_get_be32(f);
target-arm/machine.c:        env->cp15.c6_region[i] = qemu_get_be32(f);
target-arm/machine.c:    env->cp15.c6_insn = qemu_get_be32(f);
target-arm/machine.c:    env->cp15.c6_data = qemu_get_be32(f);
target-arm/machine.c:    env->cp15.c7_par = qemu_get_be32(f);
target-arm/machine.c:    env->cp15.c9_insn = qemu_get_be32(f);
target-arm/machine.c:    env->cp15.c9_data = qemu_get_be32(f);
target-arm/machine.c:    env->cp15.c9_pmcr = qemu_get_be32(f);
target-arm/machine.c:    env->cp15.c9_pmcnten = qemu_get_be32(f);
target-arm/machine.c:    env->cp15.c9_pmovsr = qemu_get_be32(f);
target-arm/machine.c:    env->cp15.c9_pmxevtyper = qemu_get_be32(f);
target-arm/machine.c:    env->cp15.c9_pmuserenr = qemu_get_be32(f);
target-arm/machine.c:    env->cp15.c9_pminten = qemu_get_be32(f);
target-arm/machine.c:    env->cp15.c13_fcse = qemu_get_be32(f);
target-arm/machine.c:    env->cp15.c13_context = qemu_get_be32(f);
target-arm/machine.c:    env->cp15.c13_tls1 = qemu_get_be32(f);
target-arm/machine.c:    env->cp15.c13_tls2 = qemu_get_be32(f);
target-arm/machine.c:    env->cp15.c13_tls3 = qemu_get_be32(f);
target-arm/machine.c:    env->cp15.c15_cpar = qemu_get_be32(f);
target-arm/machine.c:    env->cp15.c15_power_control = qemu_get_be32(f);
target-arm/machine.c:    env->cp15.c15_diagnostic = qemu_get_be32(f);
target-arm/machine.c:    env->cp15.c15_power_diagnostic = qemu_get_be32(f);
target-arm/machine.c:    env->features = qemu_get_be32(f);
target-arm/machine.c:            env->vfp.regs[i] = u.d;
target-arm/machine.c:            env->vfp.xregs[i] = qemu_get_be32(f);
target-arm/machine.c:        env->vfp.vec_len = qemu_get_be32(f);
target-arm/machine.c:        env->vfp.vec_stride = qemu_get_be32(f);
target-arm/machine.c:                env->vfp.regs[i] = u.d;
target-arm/machine.c:            env->iwmmxt.regs[i] = qemu_get_be64(f);
target-arm/machine.c:            env->iwmmxt.cregs[i] = qemu_get_be32(f);
target-arm/machine.c:        env->v7m.other_sp = qemu_get_be32(f);
target-arm/machine.c:        env->v7m.vecbase = qemu_get_be32(f);
target-arm/machine.c:        env->v7m.basepri = qemu_get_be32(f);
target-arm/machine.c:        env->v7m.control = qemu_get_be32(f);
target-arm/machine.c:        env->v7m.current_sp = qemu_get_be32(f);
target-arm/machine.c:        env->v7m.exception = qemu_get_be32(f);
target-arm/machine.c:        env->teecr = qemu_get_be32(f);
target-arm/machine.c:        env->teehbr = qemu_get_be32(f);
target-arm/translate.c:        if (!env->cp[cp].cp_read)
target-arm/translate.c:        if (!env->cp[cp].cp_write)
target-arm/translate.c:            return env->cp15.c9_pmuserenr;
target-arm/translate.c:            if (IS_USER(s) && (env->teecr & 1))
target-arm/translate.c:            if (IS_USER(s) && (env->teecr & 1))
target-arm/translate.c:	    && ((env->cp15.c15_cpar ^ 0x3fff) & (1 << cpnum)))
target-arm/translate.c:    /* if (env->exclusive_addr == addr && env->exclusive_val == [addr]) {
target-arm/translate.c:                if (env->cp15.c15_cpar & (1 << 1))
target-arm/translate.c:    dc->singlestep_enabled = env->singlestep_enabled;
target-arm/translate.c:        if (unlikely(!QTAILQ_EMPTY(&env->breakpoints))) {
target-arm/translate.c:            QTAILQ_FOREACH(bp, &env->breakpoints, entry) {
target-arm/translate.c:             !env->singlestep_enabled &&
target-arm/translate.c:    if (unlikely(env->singlestep_enabled)) {
target-arm/translate.c:        cpu_fprintf(f, "R%02d=%08x", i, env->regs[i]);
target-arm/translate.c:        d.d = env->vfp.regs[i];
target-arm/translate.c:    cpu_fprintf(f, "FPSCR: %08x\n", (int)env->vfp.xregs[ARM_VFP_FPSCR]);
target-arm/translate.c:    env->regs[15] = gen_opc_pc[pc_pos];
target-arm/translate.c:    env->condexec_bits = gen_opc_condexec_bits[pc_pos];
target-cris/op_helper.c:          env->pc, env->debug1, (void *)retaddr);
target-cris/op_helper.c:	env->exception_index = index;
target-cris/op_helper.c:	if (pid != (env->pregs[PR_PID] & 0xff))
target-cris/op_helper.c:		cris_mmu_flush_pid(env, env->pregs[PR_PID]);
target-cris/op_helper.c:	tlb_flush_page(env, env->pregs[PR_SPC]);
target-cris/op_helper.c:	srs = env->pregs[PR_SRS];
target-cris/op_helper.c:	env->sregs[srs][sreg] = env->regs[reg];
target-cris/op_helper.c:			env->sregs[SFR_RW_MM_TLB_HI] = env->regs[reg];
target-cris/op_helper.c:			env->sregs[SFR_R_MM_CAUSE] = env->regs[reg];
target-cris/op_helper.c:			idx = set = env->sregs[SFR_RW_MM_TLB_SEL];
target-cris/op_helper.c:			lo = env->sregs[SFR_RW_MM_TLB_LO];
target-cris/op_helper.c:			hi = env->sregs[SFR_R_MM_CAUSE];
target-cris/op_helper.c:			vaddr = EXTRACT_FIELD(env->tlbsets[srs-1][set][idx].hi,
target-cris/op_helper.c:			tlb_v = EXTRACT_FIELD(env->tlbsets[srs-1][set][idx].lo,
target-cris/op_helper.c:			env->tlbsets[srs - 1][set][idx].lo = lo;
target-cris/op_helper.c:			env->tlbsets[srs - 1][set][idx].hi = hi;
target-cris/op_helper.c:				  vaddr, tlb_v, env->pc);
target-cris/op_helper.c:	env->pregs[PR_SRS] &= 3;
target-cris/op_helper.c:	srs = env->pregs[PR_SRS];
target-cris/op_helper.c:		idx = set = env->sregs[SFR_RW_MM_TLB_SEL];
target-cris/op_helper.c:		hi = env->tlbsets[srs - 1][set][idx].hi;
target-cris/op_helper.c:		lo = env->tlbsets[srs - 1][set][idx].lo;
target-cris/op_helper.c:		env->sregs[SFR_RW_MM_TLB_HI] = hi;
target-cris/op_helper.c:		env->sregs[SFR_RW_MM_TLB_LO] = lo;
target-cris/op_helper.c:	env->regs[reg] = env->sregs[srs][sreg];
target-cris/op_helper.c:	ccs = env->pregs[PR_CCS];
target-cris/op_helper.c:		env->ksp = env->regs[R_SP];
target-cris/op_helper.c:		env->regs[R_SP] = env->pregs[PR_USP];
target-cris/op_helper.c:	env->pregs[PR_CCS] = ccs;
target-cris/op_helper.c:	int rflag = env->pregs[PR_CCS] & R_FLAG;
target-cris/op_helper.c:		 env->pregs[PR_ERP], env->pregs[PR_PID],
target-cris/op_helper.c:		 env->pregs[PR_CCS],
target-cris/op_helper.c:		 env->btarget);
target-cris/op_helper.c:		env->pregs[PR_CCS] |= P_FLAG;
target-cris/op_helper.c:	int rflag = env->pregs[PR_CCS] & R_FLAG;
target-cris/op_helper.c:		 env->pregs[PR_ERP], env->pregs[PR_PID],
target-cris/op_helper.c:		 env->pregs[PR_CCS],
target-cris/op_helper.c:		 env->btarget);
target-cris/op_helper.c:		env->pregs[PR_CCS] |= P_FLAG;
target-cris/op_helper.c:    env->pregs[PR_CCS] |= M_FLAG;
target-cris/op_helper.c:	if (env->pregs[PR_VR] < 32)
target-cris/op_helper.c:	x = env->cc_x;
target-cris/op_helper.c:	mask = env->cc_mask | X_FLAG;
target-cris/op_helper.c:	src = env->cc_src;
target-cris/op_helper.c:	dst = env->cc_dest;
target-cris/op_helper.c:	res = env->cc_result;
target-cris/op_helper.c:	if (env->cc_op == CC_OP_SUB || env->cc_op == CC_OP_CMP)
target-cris/op_helper.c:	switch (env->cc_size)
target-cris/op_helper.c:	if (env->cc_op == CC_OP_SUB || env->cc_op == CC_OP_CMP)
target-cris/op_helper.c:	env->pregs[PR_CCS] = evaluate_flags_writeback(flags, env->pregs[PR_CCS]);
target-cris/op_helper.c:	switch (env->cc_op)
target-cris/op_helper.c:			env->pregs[PR_CCS] = helper_evaluate_flags_mcp(
target-cris/op_helper.c:					env->pregs[PR_CCS], env->cc_src,
target-cris/op_helper.c:					env->cc_dest, env->cc_result);
target-cris/op_helper.c:			env->pregs[PR_CCS] = helper_evaluate_flags_muls(
target-cris/op_helper.c:					env->pregs[PR_CCS], env->cc_result,
target-cris/op_helper.c:					env->pregs[PR_MOF]);
target-cris/op_helper.c:			env->pregs[PR_CCS] = helper_evaluate_flags_mulu(
target-cris/op_helper.c:					env->pregs[PR_CCS], env->cc_result,
target-cris/op_helper.c:					env->pregs[PR_MOF]);
target-cris/op_helper.c:		switch (env->cc_size)
target-cris/op_helper.c:				env->pregs[PR_CCS] =
target-cris/op_helper.c:							env->pregs[PR_CCS],
target-cris/op_helper.c:							env->cc_result);
target-cris/op_helper.c:				env->pregs[PR_CCS] =
target-cris/op_helper.c:							env->pregs[PR_CCS],
target-cris/op_helper.c:							env->cc_result);
target-cris/op_helper.c:			if (env->cc_size == 4)
target-cris/op_helper.c:				env->pregs[PR_CCS] =
target-cris/op_helper.c:						env->pregs[PR_CCS],
target-cris/op_helper.c:						env->cc_src, env->cc_dest,
target-cris/op_helper.c:						env->cc_result);
target-cris/op_helper.c:			switch (env->cc_size)
target-cris/op_helper.c:				env->pregs[PR_CCS] =
target-cris/op_helper.c:						env->pregs[PR_CCS],
target-cris/op_helper.c:						env->cc_src, env->cc_dest,
target-cris/op_helper.c:						env->cc_result);
target-cris/cpu.h:    CC_OP_DYNAMIC, /* Use env->cc_op  */
target-cris/cpu.h:	return !!(env->pregs[PR_CCS] & U_FLAG);
target-cris/cpu.h:        env->regs[14] = newsp;
target-cris/cpu.h:    env->regs[10] = 0;
target-cris/cpu.h:	env->pregs[PR_PID] = (env->pregs[PR_PID] & 0xff) | newtls;
target-cris/cpu.h:#define SFR_RW_MM_CFG      env->pregs[PR_SRS]][0
target-cris/cpu.h:#define SFR_RW_MM_KBASE_LO env->pregs[PR_SRS]][1
target-cris/cpu.h:#define SFR_RW_MM_KBASE_HI env->pregs[PR_SRS]][2
target-cris/cpu.h:#define SFR_R_MM_CAUSE     env->pregs[PR_SRS]][3
target-cris/cpu.h:#define SFR_RW_MM_TLB_SEL  env->pregs[PR_SRS]][4
target-cris/cpu.h:#define SFR_RW_MM_TLB_LO   env->pregs[PR_SRS]][5
target-cris/cpu.h:#define SFR_RW_MM_TLB_HI   env->pregs[PR_SRS]][6
target-cris/cpu.h:    *pc = env->pc;
target-cris/cpu.h:    *flags = env->dslot |
target-cris/cpu.h:            (env->pregs[PR_CCS] & (S_FLAG | P_FLAG | U_FLAG
target-cris/cpu.h:    return env->interrupt_request & (CPU_INTERRUPT_HARD | CPU_INTERRUPT_NMI);
target-cris/cpu.h:    env->pc = tb->pc;
target-cris/helper.c:	env->exception_index = -1;
target-cris/helper.c:	env->pregs[PR_ERP] = env->pc;
target-cris/helper.c:	env->exception_index = 0xaa;
target-cris/helper.c:	env->pregs[PR_EDA] = address;
target-cris/helper.c:	ccs = env->pregs[PR_CCS];
target-cris/helper.c:	env->pregs[PR_CCS] = ccs;
target-cris/helper.c:	D(printf ("%s addr=%x pc=%x rw=%x\n", __func__, address, env->pc, rw));
target-cris/helper.c:		if (env->exception_index == EXCP_BUSFAULT)
target-cris/helper.c:		env->pregs[PR_EDA] = address;
target-cris/helper.c:		env->exception_index = EXCP_BUSFAULT;
target-cris/helper.c:		env->fault_vector = res.bf_vec;
target-cris/helper.c:                  __func__, r, env->interrupt_request, address, res.phy,
target-cris/helper.c:                  res.bf_vec, env->pc);
target-cris/helper.c:		   env->exception_index,
target-cris/helper.c:		   env->interrupt_request);
target-cris/helper.c:	assert(!(env->pregs[PR_CCS] & PFIX_FLAG));
target-cris/helper.c:	switch (env->exception_index)
target-cris/helper.c:			ex_vec = env->trap_vector;
target-cris/helper.c:			env->pregs[PR_ERP] = env->pc;
target-cris/helper.c:			env->pregs[PR_CCS] &= ~M_FLAG;
target-cris/helper.c:			env->pregs[PR_NRP] = env->pc;
target-cris/helper.c:			ex_vec = env->interrupt_vector;
target-cris/helper.c:			   TB's.  env->pc is valid here.  */
target-cris/helper.c:			env->pregs[PR_ERP] = env->pc;
target-cris/helper.c:	if (env->pregs[PR_CCS] & U_FLAG) {
target-cris/helper.c:		env->pregs[PR_USP] = env->regs[R_SP];
target-cris/helper.c:		env->regs[R_SP] = env->ksp;
target-cris/helper.c:	env->pc = ldl_code(env->pregs[PR_EBP] + ex_vec * 4);
target-cris/helper.c:	env->locked_irq = 1;
target-cris/helper.c:	env->pregs[PR_CCS] |= F_FLAG_V10; /* set F.  */
target-cris/helper.c:		      __func__, env->pc, ex_vec, 
target-cris/helper.c:		      env->pregs[PR_CCS],
target-cris/helper.c:		      env->pregs[PR_PID], 
target-cris/helper.c:		      env->pregs[PR_ERP]);
target-cris/helper.c:	if (env->pregs[PR_VR] < 32)
target-cris/helper.c:		   env->exception_index,
target-cris/helper.c:		   env->interrupt_request);
target-cris/helper.c:	switch (env->exception_index)
target-cris/helper.c:			ex_vec = env->trap_vector;
target-cris/helper.c:			env->pregs[PR_ERP] = env->pc;
target-cris/helper.c:			env->pregs[PR_CCS] &= ~M_FLAG;
target-cris/helper.c:			env->pregs[PR_NRP] = env->pc;
target-cris/helper.c:			ex_vec = env->fault_vector;
target-cris/helper.c:			env->pregs[PR_ERP] = env->pc;
target-cris/helper.c:			ex_vec = env->interrupt_vector;
target-cris/helper.c:			   TB's.  env->pc is valid here.  */
target-cris/helper.c:			env->pregs[PR_ERP] = env->pc;
target-cris/helper.c:	env->pregs[PR_EXS] = (ex_vec & 0xff) << 8;
target-cris/helper.c:	if (env->dslot) {
target-cris/helper.c:			  ex_vec, env->pc, env->dslot,
target-cris/helper.c:			  env->regs[R_SP],
target-cris/helper.c:			  env->pregs[PR_ERP], env->pregs[PR_PID],
target-cris/helper.c:			  env->pregs[PR_CCS],
target-cris/helper.c:			  env->cc_op, env->cc_mask);
target-cris/helper.c:		env->pregs[PR_ERP] -= env->dslot;
target-cris/helper.c:		env->dslot = 0;
target-cris/helper.c:	if (env->pregs[PR_CCS] & U_FLAG) {
target-cris/helper.c:		env->pregs[PR_USP] = env->regs[R_SP];
target-cris/helper.c:		env->regs[R_SP] = env->ksp;
target-cris/helper.c:	env->pc = ldl_code(env->pregs[PR_EBP] + ex_vec * 4);
target-cris/helper.c:	env->exception_index = -1;
target-cris/helper.c:		   __func__, env->pc, ex_vec,
target-cris/helper.c:		   env->pregs[PR_CCS],
target-cris/helper.c:		   env->pregs[PR_PID], 
target-cris/helper.c:		   env->pregs[PR_ERP]);
target-cris/mmu.c:	env->mmu_rand_lfsr = 0xcccc;
target-cris/mmu.c:	f = compute_polynom(env->mmu_rand_lfsr);
target-cris/mmu.c:	env->mmu_rand_lfsr >>= 1;
target-cris/mmu.c:	env->mmu_rand_lfsr |= (f << 15);
target-cris/mmu.c:	env->mmu_rand_lfsr &= 0xffff;
target-cris/mmu.c:		base = env->sregs[SFR_RW_MM_KBASE_LO];
target-cris/mmu.c:		base = env->sregs[SFR_RW_MM_KBASE_HI];
target-cris/mmu.c:			lo = env->tlbsets[mmu][set][idx].lo;
target-cris/mmu.c:			hi = env->tlbsets[mmu][set][idx].hi;
target-cris/mmu.c:	r_cause = env->sregs[SFR_R_MM_CAUSE];
target-cris/mmu.c:	r_cfg = env->sregs[SFR_RW_MM_CFG];
target-cris/mmu.c:	pid = env->pregs[PR_PID] & 0xff;
target-cris/mmu.c:			lo = env->tlbsets[mmu][set][idx].lo;
target-cris/mmu.c:			hi = env->tlbsets[mmu][set][idx].hi;
target-cris/mmu.c:		lo = env->tlbsets[mmu][set][idx].lo;
target-cris/mmu.c:		hi = env->tlbsets[mmu][set][idx].hi;
target-cris/mmu.c:				  vaddr, lo, env->pc));
target-cris/mmu.c:				  vaddr, lo, env->pc));
target-cris/mmu.c:				 vaddr, lo, env->pc));
target-cris/mmu.c:		set = env->mmu_rand_lfsr & 3;
target-cris/mmu.c:		env->sregs[SFR_RW_MM_TLB_SEL] = 0;
target-cris/mmu.c:		set_field(&env->sregs[SFR_RW_MM_TLB_SEL], idx, 0, 4);
target-cris/mmu.c:		set_field(&env->sregs[SFR_RW_MM_TLB_SEL], set, 4, 2);
target-cris/mmu.c:		env->sregs[SFR_R_MM_CAUSE] = r_cause;
target-cris/mmu.c:		D(printf("refill vaddr=%x pc=%x\n", vaddr, env->pc));
target-cris/mmu.c:		  __func__, rw, match, env->pc,
target-cris/mmu.c:		  env->sregs[SFR_RW_MM_TLB_SEL],
target-cris/mmu.c:		  env->regs[R_SP], env->pregs[PR_USP], env->ksp));
target-cris/mmu.c:				lo = env->tlbsets[mmu][set][idx].lo;
target-cris/mmu.c:				hi = env->tlbsets[mmu][set][idx].hi;
target-cris/mmu.c:	old_srs= env->pregs[PR_SRS];
target-cris/mmu.c:	env->pregs[PR_SRS] = rw == 2 ? 1 : 2;
target-cris/mmu.c:	if (!cris_mmu_enabled(env->sregs[SFR_RW_GC_CFG])) {
target-cris/mmu.c:	if (!is_user && cris_mmu_segmented_addr(seg, env->sregs[SFR_RW_MM_CFG]))
target-cris/mmu.c:	env->pregs[PR_SRS] = old_srs;
target-cris/cpu.c:        qemu_log("CPU Reset (CPU %d)\n", env->cpu_index);
target-cris/cpu.c:    vr = env->pregs[PR_VR];
target-cris/cpu.c:    env->pregs[PR_VR] = vr;
target-cris/cpu.c:    env->pregs[PR_CCS] |= U_FLAG | I_FLAG | P_FLAG;
target-cris/cpu.c:    env->pregs[PR_CCS] = 0;
target-cris/machine.c:        qemu_put_be32(f, env->regs[i]);
target-cris/machine.c:        qemu_put_be32(f, env->pregs[i]);
target-cris/machine.c:    qemu_put_be32(f, env->pc);
target-cris/machine.c:    qemu_put_be32(f, env->ksp);
target-cris/machine.c:    qemu_put_be32(f, env->dslot);
target-cris/machine.c:    qemu_put_be32(f, env->btaken);
target-cris/machine.c:    qemu_put_be32(f, env->btarget);
target-cris/machine.c:    qemu_put_be32(f, env->cc_op);
target-cris/machine.c:    qemu_put_be32(f, env->cc_mask);
target-cris/machine.c:    qemu_put_be32(f, env->cc_dest);
target-cris/machine.c:    qemu_put_be32(f, env->cc_src);
target-cris/machine.c:    qemu_put_be32(f, env->cc_result);
target-cris/machine.c:    qemu_put_be32(f, env->cc_size);
target-cris/machine.c:    qemu_put_be32(f, env->cc_x);
target-cris/machine.c:            qemu_put_be32(f, env->sregs[s][i]);
target-cris/machine.c:    qemu_put_be32(f, env->mmu_rand_lfsr);
target-cris/machine.c:                qemu_put_be32(f, env->tlbsets[mmu][s][i].lo);
target-cris/machine.c:                qemu_put_be32(f, env->tlbsets[mmu][s][i].hi);
target-cris/machine.c:        env->regs[i] = qemu_get_be32(f);
target-cris/machine.c:        env->pregs[i] = qemu_get_be32(f);
target-cris/machine.c:    env->pc = qemu_get_be32(f);
target-cris/machine.c:    env->ksp = qemu_get_be32(f);
target-cris/machine.c:    env->dslot = qemu_get_be32(f);
target-cris/machine.c:    env->btaken = qemu_get_be32(f);
target-cris/machine.c:    env->btarget = qemu_get_be32(f);
target-cris/machine.c:    env->cc_op = qemu_get_be32(f);
target-cris/machine.c:    env->cc_mask = qemu_get_be32(f);
target-cris/machine.c:    env->cc_dest = qemu_get_be32(f);
target-cris/machine.c:    env->cc_src = qemu_get_be32(f);
target-cris/machine.c:    env->cc_result = qemu_get_be32(f);
target-cris/machine.c:    env->cc_size = qemu_get_be32(f);
target-cris/machine.c:    env->cc_x = qemu_get_be32(f);
target-cris/machine.c:            env->sregs[s][i] = qemu_get_be32(f);
target-cris/machine.c:    env->mmu_rand_lfsr = qemu_get_be32(f);
target-cris/machine.c:                env->tlbsets[mmu][s][i].lo = qemu_get_be32(f);
target-cris/machine.c:                env->tlbsets[mmu][s][i].hi = qemu_get_be32(f);
target-cris/translate.c:	if (unlikely(!QTAILQ_EMPTY(&env->breakpoints))) {
target-cris/translate.c:		QTAILQ_FOREACH(bp, &env->breakpoints, entry) {
target-cris/translate.c: * The TB contaning the branch insn will set up env->btarget and evaluate 
target-cris/translate.c: * env->btaken. When the translation loop exits we will note that the branch 
target-cris/translate.c: * sequence is broken and let env->dslot be the size of the branch insn (those
target-cris/translate.c: * set). It will also expect to have env->dslot setup with the size of the 
target-cris/translate.c: * delay slot so that env->pc - env->dslot point to the branch insn. This TB 
target-cris/translate.c: * When exceptions occur, we check for env->dslot in do_interrupt to detect 
target-cris/translate.c: * branch and set lsb). Then env->dslot gets cleared so that the exception 
target-cris/translate.c:	if (env->pregs[PR_VR] == 32) {
target-cris/translate.c:	dc->singlestep_enabled = env->singlestep_enabled;
target-cris/translate.c:			env->btarget, (unsigned)tb->flags & 7,
target-cris/translate.c:			env->pregs[PR_CCS], 
target-cris/translate.c:			env->pregs[PR_PID], env->pregs[PR_USP],
target-cris/translate.c:			env->regs[0], env->regs[1], env->regs[2], env->regs[3],
target-cris/translate.c:			env->regs[4], env->regs[5], env->regs[6], env->regs[7],
target-cris/translate.c:			env->regs[8], env->regs[9],
target-cris/translate.c:			env->regs[10], env->regs[11],
target-cris/translate.c:			env->regs[12], env->regs[13],
target-cris/translate.c:			env->regs[14], env->regs[15]);
target-cris/translate.c:		if (!(tb->pc & 1) && env->singlestep_enabled)
target-cris/translate.c:		/* Set env->dslot to the size of the branch insn.  */
target-cris/translate.c:	if (unlikely(env->singlestep_enabled)) {
target-cris/translate.c:                                 dc->env->pregs[PR_VR]);
target-cris/translate.c:		    env->pc, env->pregs[PR_CCS], env->btaken, env->btarget,
target-cris/translate.c:		    env->cc_op,
target-cris/translate.c:		    env->cc_src, env->cc_dest, env->cc_result, env->cc_mask);
target-cris/translate.c:		cpu_fprintf(f, "%s=%8.8x ",regnames[i], env->regs[i]);
target-cris/translate.c:		cpu_fprintf(f, "%s=%8.8x ", pregnames[i], env->pregs[i]);
target-cris/translate.c:	srs = env->pregs[PR_SRS];
target-cris/translate.c:				    i, env->sregs[srs][i]);
target-cris/translate.c:	env->pregs[PR_VR] = vr_by_name(cpu_model);
target-cris/translate.c:	if (env->pregs[PR_VR] < 32) {
target-cris/translate.c:	env->pc = gen_opc_pc[pc_pos];
target-i386/op_helper.c:    env->fpstt = (env->fpstt - 1) & 7;
target-i386/op_helper.c:    env->fptags[env->fpstt] = 0; /* validate stack entry */
target-i386/op_helper.c:    env->fptags[env->fpstt] = 1; /* invvalidate stack entry */
target-i386/op_helper.c:    env->fpstt = (env->fpstt + 1) & 7;
target-i386/op_helper.c:    return env->eflags | helper_cc_compute_all(CC_OP) | (DF & DF_MASK);
target-i386/op_helper.c:    env->eflags = (env->eflags & ~update_mask) |
target-i386/op_helper.c:    env->efer = val;
target-i386/op_helper.c:    env->hflags &= ~(HF_LMA_MASK | HF_SVME_MASK);
target-i386/op_helper.c:    if (env->efer & MSR_EFER_LMA) {
target-i386/op_helper.c:        env->hflags |= HF_LMA_MASK;
target-i386/op_helper.c:    if (env->efer & MSR_EFER_SVME) {
target-i386/op_helper.c:        env->hflags |= HF_SVME_MASK;
target-i386/op_helper.c:    eflags |= env->eflags & ~(VM_MASK | RF_MASK);
target-i386/op_helper.c:        dt = &env->ldt;
target-i386/op_helper.c:        dt = &env->gdt;
target-i386/op_helper.c:        printf("TR: base=%p limit=%x\n", env->tr.base, env->tr.limit);
target-i386/op_helper.c:        for(i=0;i<env->tr.limit;i++) {
target-i386/op_helper.c:            printf("%02x ", env->tr.base[i]);
target-i386/op_helper.c:    if (!(env->tr.flags & DESC_P_MASK))
target-i386/op_helper.c:    type = (env->tr.flags >> DESC_TYPE_SHIFT) & 0xf;
target-i386/op_helper.c:    if (index + (4 << shift) - 1 > env->tr.limit)
target-i386/op_helper.c:        raise_exception_err(EXCP0A_TSS, env->tr.selector & 0xfffc);
target-i386/op_helper.c:        *esp_ptr = lduw_kernel(env->tr.base + index);
target-i386/op_helper.c:        *ss_ptr = lduw_kernel(env->tr.base + index + 2);
target-i386/op_helper.c:        *esp_ptr = ldl_kernel(env->tr.base + index);
target-i386/op_helper.c:        *ss_ptr = lduw_kernel(env->tr.base + index + 4);
target-i386/op_helper.c:        cpl = env->hflags & HF_CPL_MASK;
target-i386/op_helper.c:    old_type = (env->tr.flags >> DESC_TYPE_SHIFT) & 0xf;
target-i386/op_helper.c:    v1 = ldub_kernel(env->tr.base);
target-i386/op_helper.c:    v2 = ldub_kernel(env->tr.base + old_tss_limit_max);
target-i386/op_helper.c:    stb_kernel(env->tr.base, v1);
target-i386/op_helper.c:    stb_kernel(env->tr.base + old_tss_limit_max, v2);
target-i386/op_helper.c:        ptr = env->gdt.base + (env->tr.selector & ~7);
target-i386/op_helper.c:        stl_kernel(env->tr.base + 0x20, next_eip);
target-i386/op_helper.c:        stl_kernel(env->tr.base + 0x24, old_eflags);
target-i386/op_helper.c:        stl_kernel(env->tr.base + (0x28 + 0 * 4), EAX);
target-i386/op_helper.c:        stl_kernel(env->tr.base + (0x28 + 1 * 4), ECX);
target-i386/op_helper.c:        stl_kernel(env->tr.base + (0x28 + 2 * 4), EDX);
target-i386/op_helper.c:        stl_kernel(env->tr.base + (0x28 + 3 * 4), EBX);
target-i386/op_helper.c:        stl_kernel(env->tr.base + (0x28 + 4 * 4), ESP);
target-i386/op_helper.c:        stl_kernel(env->tr.base + (0x28 + 5 * 4), EBP);
target-i386/op_helper.c:        stl_kernel(env->tr.base + (0x28 + 6 * 4), ESI);
target-i386/op_helper.c:        stl_kernel(env->tr.base + (0x28 + 7 * 4), EDI);
target-i386/op_helper.c:            stw_kernel(env->tr.base + (0x48 + i * 4), env->segs[i].selector);
target-i386/op_helper.c:        stw_kernel(env->tr.base + 0x0e, next_eip);
target-i386/op_helper.c:        stw_kernel(env->tr.base + 0x10, old_eflags);
target-i386/op_helper.c:        stw_kernel(env->tr.base + (0x12 + 0 * 2), EAX);
target-i386/op_helper.c:        stw_kernel(env->tr.base + (0x12 + 1 * 2), ECX);
target-i386/op_helper.c:        stw_kernel(env->tr.base + (0x12 + 2 * 2), EDX);
target-i386/op_helper.c:        stw_kernel(env->tr.base + (0x12 + 3 * 2), EBX);
target-i386/op_helper.c:        stw_kernel(env->tr.base + (0x12 + 4 * 2), ESP);
target-i386/op_helper.c:        stw_kernel(env->tr.base + (0x12 + 5 * 2), EBP);
target-i386/op_helper.c:        stw_kernel(env->tr.base + (0x12 + 6 * 2), ESI);
target-i386/op_helper.c:        stw_kernel(env->tr.base + (0x12 + 7 * 2), EDI);
target-i386/op_helper.c:            stw_kernel(env->tr.base + (0x22 + i * 4), env->segs[i].selector);
target-i386/op_helper.c:        stw_kernel(tss_base, env->tr.selector);
target-i386/op_helper.c:        ptr = env->gdt.base + (tss_selector & ~7);
target-i386/op_helper.c:    env->cr[0] |= CR0_TS_MASK;
target-i386/op_helper.c:    env->hflags |= HF_TS_MASK;
target-i386/op_helper.c:    env->tr.selector = tss_selector;
target-i386/op_helper.c:    env->tr.base = tss_base;
target-i386/op_helper.c:    env->tr.limit = tss_limit;
target-i386/op_helper.c:    env->tr.flags = e2 & ~DESC_TSS_BUSY_MASK;
target-i386/op_helper.c:    if ((type & 8) && (env->cr[0] & CR0_PG_MASK)) {
target-i386/op_helper.c:    env->eip = new_eip;
target-i386/op_helper.c:    env->ldt.selector = new_ldt & ~4;
target-i386/op_helper.c:    env->ldt.base = 0;
target-i386/op_helper.c:    env->ldt.limit = 0;
target-i386/op_helper.c:    env->ldt.flags = 0;
target-i386/op_helper.c:        dt = &env->gdt;
target-i386/op_helper.c:        load_seg_cache_raw_dt(&env->ldt, e1, e2);
target-i386/op_helper.c:    if (new_eip > env->segs[R_CS].limit) {
target-i386/op_helper.c:    if (env->dr[7] & 0x55) {
target-i386/op_helper.c:            if (hw_breakpoint_enabled(env->dr[7], i) == 0x1)
target-i386/op_helper.c:        env->dr[7] &= ~0x55;
target-i386/op_helper.c:    if (!(env->tr.flags & DESC_P_MASK) ||
target-i386/op_helper.c:        ((env->tr.flags >> DESC_TYPE_SHIFT) & 0xf) != 9 ||
target-i386/op_helper.c:        env->tr.limit < 103)
target-i386/op_helper.c:    io_offset = lduw_kernel(env->tr.base + 0x66);
target-i386/op_helper.c:    if ((io_offset + 1) > env->tr.limit)
target-i386/op_helper.c:    val = lduw_kernel(env->tr.base + io_offset);
target-i386/op_helper.c:        old_eip = env->eip;
target-i386/op_helper.c:    dt = &env->idt;
target-i386/op_helper.c:            type = (env->tr.flags >> DESC_TYPE_SHIFT) & 0xf;
target-i386/op_helper.c:            if (env->segs[R_SS].flags & DESC_B_MASK)
target-i386/op_helper.c:            ssp = env->segs[R_SS].base + esp;
target-i386/op_helper.c:    cpl = env->hflags & HF_CPL_MASK;
target-i386/op_helper.c:        if (env->eflags & VM_MASK)
target-i386/op_helper.c:        sp_mask = get_sp_mask(env->segs[R_SS].flags);
target-i386/op_helper.c:        ssp = env->segs[R_SS].base;
target-i386/op_helper.c:    if (env->eflags & VM_MASK)
target-i386/op_helper.c:            if (env->eflags & VM_MASK) {
target-i386/op_helper.c:                PUSHL(ssp, esp, sp_mask, env->segs[R_GS].selector);
target-i386/op_helper.c:                PUSHL(ssp, esp, sp_mask, env->segs[R_FS].selector);
target-i386/op_helper.c:                PUSHL(ssp, esp, sp_mask, env->segs[R_DS].selector);
target-i386/op_helper.c:                PUSHL(ssp, esp, sp_mask, env->segs[R_ES].selector);
target-i386/op_helper.c:            PUSHL(ssp, esp, sp_mask, env->segs[R_SS].selector);
target-i386/op_helper.c:        PUSHL(ssp, esp, sp_mask, env->segs[R_CS].selector);
target-i386/op_helper.c:            if (env->eflags & VM_MASK) {
target-i386/op_helper.c:                PUSHW(ssp, esp, sp_mask, env->segs[R_GS].selector);
target-i386/op_helper.c:                PUSHW(ssp, esp, sp_mask, env->segs[R_FS].selector);
target-i386/op_helper.c:                PUSHW(ssp, esp, sp_mask, env->segs[R_DS].selector);
target-i386/op_helper.c:                PUSHW(ssp, esp, sp_mask, env->segs[R_ES].selector);
target-i386/op_helper.c:            PUSHW(ssp, esp, sp_mask, env->segs[R_SS].selector);
target-i386/op_helper.c:        PUSHW(ssp, esp, sp_mask, env->segs[R_CS].selector);
target-i386/op_helper.c:        if (env->eflags & VM_MASK) {
target-i386/op_helper.c:    env->eip = offset;
target-i386/op_helper.c:        env->eflags &= ~IF_MASK;
target-i386/op_helper.c:    env->eflags &= ~(TF_MASK | VM_MASK | RF_MASK | NT_MASK);
target-i386/op_helper.c:           env->tr.base, env->tr.limit);
target-i386/op_helper.c:    if (!(env->tr.flags & DESC_P_MASK))
target-i386/op_helper.c:    if ((index + 7) > env->tr.limit)
target-i386/op_helper.c:        raise_exception_err(EXCP0A_TSS, env->tr.selector & 0xfffc);
target-i386/op_helper.c:    return ldq_kernel(env->tr.base + index);
target-i386/op_helper.c:        old_eip = env->eip;
target-i386/op_helper.c:    dt = &env->idt;
target-i386/op_helper.c:    cpl = env->hflags & HF_CPL_MASK;
target-i386/op_helper.c:        if (env->eflags & VM_MASK)
target-i386/op_helper.c:    PUSHQ(esp, env->segs[R_SS].selector);
target-i386/op_helper.c:    PUSHQ(esp, env->segs[R_CS].selector);
target-i386/op_helper.c:    env->eip = offset;
target-i386/op_helper.c:        env->eflags &= ~IF_MASK;
target-i386/op_helper.c:    env->eflags &= ~(TF_MASK | VM_MASK | RF_MASK | NT_MASK);
target-i386/op_helper.c:    env->exception_index = EXCP_SYSCALL;
target-i386/op_helper.c:    env->exception_next_eip = env->eip + next_eip_addend;
target-i386/op_helper.c:    if (!(env->efer & MSR_EFER_SCE)) {
target-i386/op_helper.c:    selector = (env->star >> 32) & 0xffff;
target-i386/op_helper.c:    if (env->hflags & HF_LMA_MASK) {
target-i386/op_helper.c:        ECX = env->eip + next_eip_addend;
target-i386/op_helper.c:        env->regs[11] = compute_eflags();
target-i386/op_helper.c:        code64 = env->hflags & HF_CS64_MASK;
target-i386/op_helper.c:        env->eflags &= ~env->fmask;
target-i386/op_helper.c:        load_eflags(env->eflags, 0);
target-i386/op_helper.c:            env->eip = env->lstar;
target-i386/op_helper.c:            env->eip = env->cstar;
target-i386/op_helper.c:        ECX = (uint32_t)(env->eip + next_eip_addend);
target-i386/op_helper.c:        env->eflags &= ~(IF_MASK | RF_MASK | VM_MASK);
target-i386/op_helper.c:        env->eip = (uint32_t)env->star;
target-i386/op_helper.c:    if (!(env->efer & MSR_EFER_SCE)) {
target-i386/op_helper.c:    cpl = env->hflags & HF_CPL_MASK;
target-i386/op_helper.c:    if (!(env->cr[0] & CR0_PE_MASK) || cpl != 0) {
target-i386/op_helper.c:    selector = (env->star >> 48) & 0xffff;
target-i386/op_helper.c:    if (env->hflags & HF_LMA_MASK) {
target-i386/op_helper.c:            env->eip = ECX;
target-i386/op_helper.c:            env->eip = (uint32_t)ECX;
target-i386/op_helper.c:        load_eflags((uint32_t)(env->regs[11]), TF_MASK | AC_MASK | ID_MASK |
target-i386/op_helper.c:        env->eip = (uint32_t)ECX;
target-i386/op_helper.c:        env->eflags |= IF_MASK;
target-i386/op_helper.c:    dt = &env->idt;
target-i386/op_helper.c:    ssp = env->segs[R_SS].base;
target-i386/op_helper.c:        old_eip = env->eip;
target-i386/op_helper.c:    old_cs = env->segs[R_CS].selector;
target-i386/op_helper.c:    env->eip = offset;
target-i386/op_helper.c:    env->segs[R_CS].selector = selector;
target-i386/op_helper.c:    env->segs[R_CS].base = (selector << 4);
target-i386/op_helper.c:    env->eflags &= ~(IF_MASK | TF_MASK | AC_MASK | RF_MASK);
target-i386/op_helper.c:    dt = &env->idt;
target-i386/op_helper.c:    if (env->hflags & HF_LMA_MASK) {
target-i386/op_helper.c:    cpl = env->hflags & HF_CPL_MASK;
target-i386/op_helper.c:    uint32_t event_inj = ldl_phys(env->vm_vmcb + offsetof(struct vmcb, control.event_inj));
target-i386/op_helper.c:		    stl_phys(env->vm_vmcb + offsetof(struct vmcb, control.event_inj_err), error_code);
target-i386/op_helper.c:	    stl_phys(env->vm_vmcb + offsetof(struct vmcb, control.event_inj), event_inj);
target-i386/op_helper.c:        if ((env->cr[0] & CR0_PE_MASK)) {
target-i386/op_helper.c:                    env->hflags & HF_CPL_MASK,
target-i386/op_helper.c:                    env->segs[R_CS].selector, EIP,
target-i386/op_helper.c:                    (int)env->segs[R_CS].base + EIP,
target-i386/op_helper.c:                    env->segs[R_SS].selector, ESP);
target-i386/op_helper.c:                qemu_log(" CR2=" TARGET_FMT_lx, env->cr[2]);
target-i386/op_helper.c:                ptr = env->segs[R_CS].base + env->eip;
target-i386/op_helper.c:    if (env->cr[0] & CR0_PE_MASK) {
target-i386/op_helper.c:        if (env->hflags & HF_SVMI_MASK)
target-i386/op_helper.c:        if (env->hflags & HF_LMA_MASK) {
target-i386/op_helper.c:        if (env->hflags & HF_SVMI_MASK)
target-i386/op_helper.c:    if (env->hflags & HF_SVMI_MASK) {
target-i386/op_helper.c:	    uint32_t event_inj = ldl_phys(env->vm_vmcb + offsetof(struct vmcb, control.event_inj));
target-i386/op_helper.c:	    stl_phys(env->vm_vmcb + offsetof(struct vmcb, control.event_inj), event_inj & ~SVM_EVTINJ_VALID);
target-i386/op_helper.c:    do_interrupt_user(env->exception_index,
target-i386/op_helper.c:                      env->exception_is_int,
target-i386/op_helper.c:                      env->error_code,
target-i386/op_helper.c:                      env->exception_next_eip);
target-i386/op_helper.c:    env->old_exception = -1;
target-i386/op_helper.c:    do_interrupt_all(env->exception_index,
target-i386/op_helper.c:                     env->exception_is_int,
target-i386/op_helper.c:                     env->error_code,
target-i386/op_helper.c:                     env->exception_next_eip, 0);
target-i386/op_helper.c:    env->old_exception = -1;
target-i386/op_helper.c:    int first_contributory = env->old_exception == 0 ||
target-i386/op_helper.c:                              (env->old_exception >= 10 &&
target-i386/op_helper.c:                               env->old_exception <= 13);
target-i386/op_helper.c:                env->old_exception, intno);
target-i386/op_helper.c:    if (env->old_exception == EXCP08_DBLE) {
target-i386/op_helper.c:        if (env->hflags & HF_SVMI_MASK)
target-i386/op_helper.c:        || (env->old_exception == EXCP0E_PAGE &&
target-i386/op_helper.c:        env->old_exception = intno;
target-i386/op_helper.c:    env->exception_index = intno;
target-i386/op_helper.c:    env->error_code = error_code;
target-i386/op_helper.c:    env->exception_is_int = is_int;
target-i386/op_helper.c:    env->exception_next_eip = env->eip + next_eip_addend;
target-i386/op_helper.c:    env->hflags |= HF_SMM_MASK;
target-i386/op_helper.c:    sm_state = env->smbase + 0x8000;
target-i386/op_helper.c:        dt = &env->segs[i];
target-i386/op_helper.c:    stq_phys(sm_state + 0x7e68, env->gdt.base);
target-i386/op_helper.c:    stl_phys(sm_state + 0x7e64, env->gdt.limit);
target-i386/op_helper.c:    stw_phys(sm_state + 0x7e70, env->ldt.selector);
target-i386/op_helper.c:    stq_phys(sm_state + 0x7e78, env->ldt.base);
target-i386/op_helper.c:    stl_phys(sm_state + 0x7e74, env->ldt.limit);
target-i386/op_helper.c:    stw_phys(sm_state + 0x7e72, (env->ldt.flags >> 8) & 0xf0ff);
target-i386/op_helper.c:    stq_phys(sm_state + 0x7e88, env->idt.base);
target-i386/op_helper.c:    stl_phys(sm_state + 0x7e84, env->idt.limit);
target-i386/op_helper.c:    stw_phys(sm_state + 0x7e90, env->tr.selector);
target-i386/op_helper.c:    stq_phys(sm_state + 0x7e98, env->tr.base);
target-i386/op_helper.c:    stl_phys(sm_state + 0x7e94, env->tr.limit);
target-i386/op_helper.c:    stw_phys(sm_state + 0x7e92, (env->tr.flags >> 8) & 0xf0ff);
target-i386/op_helper.c:    stq_phys(sm_state + 0x7ed0, env->efer);
target-i386/op_helper.c:        stq_phys(sm_state + 0x7ff8 - i * 8, env->regs[i]);
target-i386/op_helper.c:    stq_phys(sm_state + 0x7f78, env->eip);
target-i386/op_helper.c:    stl_phys(sm_state + 0x7f68, env->dr[6]);
target-i386/op_helper.c:    stl_phys(sm_state + 0x7f60, env->dr[7]);
target-i386/op_helper.c:    stl_phys(sm_state + 0x7f48, env->cr[4]);
target-i386/op_helper.c:    stl_phys(sm_state + 0x7f50, env->cr[3]);
target-i386/op_helper.c:    stl_phys(sm_state + 0x7f58, env->cr[0]);
target-i386/op_helper.c:    stl_phys(sm_state + 0x7f00, env->smbase);
target-i386/op_helper.c:    stl_phys(sm_state + 0x7ffc, env->cr[0]);
target-i386/op_helper.c:    stl_phys(sm_state + 0x7ff8, env->cr[3]);
target-i386/op_helper.c:    stl_phys(sm_state + 0x7ff0, env->eip);
target-i386/op_helper.c:    stl_phys(sm_state + 0x7fcc, env->dr[6]);
target-i386/op_helper.c:    stl_phys(sm_state + 0x7fc8, env->dr[7]);
target-i386/op_helper.c:    stl_phys(sm_state + 0x7fc4, env->tr.selector);
target-i386/op_helper.c:    stl_phys(sm_state + 0x7f64, env->tr.base);
target-i386/op_helper.c:    stl_phys(sm_state + 0x7f60, env->tr.limit);
target-i386/op_helper.c:    stl_phys(sm_state + 0x7f5c, (env->tr.flags >> 8) & 0xf0ff);
target-i386/op_helper.c:    stl_phys(sm_state + 0x7fc0, env->ldt.selector);
target-i386/op_helper.c:    stl_phys(sm_state + 0x7f80, env->ldt.base);
target-i386/op_helper.c:    stl_phys(sm_state + 0x7f7c, env->ldt.limit);
target-i386/op_helper.c:    stl_phys(sm_state + 0x7f78, (env->ldt.flags >> 8) & 0xf0ff);
target-i386/op_helper.c:    stl_phys(sm_state + 0x7f74, env->gdt.base);
target-i386/op_helper.c:    stl_phys(sm_state + 0x7f70, env->gdt.limit);
target-i386/op_helper.c:    stl_phys(sm_state + 0x7f58, env->idt.base);
target-i386/op_helper.c:    stl_phys(sm_state + 0x7f54, env->idt.limit);
target-i386/op_helper.c:        dt = &env->segs[i];
target-i386/op_helper.c:    stl_phys(sm_state + 0x7f14, env->cr[4]);
target-i386/op_helper.c:    stl_phys(sm_state + 0x7ef8, env->smbase);
target-i386/op_helper.c:    env->eip = 0x00008000;
target-i386/op_helper.c:    cpu_x86_load_seg_cache(env, R_CS, (env->smbase >> 4) & 0xffff, env->smbase,
target-i386/op_helper.c:                       env->cr[0] & ~(CR0_PE_MASK | CR0_EM_MASK | CR0_TS_MASK | CR0_PG_MASK));
target-i386/op_helper.c:    env->dr[7] = 0x00000400;
target-i386/op_helper.c:    sm_state = env->smbase + 0x8000;
target-i386/op_helper.c:    env->gdt.base = ldq_phys(sm_state + 0x7e68);
target-i386/op_helper.c:    env->gdt.limit = ldl_phys(sm_state + 0x7e64);
target-i386/op_helper.c:    env->ldt.selector = lduw_phys(sm_state + 0x7e70);
target-i386/op_helper.c:    env->ldt.base = ldq_phys(sm_state + 0x7e78);
target-i386/op_helper.c:    env->ldt.limit = ldl_phys(sm_state + 0x7e74);
target-i386/op_helper.c:    env->ldt.flags = (lduw_phys(sm_state + 0x7e72) & 0xf0ff) << 8;
target-i386/op_helper.c:    env->idt.base = ldq_phys(sm_state + 0x7e88);
target-i386/op_helper.c:    env->idt.limit = ldl_phys(sm_state + 0x7e84);
target-i386/op_helper.c:    env->tr.selector = lduw_phys(sm_state + 0x7e90);
target-i386/op_helper.c:    env->tr.base = ldq_phys(sm_state + 0x7e98);
target-i386/op_helper.c:    env->tr.limit = ldl_phys(sm_state + 0x7e94);
target-i386/op_helper.c:    env->tr.flags = (lduw_phys(sm_state + 0x7e92) & 0xf0ff) << 8;
target-i386/op_helper.c:        env->regs[i] = ldq_phys(sm_state + 0x7ff8 - i * 8);
target-i386/op_helper.c:    env->eip = ldq_phys(sm_state + 0x7f78);
target-i386/op_helper.c:    env->dr[6] = ldl_phys(sm_state + 0x7f68);
target-i386/op_helper.c:    env->dr[7] = ldl_phys(sm_state + 0x7f60);
target-i386/op_helper.c:        env->smbase = ldl_phys(sm_state + 0x7f00) & ~0x7fff;
target-i386/op_helper.c:    env->eip = ldl_phys(sm_state + 0x7ff0);
target-i386/op_helper.c:    env->dr[6] = ldl_phys(sm_state + 0x7fcc);
target-i386/op_helper.c:    env->dr[7] = ldl_phys(sm_state + 0x7fc8);
target-i386/op_helper.c:    env->tr.selector = ldl_phys(sm_state + 0x7fc4) & 0xffff;
target-i386/op_helper.c:    env->tr.base = ldl_phys(sm_state + 0x7f64);
target-i386/op_helper.c:    env->tr.limit = ldl_phys(sm_state + 0x7f60);
target-i386/op_helper.c:    env->tr.flags = (ldl_phys(sm_state + 0x7f5c) & 0xf0ff) << 8;
target-i386/op_helper.c:    env->ldt.selector = ldl_phys(sm_state + 0x7fc0) & 0xffff;
target-i386/op_helper.c:    env->ldt.base = ldl_phys(sm_state + 0x7f80);
target-i386/op_helper.c:    env->ldt.limit = ldl_phys(sm_state + 0x7f7c);
target-i386/op_helper.c:    env->ldt.flags = (ldl_phys(sm_state + 0x7f78) & 0xf0ff) << 8;
target-i386/op_helper.c:    env->gdt.base = ldl_phys(sm_state + 0x7f74);
target-i386/op_helper.c:    env->gdt.limit = ldl_phys(sm_state + 0x7f70);
target-i386/op_helper.c:    env->idt.base = ldl_phys(sm_state + 0x7f58);
target-i386/op_helper.c:    env->idt.limit = ldl_phys(sm_state + 0x7f54);
target-i386/op_helper.c:        env->smbase = ldl_phys(sm_state + 0x7ef8) & ~0x7fff;
target-i386/op_helper.c:    env->hflags &= ~HF_SMM_MASK;
target-i386/op_helper.c:    env->dr[6] |= DR6_BS;
target-i386/op_helper.c:    esp_mask = get_sp_mask(env->segs[R_SS].flags);
target-i386/op_helper.c:    ssp = env->segs[R_SS].base;
target-i386/op_helper.c:        env->ldt.base = 0;
target-i386/op_helper.c:        env->ldt.limit = 0;
target-i386/op_helper.c:        dt = &env->gdt;
target-i386/op_helper.c:        if (env->hflags & HF_LMA_MASK)
target-i386/op_helper.c:        if (env->hflags & HF_LMA_MASK) {
target-i386/op_helper.c:            load_seg_cache_raw_dt(&env->ldt, e1, e2);
target-i386/op_helper.c:            env->ldt.base |= (target_ulong)e3 << 32;
target-i386/op_helper.c:            load_seg_cache_raw_dt(&env->ldt, e1, e2);
target-i386/op_helper.c:    env->ldt.selector = selector;
target-i386/op_helper.c:        env->tr.base = 0;
target-i386/op_helper.c:        env->tr.limit = 0;
target-i386/op_helper.c:        env->tr.flags = 0;
target-i386/op_helper.c:        dt = &env->gdt;
target-i386/op_helper.c:        if (env->hflags & HF_LMA_MASK)
target-i386/op_helper.c:        if (env->hflags & HF_LMA_MASK) {
target-i386/op_helper.c:            load_seg_cache_raw_dt(&env->tr, e1, e2);
target-i386/op_helper.c:            env->tr.base |= (target_ulong)e3 << 32;
target-i386/op_helper.c:            load_seg_cache_raw_dt(&env->tr, e1, e2);
target-i386/op_helper.c:    env->tr.selector = selector;
target-i386/op_helper.c:    cpl = env->hflags & HF_CPL_MASK;
target-i386/op_helper.c:            && (!(env->hflags & HF_CS64_MASK) || cpl == 3)
target-i386/op_helper.c:            dt = &env->ldt;
target-i386/op_helper.c:            dt = &env->gdt;
target-i386/op_helper.c:    cpl = env->hflags & HF_CPL_MASK;
target-i386/op_helper.c:            !(env->hflags & HF_LMA_MASK) && !(e2 & DESC_L_MASK))
target-i386/op_helper.c:        cpl = env->hflags & HF_CPL_MASK;
target-i386/op_helper.c:            next_eip = env->eip + next_eip_addend;
target-i386/op_helper.c:    esp_mask = get_sp_mask(env->segs[R_SS].flags);
target-i386/op_helper.c:    ssp = env->segs[R_SS].base;
target-i386/op_helper.c:        PUSHL(ssp, esp, esp_mask, env->segs[R_CS].selector);
target-i386/op_helper.c:        PUSHW(ssp, esp, esp_mask, env->segs[R_CS].selector);
target-i386/op_helper.c:    env->eip = new_eip;
target-i386/op_helper.c:    env->segs[R_CS].selector = new_cs;
target-i386/op_helper.c:    env->segs[R_CS].base = (new_cs << 4);
target-i386/op_helper.c:    next_eip = env->eip + next_eip_addend;
target-i386/op_helper.c:    cpl = env->hflags & HF_CPL_MASK;
target-i386/op_helper.c:            PUSHQ(rsp, env->segs[R_CS].selector);
target-i386/op_helper.c:            sp_mask = get_sp_mask(env->segs[R_SS].flags);
target-i386/op_helper.c:            ssp = env->segs[R_SS].base;
target-i386/op_helper.c:                PUSHL(ssp, sp, sp_mask, env->segs[R_CS].selector);
target-i386/op_helper.c:                PUSHW(ssp, sp, sp_mask, env->segs[R_CS].selector);
target-i386/op_helper.c:            old_sp_mask = get_sp_mask(env->segs[R_SS].flags);
target-i386/op_helper.c:            old_ssp = env->segs[R_SS].base;
target-i386/op_helper.c:                PUSHL(ssp, sp, sp_mask, env->segs[R_SS].selector);
target-i386/op_helper.c:                PUSHW(ssp, sp, sp_mask, env->segs[R_SS].selector);
target-i386/op_helper.c:            sp_mask = get_sp_mask(env->segs[R_SS].flags);
target-i386/op_helper.c:            ssp = env->segs[R_SS].base;
target-i386/op_helper.c:            PUSHL(ssp, sp, sp_mask, env->segs[R_CS].selector);
target-i386/op_helper.c:            PUSHW(ssp, sp, sp_mask, env->segs[R_CS].selector);
target-i386/op_helper.c:    ssp = env->segs[R_SS].base;
target-i386/op_helper.c:    env->segs[R_CS].selector = new_cs;
target-i386/op_helper.c:    env->segs[R_CS].base = (new_cs << 4);
target-i386/op_helper.c:    env->eip = new_eip;
target-i386/op_helper.c:    if (env->eflags & VM_MASK)
target-i386/op_helper.c:    env->hflags2 &= ~HF2_NMI_MASK;
target-i386/op_helper.c:        (env->segs[seg_reg].selector & 0xfffc) == 0)
target-i386/op_helper.c:    e2 = env->segs[seg_reg].flags;
target-i386/op_helper.c:        sp_mask = get_sp_mask(env->segs[R_SS].flags);
target-i386/op_helper.c:    ssp = env->segs[R_SS].base;
target-i386/op_helper.c:    cpl = env->hflags & HF_CPL_MASK;
target-i386/op_helper.c:    if (rpl == cpl && (!(env->hflags & HF_CS64_MASK) ||
target-i386/op_helper.c:                       ((env->hflags & HF_CS64_MASK) && !is_iret))) {
target-i386/op_helper.c:            if ((env->hflags & HF_LMA_MASK) && rpl != 3) {
target-i386/op_helper.c:        if (env->hflags & HF_CS64_MASK)
target-i386/op_helper.c:    env->eip = new_eip;
target-i386/op_helper.c:        iopl = (env->eflags >> IOPL_SHIFT) & 3;
target-i386/op_helper.c:    env->eip = new_eip & 0xffff;
target-i386/op_helper.c:    if (env->eflags & NT_MASK) {
target-i386/op_helper.c:        if (env->hflags & HF_LMA_MASK)
target-i386/op_helper.c:        tss_selector = lduw_kernel(env->tr.base + 0);
target-i386/op_helper.c:    env->hflags2 &= ~HF2_NMI_MASK;
target-i386/op_helper.c:    if (env->sysenter_cs == 0) {
target-i386/op_helper.c:    env->eflags &= ~(VM_MASK | IF_MASK | RF_MASK);
target-i386/op_helper.c:    if (env->hflags & HF_LMA_MASK) {
target-i386/op_helper.c:        cpu_x86_load_seg_cache(env, R_CS, env->sysenter_cs & 0xfffc,
target-i386/op_helper.c:        cpu_x86_load_seg_cache(env, R_CS, env->sysenter_cs & 0xfffc,
target-i386/op_helper.c:    cpu_x86_load_seg_cache(env, R_SS, (env->sysenter_cs + 8) & 0xfffc,
target-i386/op_helper.c:    ESP = env->sysenter_esp;
target-i386/op_helper.c:    EIP = env->sysenter_eip;
target-i386/op_helper.c:    cpl = env->hflags & HF_CPL_MASK;
target-i386/op_helper.c:    if (env->sysenter_cs == 0 || cpl != 0) {
target-i386/op_helper.c:        cpu_x86_load_seg_cache(env, R_CS, ((env->sysenter_cs + 32) & 0xfffc) | 3,
target-i386/op_helper.c:        cpu_x86_load_seg_cache(env, R_SS, ((env->sysenter_cs + 40) & 0xfffc) | 3,
target-i386/op_helper.c:        cpu_x86_load_seg_cache(env, R_CS, ((env->sysenter_cs + 16) & 0xfffc) | 3,
target-i386/op_helper.c:        cpu_x86_load_seg_cache(env, R_SS, ((env->sysenter_cs + 24) & 0xfffc) | 3,
target-i386/op_helper.c:        val = env->cr[reg];
target-i386/op_helper.c:        if (!(env->hflags2 & HF2_VINTR_MASK)) {
target-i386/op_helper.c:            val = cpu_get_apic_tpr(env->apic_state);
target-i386/op_helper.c:            val = env->v_tpr;
target-i386/op_helper.c:        if (!(env->hflags2 & HF2_VINTR_MASK)) {
target-i386/op_helper.c:            cpu_set_apic_tpr(env->apic_state, t0);
target-i386/op_helper.c:        env->v_tpr = t0 & 0x0f;
target-i386/op_helper.c:        env->cr[reg] = t0;
target-i386/op_helper.c:        env->dr[reg] = t0;
target-i386/op_helper.c:        env->dr[7] = t0;
target-i386/op_helper.c:        env->dr[reg] = t0;
target-i386/op_helper.c:    t0 = (env->cr[0] & ~0xe) | (t0 & 0xf);
target-i386/op_helper.c:    env->cr[0] &= ~CR0_TS_MASK;
target-i386/op_helper.c:    env->hflags &= ~HF_TS_MASK;
target-i386/op_helper.c:    if ((env->cr[4] & CR4_TSD_MASK) && ((env->hflags & HF_CPL_MASK) != 0)) {
target-i386/op_helper.c:    val = cpu_get_tsc(env) + env->tsc_offset;
target-i386/op_helper.c:    ECX = (uint32_t)(env->tsc_aux);
target-i386/op_helper.c:    if ((env->cr[4] & CR4_PCE_MASK) && ((env->hflags & HF_CPL_MASK) != 0)) {
target-i386/op_helper.c:        env->sysenter_cs = val & 0xffff;
target-i386/op_helper.c:        env->sysenter_esp = val;
target-i386/op_helper.c:        env->sysenter_eip = val;
target-i386/op_helper.c:        cpu_set_apic_base(env->apic_state, val);
target-i386/op_helper.c:            if (env->cpuid_ext2_features & CPUID_EXT2_SYSCALL)
target-i386/op_helper.c:            if (env->cpuid_ext2_features & CPUID_EXT2_LM)
target-i386/op_helper.c:            if (env->cpuid_ext2_features & CPUID_EXT2_FFXSR)
target-i386/op_helper.c:            if (env->cpuid_ext2_features & CPUID_EXT2_NX)
target-i386/op_helper.c:            if (env->cpuid_ext3_features & CPUID_EXT3_SVM)
target-i386/op_helper.c:            if (env->cpuid_ext2_features & CPUID_EXT2_FFXSR)
target-i386/op_helper.c:            cpu_load_efer(env, (env->efer & ~update_mask) |
target-i386/op_helper.c:        env->star = val;
target-i386/op_helper.c:        env->pat = val;
target-i386/op_helper.c:        env->vm_hsave = val;
target-i386/op_helper.c:        env->lstar = val;
target-i386/op_helper.c:        env->cstar = val;
target-i386/op_helper.c:        env->fmask = val;
target-i386/op_helper.c:        env->segs[R_FS].base = val;
target-i386/op_helper.c:        env->segs[R_GS].base = val;
target-i386/op_helper.c:        env->kernelgsbase = val;
target-i386/op_helper.c:        env->mtrr_var[((uint32_t)ECX - MSR_MTRRphysBase(0)) / 2].base = val;
target-i386/op_helper.c:        env->mtrr_var[((uint32_t)ECX - MSR_MTRRphysMask(0)) / 2].mask = val;
target-i386/op_helper.c:        env->mtrr_fixed[(uint32_t)ECX - MSR_MTRRfix64K_00000] = val;
target-i386/op_helper.c:        env->mtrr_fixed[(uint32_t)ECX - MSR_MTRRfix16K_80000 + 1] = val;
target-i386/op_helper.c:        env->mtrr_fixed[(uint32_t)ECX - MSR_MTRRfix4K_C0000 + 3] = val;
target-i386/op_helper.c:        env->mtrr_deftype = val;
target-i386/op_helper.c:        env->mcg_status = val;
target-i386/op_helper.c:        if ((env->mcg_cap & MCG_CTL_P)
target-i386/op_helper.c:            env->mcg_ctl = val;
target-i386/op_helper.c:        env->tsc_aux = val;
target-i386/op_helper.c:        env->msr_ia32_misc_enable = val;
target-i386/op_helper.c:            && (uint32_t)ECX < MSR_MC0_CTL + (4 * env->mcg_cap & 0xff)) {
target-i386/op_helper.c:                env->mce_banks[offset] = val;
target-i386/op_helper.c:        val = env->sysenter_cs;
target-i386/op_helper.c:        val = env->sysenter_esp;
target-i386/op_helper.c:        val = env->sysenter_eip;
target-i386/op_helper.c:        val = cpu_get_apic_base(env->apic_state);
target-i386/op_helper.c:        val = env->efer;
target-i386/op_helper.c:        val = env->star;
target-i386/op_helper.c:        val = env->pat;
target-i386/op_helper.c:        val = env->vm_hsave;
target-i386/op_helper.c:        val = env->lstar;
target-i386/op_helper.c:        val = env->cstar;
target-i386/op_helper.c:        val = env->fmask;
target-i386/op_helper.c:        val = env->segs[R_FS].base;
target-i386/op_helper.c:        val = env->segs[R_GS].base;
target-i386/op_helper.c:        val = env->kernelgsbase;
target-i386/op_helper.c:        val = env->tsc_aux;
target-i386/op_helper.c:        val = env->mtrr_var[((uint32_t)ECX - MSR_MTRRphysBase(0)) / 2].base;
target-i386/op_helper.c:        val = env->mtrr_var[((uint32_t)ECX - MSR_MTRRphysMask(0)) / 2].mask;
target-i386/op_helper.c:        val = env->mtrr_fixed[0];
target-i386/op_helper.c:        val = env->mtrr_fixed[(uint32_t)ECX - MSR_MTRRfix16K_80000 + 1];
target-i386/op_helper.c:        val = env->mtrr_fixed[(uint32_t)ECX - MSR_MTRRfix4K_C0000 + 3];
target-i386/op_helper.c:        val = env->mtrr_deftype;
target-i386/op_helper.c:        if (env->cpuid_features & CPUID_MTRR)
target-i386/op_helper.c:        val = env->mcg_cap;
target-i386/op_helper.c:        if (env->mcg_cap & MCG_CTL_P)
target-i386/op_helper.c:            val = env->mcg_ctl;
target-i386/op_helper.c:        val = env->mcg_status;
target-i386/op_helper.c:        val = env->msr_ia32_misc_enable;
target-i386/op_helper.c:            && (uint32_t)ECX < MSR_MC0_CTL + (4 * env->mcg_cap & 0xff)) {
target-i386/op_helper.c:            val = env->mce_banks[offset];
target-i386/op_helper.c:    cpl = env->hflags & HF_CPL_MASK;
target-i386/op_helper.c:    cpl = env->hflags & HF_CPL_MASK;
target-i386/op_helper.c:    cpl = env->hflags & HF_CPL_MASK;
target-i386/op_helper.c:    cpl = env->hflags & HF_CPL_MASK;
target-i386/op_helper.c:    u.f64 = floatx80_to_float64(a, &env->fp_status);
target-i386/op_helper.c:    return float64_to_floatx80(u.f64, &env->fp_status);
target-i386/op_helper.c:    env->fpus |= mask;
target-i386/op_helper.c:    if (env->fpus & (~env->fpuc & FPUC_EM))
target-i386/op_helper.c:        env->fpus |= FPUS_SE | FPUS_B;
target-i386/op_helper.c:    return floatx80_div(a, b, &env->fp_status);
target-i386/op_helper.c:    if (env->cr[0] & CR0_NE_MASK) {
target-i386/op_helper.c:    FT0 = float32_to_floatx80(u.f, &env->fp_status);
target-i386/op_helper.c:    FT0 = float64_to_floatx80(u.f, &env->fp_status);
target-i386/op_helper.c:    FT0 = int32_to_floatx80(val, &env->fp_status);
target-i386/op_helper.c:    new_fpstt = (env->fpstt - 1) & 7;
target-i386/op_helper.c:    env->fpregs[new_fpstt].d = float32_to_floatx80(u.f, &env->fp_status);
target-i386/op_helper.c:    env->fpstt = new_fpstt;
target-i386/op_helper.c:    env->fptags[new_fpstt] = 0; /* validate stack entry */
target-i386/op_helper.c:    new_fpstt = (env->fpstt - 1) & 7;
target-i386/op_helper.c:    env->fpregs[new_fpstt].d = float64_to_floatx80(u.f, &env->fp_status);
target-i386/op_helper.c:    env->fpstt = new_fpstt;
target-i386/op_helper.c:    env->fptags[new_fpstt] = 0; /* validate stack entry */
target-i386/op_helper.c:    new_fpstt = (env->fpstt - 1) & 7;
target-i386/op_helper.c:    env->fpregs[new_fpstt].d = int32_to_floatx80(val, &env->fp_status);
target-i386/op_helper.c:    env->fpstt = new_fpstt;
target-i386/op_helper.c:    env->fptags[new_fpstt] = 0; /* validate stack entry */
target-i386/op_helper.c:    new_fpstt = (env->fpstt - 1) & 7;
target-i386/op_helper.c:    env->fpregs[new_fpstt].d = int64_to_floatx80(val, &env->fp_status);
target-i386/op_helper.c:    env->fpstt = new_fpstt;
target-i386/op_helper.c:    env->fptags[new_fpstt] = 0; /* validate stack entry */
target-i386/op_helper.c:    u.f = floatx80_to_float32(ST0, &env->fp_status);
target-i386/op_helper.c:    u.f = floatx80_to_float64(ST0, &env->fp_status);
target-i386/op_helper.c:    val = floatx80_to_int32(ST0, &env->fp_status);
target-i386/op_helper.c:    val = floatx80_to_int32(ST0, &env->fp_status);
target-i386/op_helper.c:    val = floatx80_to_int64(ST0, &env->fp_status);
target-i386/op_helper.c:    val = floatx80_to_int32_round_to_zero(ST0, &env->fp_status);
target-i386/op_helper.c:    val = floatx80_to_int32_round_to_zero(ST0, &env->fp_status);
target-i386/op_helper.c:    val = floatx80_to_int64_round_to_zero(ST0, &env->fp_status);
target-i386/op_helper.c:    new_fpstt = (env->fpstt - 1) & 7;
target-i386/op_helper.c:    env->fpregs[new_fpstt].d = helper_fldt(ptr);
target-i386/op_helper.c:    env->fpstt = new_fpstt;
target-i386/op_helper.c:    env->fptags[new_fpstt] = 0; /* validate stack entry */
target-i386/op_helper.c:    env->fpstt = (env->fpstt - 1) & 7;
target-i386/op_helper.c:    env->fpus &= (~0x4700);
target-i386/op_helper.c:    env->fpstt = (env->fpstt + 1) & 7;
target-i386/op_helper.c:    env->fpus &= (~0x4700);
target-i386/op_helper.c:    env->fptags[(env->fpstt + st_index) & 7] = 1;
target-i386/op_helper.c:    ret = floatx80_compare(ST0, FT0, &env->fp_status);
target-i386/op_helper.c:    env->fpus = (env->fpus & ~0x4500) | fcom_ccval[ret + 1];
target-i386/op_helper.c:    ret = floatx80_compare_quiet(ST0, FT0, &env->fp_status);
target-i386/op_helper.c:    env->fpus = (env->fpus & ~0x4500) | fcom_ccval[ret+ 1];
target-i386/op_helper.c:    ret = floatx80_compare(ST0, FT0, &env->fp_status);
target-i386/op_helper.c:    ret = floatx80_compare_quiet(ST0, FT0, &env->fp_status);
target-i386/op_helper.c:    ST0 = floatx80_add(ST0, FT0, &env->fp_status);
target-i386/op_helper.c:    ST0 = floatx80_mul(ST0, FT0, &env->fp_status);
target-i386/op_helper.c:    ST0 = floatx80_sub(ST0, FT0, &env->fp_status);
target-i386/op_helper.c:    ST0 = floatx80_sub(FT0, ST0, &env->fp_status);
target-i386/op_helper.c:    ST(st_index) = floatx80_add(ST(st_index), ST0, &env->fp_status);
target-i386/op_helper.c:    ST(st_index) = floatx80_mul(ST(st_index), ST0, &env->fp_status);
target-i386/op_helper.c:    ST(st_index) = floatx80_sub(ST(st_index), ST0, &env->fp_status);
target-i386/op_helper.c:    ST(st_index) = floatx80_sub(ST0, ST(st_index), &env->fp_status);
target-i386/op_helper.c:    return (env->fpus & ~0x3800) | (env->fpstt & 0x7) << 11;
target-i386/op_helper.c:    return env->fpuc;
target-i386/op_helper.c:    switch(env->fpuc & FPU_RC_MASK) {
target-i386/op_helper.c:    set_float_rounding_mode(rnd_type, &env->fp_status);
target-i386/op_helper.c:    switch((env->fpuc >> 8) & 3) {
target-i386/op_helper.c:    set_floatx80_rounding_precision(rnd_type, &env->fp_status);
target-i386/op_helper.c:    env->fpuc = val;
target-i386/op_helper.c:    env->fpus &= 0x7f00;
target-i386/op_helper.c:    if (env->fpus & FPUS_SE)
target-i386/op_helper.c:    env->fpus = 0;
target-i386/op_helper.c:    env->fpstt = 0;
target-i386/op_helper.c:    env->fpuc = 0x37f;
target-i386/op_helper.c:    env->fptags[0] = 1;
target-i386/op_helper.c:    env->fptags[1] = 1;
target-i386/op_helper.c:    env->fptags[2] = 1;
target-i386/op_helper.c:    env->fptags[3] = 1;
target-i386/op_helper.c:    env->fptags[4] = 1;
target-i386/op_helper.c:    env->fptags[5] = 1;
target-i386/op_helper.c:    env->fptags[6] = 1;
target-i386/op_helper.c:    env->fptags[7] = 1;
target-i386/op_helper.c:    tmp = int64_to_floatx80(val, &env->fp_status);
target-i386/op_helper.c:    val = floatx80_to_int64(ST0, &env->fp_status);
target-i386/op_helper.c:        env->fpus &= (~0x4700);
target-i386/op_helper.c:        env->fpus |= 0x400;
target-i386/op_helper.c:        env->fpus |= 0x400;
target-i386/op_helper.c:        env->fpus &= (~0x400);  /* C2 <-- 0 */
target-i386/op_helper.c:        ST0 = floatx80_div(floatx80_chs(floatx80_one), floatx80_zero, &env->fp_status);
target-i386/op_helper.c:        ST0 = int32_to_floatx80(expdif, &env->fp_status);
target-i386/op_helper.c:        env->fpus &= (~0x4700); /* (C3,C2,C1,C0) <-- 0000 */
target-i386/op_helper.c:        env->fpus &= (~0x4700); /* (C3,C2,C1,C0) <-- 0000 */
target-i386/op_helper.c:        env->fpus &= (~0x4700); /* (C3,C2,C1,C0) <-- 0000 */
target-i386/op_helper.c:        env->fpus |= (q & 0x4) << (8 - 2);  /* (C0) <-- q2 */
target-i386/op_helper.c:        env->fpus |= (q & 0x2) << (14 - 1); /* (C3) <-- q1 */
target-i386/op_helper.c:        env->fpus |= (q & 0x1) << (9 - 0);  /* (C1) <-- q0 */
target-i386/op_helper.c:        env->fpus |= 0x400;  /* C2 <-- 1 */
target-i386/op_helper.c:       env->fpus &= (~0x4700); /* (C3,C2,C1,C0) <-- 0000 */
target-i386/op_helper.c:        env->fpus &= (~0x4700); /* (C3,C2,C1,C0) <-- 0000 */
target-i386/op_helper.c:        env->fpus &= (~0x4700); /* (C3,C2,C1,C0) <-- 0000 */
target-i386/op_helper.c:        env->fpus |= (q & 0x4) << (8 - 2);  /* (C0) <-- q2 */
target-i386/op_helper.c:        env->fpus |= (q & 0x2) << (14 - 1); /* (C3) <-- q1 */
target-i386/op_helper.c:        env->fpus |= (q & 0x1) << (9 - 0);  /* (C1) <-- q0 */
target-i386/op_helper.c:        env->fpus |= 0x400;  /* C2 <-- 1 */
target-i386/op_helper.c:        env->fpus &= (~0x4700);
target-i386/op_helper.c:        env->fpus |= 0x400;
target-i386/op_helper.c:        env->fpus &= (~0x4700);  /* (C3,C2,C1,C0) <-- 0000 */
target-i386/op_helper.c:        env->fpus |= 0x400;
target-i386/op_helper.c:    ST0 = floatx80_sqrt(ST0, &env->fp_status);
target-i386/op_helper.c:        env->fpus |= 0x400;
target-i386/op_helper.c:        env->fpus &= (~0x400);  /* C2 <-- 0 */
target-i386/op_helper.c:    ST0 = floatx80_round_to_int(ST0, &env->fp_status);
target-i386/op_helper.c:        int n = floatx80_to_int32_round_to_zero(ST1, &env->fp_status);
target-i386/op_helper.c:        ST0 = floatx80_scalbn(ST0, n, &env->fp_status);
target-i386/op_helper.c:        env->fpus |= 0x400;
target-i386/op_helper.c:        env->fpus &= (~0x400);  /* C2 <-- 0 */
target-i386/op_helper.c:        env->fpus |= 0x400;
target-i386/op_helper.c:        env->fpus &= (~0x400);  /* C2 <-- 0 */
target-i386/op_helper.c:    env->fpus &= (~0x4700);  /* (C3,C2,C1,C0) <-- 0000 */
target-i386/op_helper.c:        env->fpus |= 0x200; /* C1 <-- 1 */
target-i386/op_helper.c:            env->fpus |=  0x500 /*Infinity*/;
target-i386/op_helper.c:            env->fpus |=  0x100 /*NaN*/;
target-i386/op_helper.c:            env->fpus |=  0x4000 /*Zero*/;
target-i386/op_helper.c:            env->fpus |= 0x4400 /*Denormal*/;
target-i386/op_helper.c:        env->fpus |= 0x400;
target-i386/op_helper.c:    fpus = (env->fpus & ~0x3800) | (env->fpstt & 0x7) << 11;
target-i386/op_helper.c:	if (env->fptags[i]) {
target-i386/op_helper.c:            tmp.d = env->fpregs[i].d;
target-i386/op_helper.c:        stl(ptr, env->fpuc);
target-i386/op_helper.c:        stw(ptr, env->fpuc);
target-i386/op_helper.c:	env->fpuc = lduw(ptr);
target-i386/op_helper.c:	env->fpuc = lduw(ptr);
target-i386/op_helper.c:    env->fpstt = (fpus >> 11) & 7;
target-i386/op_helper.c:    env->fpus = fpus & ~0x3800;
target-i386/op_helper.c:        env->fptags[i] = ((fptag & 3) == 3);
target-i386/op_helper.c:    env->fpus = 0;
target-i386/op_helper.c:    env->fpstt = 0;
target-i386/op_helper.c:    env->fpuc = 0x37f;
target-i386/op_helper.c:    env->fptags[0] = 1;
target-i386/op_helper.c:    env->fptags[1] = 1;
target-i386/op_helper.c:    env->fptags[2] = 1;
target-i386/op_helper.c:    env->fptags[3] = 1;
target-i386/op_helper.c:    env->fptags[4] = 1;
target-i386/op_helper.c:    env->fptags[5] = 1;
target-i386/op_helper.c:    env->fptags[6] = 1;
target-i386/op_helper.c:    env->fptags[7] = 1;
target-i386/op_helper.c:    if (!(env->cr[0] & CR0_PE_MASK) || (env->eflags & VM_MASK)) {
target-i386/op_helper.c:    fpus = (env->fpus & ~0x3800) | (env->fpstt & 0x7) << 11;
target-i386/op_helper.c:        fptag |= (env->fptags[i] << i);
target-i386/op_helper.c:    stw(ptr, env->fpuc);
target-i386/op_helper.c:    if (env->cr[4] & CR4_OSFXSR_MASK) {
target-i386/op_helper.c:        stl(ptr + 0x18, env->mxcsr); /* mxcsr */
target-i386/op_helper.c:        if (env->hflags & HF_CS64_MASK)
target-i386/op_helper.c:        if (!(env->efer & MSR_EFER_FFXSR)
target-i386/op_helper.c:          || (env->hflags & HF_CPL_MASK)
target-i386/op_helper.c:          || !(env->hflags & HF_LMA_MASK)) {
target-i386/op_helper.c:                stq(addr, env->xmm_regs[i].XMM_Q(0));
target-i386/op_helper.c:                stq(addr + 8, env->xmm_regs[i].XMM_Q(1));
target-i386/op_helper.c:    env->fpuc = lduw(ptr);
target-i386/op_helper.c:    env->fpstt = (fpus >> 11) & 7;
target-i386/op_helper.c:    env->fpus = fpus & ~0x3800;
target-i386/op_helper.c:        env->fptags[i] = ((fptag >> i) & 1);
target-i386/op_helper.c:    if (env->cr[4] & CR4_OSFXSR_MASK) {
target-i386/op_helper.c:        env->mxcsr = ldl(ptr + 0x18);
target-i386/op_helper.c:        if (env->hflags & HF_CS64_MASK)
target-i386/op_helper.c:        if (!(env->efer & MSR_EFER_FFXSR)
target-i386/op_helper.c:          || (env->hflags & HF_CPL_MASK)
target-i386/op_helper.c:          || !(env->hflags & HF_LMA_MASK)) {
target-i386/op_helper.c:                env->xmm_regs[i].XMM_Q(0) = ldq(addr);
target-i386/op_helper.c:                env->xmm_regs[i].XMM_Q(1) = ldq(addr + 8);
target-i386/op_helper.c:    env->hflags &= ~HF_INHIBIT_IRQ_MASK; /* needed if sti is just before */
target-i386/op_helper.c:    env->halted = 1;
target-i386/op_helper.c:    env->exception_index = EXCP_HLT;
target-i386/op_helper.c:    if (env->cpu_index != 0 || env->next_cpu != NULL) {
target-i386/op_helper.c:    env->exception_index = EXCP_DEBUG;
target-i386/op_helper.c:    env->eflags &= ~RF_MASK;
target-i386/op_helper.c:    env->eflags &= ~IF_MASK;
target-i386/op_helper.c:    env->eflags |= IF_MASK;
target-i386/op_helper.c:    env->eflags &= ~VIF_MASK;
target-i386/op_helper.c:    env->eflags |= VIF_MASK;
target-i386/op_helper.c:    if (env->eflags & VIP_MASK) {
target-i386/op_helper.c:    env->hflags |= HF_INHIBIT_IRQ_MASK;
target-i386/op_helper.c:    env->hflags &= ~HF_INHIBIT_IRQ_MASK;
target-i386/op_helper.c:        raise_exception_err(env->exception_index, env->error_code);
target-i386/op_helper.c:    env->vm_vmcb = addr;
target-i386/op_helper.c:    stq_phys(env->vm_hsave + offsetof(struct vmcb, save.gdtr.base), env->gdt.base);
target-i386/op_helper.c:    stl_phys(env->vm_hsave + offsetof(struct vmcb, save.gdtr.limit), env->gdt.limit);
target-i386/op_helper.c:    stq_phys(env->vm_hsave + offsetof(struct vmcb, save.idtr.base), env->idt.base);
target-i386/op_helper.c:    stl_phys(env->vm_hsave + offsetof(struct vmcb, save.idtr.limit), env->idt.limit);
target-i386/op_helper.c:    stq_phys(env->vm_hsave + offsetof(struct vmcb, save.cr0), env->cr[0]);
target-i386/op_helper.c:    stq_phys(env->vm_hsave + offsetof(struct vmcb, save.cr2), env->cr[2]);
target-i386/op_helper.c:    stq_phys(env->vm_hsave + offsetof(struct vmcb, save.cr3), env->cr[3]);
target-i386/op_helper.c:    stq_phys(env->vm_hsave + offsetof(struct vmcb, save.cr4), env->cr[4]);
target-i386/op_helper.c:    stq_phys(env->vm_hsave + offsetof(struct vmcb, save.dr6), env->dr[6]);
target-i386/op_helper.c:    stq_phys(env->vm_hsave + offsetof(struct vmcb, save.dr7), env->dr[7]);
target-i386/op_helper.c:    stq_phys(env->vm_hsave + offsetof(struct vmcb, save.efer), env->efer);
target-i386/op_helper.c:    stq_phys(env->vm_hsave + offsetof(struct vmcb, save.rflags), compute_eflags());
target-i386/op_helper.c:    svm_save_seg(env->vm_hsave + offsetof(struct vmcb, save.es), 
target-i386/op_helper.c:                  &env->segs[R_ES]);
target-i386/op_helper.c:    svm_save_seg(env->vm_hsave + offsetof(struct vmcb, save.cs), 
target-i386/op_helper.c:                 &env->segs[R_CS]);
target-i386/op_helper.c:    svm_save_seg(env->vm_hsave + offsetof(struct vmcb, save.ss), 
target-i386/op_helper.c:                 &env->segs[R_SS]);
target-i386/op_helper.c:    svm_save_seg(env->vm_hsave + offsetof(struct vmcb, save.ds), 
target-i386/op_helper.c:                 &env->segs[R_DS]);
target-i386/op_helper.c:    stq_phys(env->vm_hsave + offsetof(struct vmcb, save.rip),
target-i386/op_helper.c:    stq_phys(env->vm_hsave + offsetof(struct vmcb, save.rsp), ESP);
target-i386/op_helper.c:    stq_phys(env->vm_hsave + offsetof(struct vmcb, save.rax), EAX);
target-i386/op_helper.c:    env->intercept            = ldq_phys(env->vm_vmcb + offsetof(struct vmcb, control.intercept));
target-i386/op_helper.c:    env->intercept_cr_read    = lduw_phys(env->vm_vmcb + offsetof(struct vmcb, control.intercept_cr_read));
target-i386/op_helper.c:    env->intercept_cr_write   = lduw_phys(env->vm_vmcb + offsetof(struct vmcb, control.intercept_cr_write));
target-i386/op_helper.c:    env->intercept_dr_read    = lduw_phys(env->vm_vmcb + offsetof(struct vmcb, control.intercept_dr_read));
target-i386/op_helper.c:    env->intercept_dr_write   = lduw_phys(env->vm_vmcb + offsetof(struct vmcb, control.intercept_dr_write));
target-i386/op_helper.c:    env->intercept_exceptions = ldl_phys(env->vm_vmcb + offsetof(struct vmcb, control.intercept_exceptions));
target-i386/op_helper.c:    env->hflags |= HF_SVMI_MASK;
target-i386/op_helper.c:    env->tsc_offset = ldq_phys(env->vm_vmcb + offsetof(struct vmcb, control.tsc_offset));
target-i386/op_helper.c:    env->gdt.base  = ldq_phys(env->vm_vmcb + offsetof(struct vmcb, save.gdtr.base));
target-i386/op_helper.c:    env->gdt.limit = ldl_phys(env->vm_vmcb + offsetof(struct vmcb, save.gdtr.limit));
target-i386/op_helper.c:    env->idt.base  = ldq_phys(env->vm_vmcb + offsetof(struct vmcb, save.idtr.base));
target-i386/op_helper.c:    env->idt.limit = ldl_phys(env->vm_vmcb + offsetof(struct vmcb, save.idtr.limit));
target-i386/op_helper.c:    stq_phys(env->vm_vmcb + offsetof(struct vmcb, control.exit_info_2), 0);
target-i386/op_helper.c:    cpu_x86_update_cr0(env, ldq_phys(env->vm_vmcb + offsetof(struct vmcb, save.cr0)));
target-i386/op_helper.c:    cpu_x86_update_cr4(env, ldq_phys(env->vm_vmcb + offsetof(struct vmcb, save.cr4)));
target-i386/op_helper.c:    cpu_x86_update_cr3(env, ldq_phys(env->vm_vmcb + offsetof(struct vmcb, save.cr3)));
target-i386/op_helper.c:    env->cr[2] = ldq_phys(env->vm_vmcb + offsetof(struct vmcb, save.cr2));
target-i386/op_helper.c:    int_ctl = ldl_phys(env->vm_vmcb + offsetof(struct vmcb, control.int_ctl));
target-i386/op_helper.c:    env->hflags2 &= ~(HF2_HIF_MASK | HF2_VINTR_MASK);
target-i386/op_helper.c:        env->v_tpr = int_ctl & V_TPR_MASK;
target-i386/op_helper.c:        env->hflags2 |= HF2_VINTR_MASK;
target-i386/op_helper.c:        if (env->eflags & IF_MASK)
target-i386/op_helper.c:            env->hflags2 |= HF2_HIF_MASK;
target-i386/op_helper.c:                  ldq_phys(env->vm_vmcb + offsetof(struct vmcb, save.efer)));
target-i386/op_helper.c:    env->eflags = 0;
target-i386/op_helper.c:    load_eflags(ldq_phys(env->vm_vmcb + offsetof(struct vmcb, save.rflags)),
target-i386/op_helper.c:    svm_load_seg_cache(env->vm_vmcb + offsetof(struct vmcb, save.es),
target-i386/op_helper.c:    svm_load_seg_cache(env->vm_vmcb + offsetof(struct vmcb, save.cs),
target-i386/op_helper.c:    svm_load_seg_cache(env->vm_vmcb + offsetof(struct vmcb, save.ss),
target-i386/op_helper.c:    svm_load_seg_cache(env->vm_vmcb + offsetof(struct vmcb, save.ds),
target-i386/op_helper.c:    EIP = ldq_phys(env->vm_vmcb + offsetof(struct vmcb, save.rip));
target-i386/op_helper.c:    env->eip = EIP;
target-i386/op_helper.c:    ESP = ldq_phys(env->vm_vmcb + offsetof(struct vmcb, save.rsp));
target-i386/op_helper.c:    EAX = ldq_phys(env->vm_vmcb + offsetof(struct vmcb, save.rax));
target-i386/op_helper.c:    env->dr[7] = ldq_phys(env->vm_vmcb + offsetof(struct vmcb, save.dr7));
target-i386/op_helper.c:    env->dr[6] = ldq_phys(env->vm_vmcb + offsetof(struct vmcb, save.dr6));
target-i386/op_helper.c:    cpu_x86_set_cpl(env, ldub_phys(env->vm_vmcb + offsetof(struct vmcb, save.cpl)));
target-i386/op_helper.c:    switch(ldub_phys(env->vm_vmcb + offsetof(struct vmcb, control.tlb_ctl))) {
target-i386/op_helper.c:    env->hflags2 |= HF2_GIF_MASK;
target-i386/op_helper.c:        env->interrupt_request |= CPU_INTERRUPT_VIRQ;
target-i386/op_helper.c:    event_inj = ldl_phys(env->vm_vmcb + offsetof(struct vmcb, control.event_inj));
target-i386/op_helper.c:        uint32_t event_inj_err = ldl_phys(env->vm_vmcb + offsetof(struct vmcb, control.event_inj_err));
target-i386/op_helper.c:                env->exception_index = vector;
target-i386/op_helper.c:                env->error_code = event_inj_err;
target-i386/op_helper.c:                env->exception_is_int = 0;
target-i386/op_helper.c:                env->exception_next_eip = -1;
target-i386/op_helper.c:                env->exception_index = EXCP02_NMI;
target-i386/op_helper.c:                env->error_code = event_inj_err;
target-i386/op_helper.c:                env->exception_is_int = 0;
target-i386/op_helper.c:                env->exception_next_eip = EIP;
target-i386/op_helper.c:                env->exception_index = vector;
target-i386/op_helper.c:                env->error_code = event_inj_err;
target-i386/op_helper.c:                env->exception_is_int = 0;
target-i386/op_helper.c:                env->exception_next_eip = -1;
target-i386/op_helper.c:                env->exception_index = vector;
target-i386/op_helper.c:                env->error_code = event_inj_err;
target-i386/op_helper.c:                env->exception_is_int = 1;
target-i386/op_helper.c:                env->exception_next_eip = EIP;
target-i386/op_helper.c:        qemu_log_mask(CPU_LOG_TB_IN_ASM, " %#x %#x\n", env->exception_index, env->error_code);
target-i386/op_helper.c:                env->segs[R_FS].base);
target-i386/op_helper.c:                 &env->tr);
target-i386/op_helper.c:                 &env->ldt);
target-i386/op_helper.c:    env->kernelgsbase = ldq_phys(addr + offsetof(struct vmcb, save.kernel_gs_base));
target-i386/op_helper.c:    env->lstar = ldq_phys(addr + offsetof(struct vmcb, save.lstar));
target-i386/op_helper.c:    env->cstar = ldq_phys(addr + offsetof(struct vmcb, save.cstar));
target-i386/op_helper.c:    env->fmask = ldq_phys(addr + offsetof(struct vmcb, save.sfmask));
target-i386/op_helper.c:    env->star = ldq_phys(addr + offsetof(struct vmcb, save.star));
target-i386/op_helper.c:    env->sysenter_cs = ldq_phys(addr + offsetof(struct vmcb, save.sysenter_cs));
target-i386/op_helper.c:    env->sysenter_esp = ldq_phys(addr + offsetof(struct vmcb, save.sysenter_esp));
target-i386/op_helper.c:    env->sysenter_eip = ldq_phys(addr + offsetof(struct vmcb, save.sysenter_eip));
target-i386/op_helper.c:                env->segs[R_FS].base);
target-i386/op_helper.c:                 &env->segs[R_FS]);
target-i386/op_helper.c:                 &env->segs[R_GS]);
target-i386/op_helper.c:                 &env->tr);
target-i386/op_helper.c:                 &env->ldt);
target-i386/op_helper.c:    stq_phys(addr + offsetof(struct vmcb, save.kernel_gs_base), env->kernelgsbase);
target-i386/op_helper.c:    stq_phys(addr + offsetof(struct vmcb, save.lstar), env->lstar);
target-i386/op_helper.c:    stq_phys(addr + offsetof(struct vmcb, save.cstar), env->cstar);
target-i386/op_helper.c:    stq_phys(addr + offsetof(struct vmcb, save.sfmask), env->fmask);
target-i386/op_helper.c:    stq_phys(addr + offsetof(struct vmcb, save.star), env->star);
target-i386/op_helper.c:    stq_phys(addr + offsetof(struct vmcb, save.sysenter_cs), env->sysenter_cs);
target-i386/op_helper.c:    stq_phys(addr + offsetof(struct vmcb, save.sysenter_esp), env->sysenter_esp);
target-i386/op_helper.c:    stq_phys(addr + offsetof(struct vmcb, save.sysenter_eip), env->sysenter_eip);
target-i386/op_helper.c:    env->hflags2 |= HF2_GIF_MASK;
target-i386/op_helper.c:    env->hflags2 &= ~HF2_GIF_MASK;
target-i386/op_helper.c:    if (likely(!(env->hflags & HF_SVMI_MASK)))
target-i386/op_helper.c:        if (env->intercept_cr_read & (1 << (type - SVM_EXIT_READ_CR0))) {
target-i386/op_helper.c:        if (env->intercept_cr_write & (1 << (type - SVM_EXIT_WRITE_CR0))) {
target-i386/op_helper.c:        if (env->intercept_dr_read & (1 << (type - SVM_EXIT_READ_DR0))) {
target-i386/op_helper.c:        if (env->intercept_dr_write & (1 << (type - SVM_EXIT_WRITE_DR0))) {
target-i386/op_helper.c:        if (env->intercept_exceptions & (1 << (type - SVM_EXIT_EXCP_BASE))) {
target-i386/op_helper.c:        if (env->intercept & (1ULL << (SVM_EXIT_MSR - SVM_EXIT_INTR))) {
target-i386/op_helper.c:            uint64_t addr = ldq_phys(env->vm_vmcb + offsetof(struct vmcb, control.msrpm_base_pa));
target-i386/op_helper.c:        if (env->intercept & (1ULL << (type - SVM_EXIT_INTR))) {
target-i386/op_helper.c:    if (env->intercept & (1ULL << (SVM_EXIT_IOIO - SVM_EXIT_INTR))) {
target-i386/op_helper.c:        uint64_t addr = ldq_phys(env->vm_vmcb + offsetof(struct vmcb, control.iopm_base_pa));
target-i386/op_helper.c:            stq_phys(env->vm_vmcb + offsetof(struct vmcb, control.exit_info_2), 
target-i386/op_helper.c:                     env->eip + next_eip_addend);
target-i386/op_helper.c:                ldq_phys(env->vm_vmcb + offsetof(struct vmcb, control.exit_info_2)),
target-i386/op_helper.c:    if(env->hflags & HF_INHIBIT_IRQ_MASK) {
target-i386/op_helper.c:        stl_phys(env->vm_vmcb + offsetof(struct vmcb, control.int_state), SVM_INTERRUPT_SHADOW_MASK);
target-i386/op_helper.c:        env->hflags &= ~HF_INHIBIT_IRQ_MASK;
target-i386/op_helper.c:        stl_phys(env->vm_vmcb + offsetof(struct vmcb, control.int_state), 0);
target-i386/op_helper.c:    svm_save_seg(env->vm_vmcb + offsetof(struct vmcb, save.es), 
target-i386/op_helper.c:                 &env->segs[R_ES]);
target-i386/op_helper.c:    svm_save_seg(env->vm_vmcb + offsetof(struct vmcb, save.cs), 
target-i386/op_helper.c:                 &env->segs[R_CS]);
target-i386/op_helper.c:    svm_save_seg(env->vm_vmcb + offsetof(struct vmcb, save.ss), 
target-i386/op_helper.c:                 &env->segs[R_SS]);
target-i386/op_helper.c:    svm_save_seg(env->vm_vmcb + offsetof(struct vmcb, save.ds), 
target-i386/op_helper.c:                 &env->segs[R_DS]);
target-i386/op_helper.c:    stq_phys(env->vm_vmcb + offsetof(struct vmcb, save.gdtr.base), env->gdt.base);
target-i386/op_helper.c:    stl_phys(env->vm_vmcb + offsetof(struct vmcb, save.gdtr.limit), env->gdt.limit);
target-i386/op_helper.c:    stq_phys(env->vm_vmcb + offsetof(struct vmcb, save.idtr.base), env->idt.base);
target-i386/op_helper.c:    stl_phys(env->vm_vmcb + offsetof(struct vmcb, save.idtr.limit), env->idt.limit);
target-i386/op_helper.c:    stq_phys(env->vm_vmcb + offsetof(struct vmcb, save.efer), env->efer);
target-i386/op_helper.c:    stq_phys(env->vm_vmcb + offsetof(struct vmcb, save.cr0), env->cr[0]);
target-i386/op_helper.c:    stq_phys(env->vm_vmcb + offsetof(struct vmcb, save.cr2), env->cr[2]);
target-i386/op_helper.c:    stq_phys(env->vm_vmcb + offsetof(struct vmcb, save.cr3), env->cr[3]);
target-i386/op_helper.c:    stq_phys(env->vm_vmcb + offsetof(struct vmcb, save.cr4), env->cr[4]);
target-i386/op_helper.c:    int_ctl = ldl_phys(env->vm_vmcb + offsetof(struct vmcb, control.int_ctl));
target-i386/op_helper.c:    int_ctl |= env->v_tpr & V_TPR_MASK;
target-i386/op_helper.c:    if (env->interrupt_request & CPU_INTERRUPT_VIRQ)
target-i386/op_helper.c:    stl_phys(env->vm_vmcb + offsetof(struct vmcb, control.int_ctl), int_ctl);
target-i386/op_helper.c:    stq_phys(env->vm_vmcb + offsetof(struct vmcb, save.rflags), compute_eflags());
target-i386/op_helper.c:    stq_phys(env->vm_vmcb + offsetof(struct vmcb, save.rip), env->eip);
target-i386/op_helper.c:    stq_phys(env->vm_vmcb + offsetof(struct vmcb, save.rsp), ESP);
target-i386/op_helper.c:    stq_phys(env->vm_vmcb + offsetof(struct vmcb, save.rax), EAX);
target-i386/op_helper.c:    stq_phys(env->vm_vmcb + offsetof(struct vmcb, save.dr7), env->dr[7]);
target-i386/op_helper.c:    stq_phys(env->vm_vmcb + offsetof(struct vmcb, save.dr6), env->dr[6]);
target-i386/op_helper.c:    stb_phys(env->vm_vmcb + offsetof(struct vmcb, save.cpl), env->hflags & HF_CPL_MASK);
target-i386/op_helper.c:    env->hflags2 &= ~(HF2_HIF_MASK | HF2_VINTR_MASK);
target-i386/op_helper.c:    env->hflags &= ~HF_SVMI_MASK;
target-i386/op_helper.c:    env->intercept = 0;
target-i386/op_helper.c:    env->intercept_exceptions = 0;
target-i386/op_helper.c:    env->interrupt_request &= ~CPU_INTERRUPT_VIRQ;
target-i386/op_helper.c:    env->tsc_offset = 0;
target-i386/op_helper.c:    env->gdt.base  = ldq_phys(env->vm_hsave + offsetof(struct vmcb, save.gdtr.base));
target-i386/op_helper.c:    env->gdt.limit = ldl_phys(env->vm_hsave + offsetof(struct vmcb, save.gdtr.limit));
target-i386/op_helper.c:    env->idt.base  = ldq_phys(env->vm_hsave + offsetof(struct vmcb, save.idtr.base));
target-i386/op_helper.c:    env->idt.limit = ldl_phys(env->vm_hsave + offsetof(struct vmcb, save.idtr.limit));
target-i386/op_helper.c:    cpu_x86_update_cr0(env, ldq_phys(env->vm_hsave + offsetof(struct vmcb, save.cr0)) | CR0_PE_MASK);
target-i386/op_helper.c:    cpu_x86_update_cr4(env, ldq_phys(env->vm_hsave + offsetof(struct vmcb, save.cr4)));
target-i386/op_helper.c:    cpu_x86_update_cr3(env, ldq_phys(env->vm_hsave + offsetof(struct vmcb, save.cr3)));
target-i386/op_helper.c:                  ldq_phys(env->vm_hsave + offsetof(struct vmcb, save.efer)));
target-i386/op_helper.c:    env->eflags = 0;
target-i386/op_helper.c:    load_eflags(ldq_phys(env->vm_hsave + offsetof(struct vmcb, save.rflags)),
target-i386/op_helper.c:    svm_load_seg_cache(env->vm_hsave + offsetof(struct vmcb, save.es),
target-i386/op_helper.c:    svm_load_seg_cache(env->vm_hsave + offsetof(struct vmcb, save.cs),
target-i386/op_helper.c:    svm_load_seg_cache(env->vm_hsave + offsetof(struct vmcb, save.ss),
target-i386/op_helper.c:    svm_load_seg_cache(env->vm_hsave + offsetof(struct vmcb, save.ds),
target-i386/op_helper.c:    EIP = ldq_phys(env->vm_hsave + offsetof(struct vmcb, save.rip));
target-i386/op_helper.c:    ESP = ldq_phys(env->vm_hsave + offsetof(struct vmcb, save.rsp));
target-i386/op_helper.c:    EAX = ldq_phys(env->vm_hsave + offsetof(struct vmcb, save.rax));
target-i386/op_helper.c:    env->dr[6] = ldq_phys(env->vm_hsave + offsetof(struct vmcb, save.dr6));
target-i386/op_helper.c:    env->dr[7] = ldq_phys(env->vm_hsave + offsetof(struct vmcb, save.dr7));
target-i386/op_helper.c:    stq_phys(env->vm_vmcb + offsetof(struct vmcb, control.exit_code), exit_code);
target-i386/op_helper.c:    stq_phys(env->vm_vmcb + offsetof(struct vmcb, control.exit_info_1), exit_info_1);
target-i386/op_helper.c:    stl_phys(env->vm_vmcb + offsetof(struct vmcb, control.exit_int_info),
target-i386/op_helper.c:             ldl_phys(env->vm_vmcb + offsetof(struct vmcb, control.event_inj)));
target-i386/op_helper.c:    stl_phys(env->vm_vmcb + offsetof(struct vmcb, control.exit_int_info_err),
target-i386/op_helper.c:             ldl_phys(env->vm_vmcb + offsetof(struct vmcb, control.event_inj_err)));
target-i386/op_helper.c:    stl_phys(env->vm_vmcb + offsetof(struct vmcb, control.event_inj), 0);
target-i386/op_helper.c:    env->hflags2 &= ~HF2_GIF_MASK;
target-i386/op_helper.c:    env->cr[0] |= CR0_PE_MASK;
target-i386/op_helper.c:    env->eflags &= ~VM_MASK;
target-i386/op_helper.c:    env->exception_index = -1;
target-i386/op_helper.c:    env->error_code = 0;
target-i386/op_helper.c:    env->old_exception = -1;
target-i386/op_helper.c:    switch(env->mxcsr & SSE_RC_MASK) {
target-i386/op_helper.c:    set_float_rounding_mode(rnd_type, &env->sse_status);
target-i386/op_helper.c:    set_flush_inputs_to_zero((env->mxcsr & SSE_DAZ) ? 1 : 0, &env->sse_status);
target-i386/op_helper.c:    set_flush_to_zero((env->mxcsr & SSE_FZ) ? 1 : 0, &env->fp_status);
target-i386/op_helper.c:    env->mxcsr = val;
target-i386/op_helper.c:    env->fpstt = 0;
target-i386/op_helper.c:    *(uint32_t *)(env->fptags) = 0;
target-i386/op_helper.c:    *(uint32_t *)(env->fptags + 4) = 0;
target-i386/op_helper.c:    *(uint32_t *)(env->fptags) = 0x01010101;
target-i386/op_helper.c:    *(uint32_t *)(env->fptags + 4) = 0x01010101;
target-i386/cpu.h:    sc = &env->segs[seg_reg];
target-i386/cpu.h:            if ((env->hflags & HF_LMA_MASK) && (flags & DESC_L_MASK)) {
target-i386/cpu.h:                env->hflags |= HF_CS32_MASK | HF_SS32_MASK | HF_CS64_MASK;
target-i386/cpu.h:                env->hflags &= ~(HF_ADDSEG_MASK);
target-i386/cpu.h:                new_hflags = (env->segs[R_CS].flags & DESC_B_MASK)
target-i386/cpu.h:                env->hflags = (env->hflags & ~(HF_CS32_MASK | HF_CS64_MASK)) |
target-i386/cpu.h:        new_hflags = (env->segs[R_SS].flags & DESC_B_MASK)
target-i386/cpu.h:        if (env->hflags & HF_CS64_MASK) {
target-i386/cpu.h:        } else if (!(env->cr[0] & CR0_PE_MASK) ||
target-i386/cpu.h:                   (env->eflags & VM_MASK) ||
target-i386/cpu.h:                   !(env->hflags & HF_CS32_MASK)) {
target-i386/cpu.h:            new_hflags |= ((env->segs[R_DS].base |
target-i386/cpu.h:                            env->segs[R_ES].base |
target-i386/cpu.h:                            env->segs[R_SS].base) != 0) <<
target-i386/cpu.h:        env->hflags = (env->hflags &
target-i386/cpu.h:    env->eip = 0;
target-i386/cpu.h:                           env->segs[R_CS].limit,
target-i386/cpu.h:                           env->segs[R_CS].flags);
target-i386/cpu.h:    env->halted = 0;
target-i386/cpu.h:    return (env->hflags & HF_CPL_MASK) == 3 ? 1 : 0;
target-i386/cpu.h:#define EAX (env->regs[R_EAX])
target-i386/cpu.h:#define ECX (env->regs[R_ECX])
target-i386/cpu.h:#define EDX (env->regs[R_EDX])
target-i386/cpu.h:#define EBX (env->regs[R_EBX])
target-i386/cpu.h:#define ESP (env->regs[R_ESP])
target-i386/cpu.h:#define EBP (env->regs[R_EBP])
target-i386/cpu.h:#define ESI (env->regs[R_ESI])
target-i386/cpu.h:#define EDI (env->regs[R_EDI])
target-i386/cpu.h:#define EIP (env->eip)
target-i386/cpu.h:#define DF  (env->df)
target-i386/cpu.h:#define CC_SRC (env->cc_src)
target-i386/cpu.h:#define CC_DST (env->cc_dst)
target-i386/cpu.h:#define CC_OP  (env->cc_op)
target-i386/cpu.h:#define FT0    (env->ft0)
target-i386/cpu.h:#define ST0    (env->fpregs[env->fpstt].d)
target-i386/cpu.h:#define ST(n)  (env->fpregs[(env->fpstt + (n)) & 7].d)
target-i386/cpu.h:        env->regs[R_ESP] = newsp;
target-i386/cpu.h:    env->regs[R_EAX] = 0;
target-i386/cpu.h:    return ((env->interrupt_request & CPU_INTERRUPT_HARD) &&
target-i386/cpu.h:            (env->eflags & IF_MASK)) ||
target-i386/cpu.h:           (env->interrupt_request & (CPU_INTERRUPT_NMI |
target-i386/cpu.h:    env->eip = tb->pc - tb->cs_base;
target-i386/cpu.h:    *cs_base = env->segs[R_CS].base;
target-i386/cpu.h:    *pc = *cs_base + env->eip;
target-i386/cpu.h:    *flags = env->hflags |
target-i386/cpu.h:        (env->eflags & (IOPL_MASK | TF_MASK | RF_MASK | VM_MASK));
target-i386/translate.c~:        if (CODE64(s) && cpu_single_env->cpuid_vendor1 != CPUID_VENDOR_INTEL_1)
target-i386/translate.c~:        if (CODE64(s) && cpu_single_env->cpuid_vendor1 != CPUID_VENDOR_INTEL_1)
target-i386/translate.c~:    dc->singlestep_enabled = env->singlestep_enabled;
target-i386/translate.c~:    dc->cpuid_features = env->cpuid_features;
target-i386/translate.c~:    dc->cpuid_ext_features = env->cpuid_ext_features;
target-i386/translate.c~:    dc->cpuid_ext2_features = env->cpuid_ext2_features;
target-i386/translate.c~:    dc->cpuid_ext3_features = env->cpuid_ext3_features;
target-i386/translate.c~:    dc->jmp_opt = !(dc->tf || env->singlestep_enabled ||
target-i386/translate.c~:        if (unlikely(!QTAILQ_EMPTY(&env->breakpoints))) {
target-i386/translate.c~:            QTAILQ_FOREACH(bp, &env->breakpoints, entry) {
target-i386/translate.c~:        qemu_log("EAX=%08x  EBX=%08x  ECX=%08x  EDX=%08x\n", (uint32_t)env->regs[0], (uint32_t)env->regs[3], (uint32_t)env->regs[1], (uint32_t)env->regs[2]);
target-i386/translate.c~:        qemu_log("ESP=%08x  EBP=%08x  ESI=%08x  EDI=%08x\n", (uint32_t)env->regs[4], (uint32_t)env->regs[5], (uint32_t)env->regs[6], (uint32_t)env->regs[7]);
target-i386/translate.c~:        qemu_log("CR3=%08x\n", (uint32_t)env->cr[3] );
target-i386/translate.c~:    env->eip = gen_opc_pc[pc_pos] - tb->cs_base;
target-i386/translate.c~:        env->cc_op = cc_op;
target-i386/helper.c:    int cpuver = env->cpuid_version;
target-i386/helper.c:    if (env->hflags & HF_CS64_MASK) {
target-i386/helper.c:    if (!(env->hflags & HF_PE_MASK) || !(sc->flags & DESC_P_MASK))
target-i386/helper.c:                    sys_type_name[(env->hflags & HF_LMA_MASK) ? 1 : 0]
target-i386/helper.c:    eflags = env->eflags;
target-i386/helper.c:    if (env->hflags & HF_CS64_MASK) {
target-i386/helper.c:                    env->regs[R_EAX],
target-i386/helper.c:                    env->regs[R_EBX],
target-i386/helper.c:                    env->regs[R_ECX],
target-i386/helper.c:                    env->regs[R_EDX],
target-i386/helper.c:                    env->regs[R_ESI],
target-i386/helper.c:                    env->regs[R_EDI],
target-i386/helper.c:                    env->regs[R_EBP],
target-i386/helper.c:                    env->regs[R_ESP],
target-i386/helper.c:                    env->regs[8],
target-i386/helper.c:                    env->regs[9],
target-i386/helper.c:                    env->regs[10],
target-i386/helper.c:                    env->regs[11],
target-i386/helper.c:                    env->regs[12],
target-i386/helper.c:                    env->regs[13],
target-i386/helper.c:                    env->regs[14],
target-i386/helper.c:                    env->regs[15],
target-i386/helper.c:                    env->eip, eflags,
target-i386/helper.c:                    env->hflags & HF_CPL_MASK,
target-i386/helper.c:                    (env->hflags >> HF_INHIBIT_IRQ_SHIFT) & 1,
target-i386/helper.c:                    (env->a20_mask >> 20) & 1,
target-i386/helper.c:                    (env->hflags >> HF_SMM_SHIFT) & 1,
target-i386/helper.c:                    env->halted);
target-i386/helper.c:                    (uint32_t)env->regs[R_EAX],
target-i386/helper.c:                    (uint32_t)env->regs[R_EBX],
target-i386/helper.c:                    (uint32_t)env->regs[R_ECX],
target-i386/helper.c:                    (uint32_t)env->regs[R_EDX],
target-i386/helper.c:                    (uint32_t)env->regs[R_ESI],
target-i386/helper.c:                    (uint32_t)env->regs[R_EDI],
target-i386/helper.c:                    (uint32_t)env->regs[R_EBP],
target-i386/helper.c:                    (uint32_t)env->regs[R_ESP],
target-i386/helper.c:                    (uint32_t)env->eip, eflags,
target-i386/helper.c:                    env->hflags & HF_CPL_MASK,
target-i386/helper.c:                    (env->hflags >> HF_INHIBIT_IRQ_SHIFT) & 1,
target-i386/helper.c:                    (env->a20_mask >> 20) & 1,
target-i386/helper.c:                    (env->hflags >> HF_SMM_SHIFT) & 1,
target-i386/helper.c:                    env->halted);
target-i386/helper.c:                               &env->segs[i]);
target-i386/helper.c:    cpu_x86_dump_seg_cache(env, f, cpu_fprintf, "LDT", &env->ldt);
target-i386/helper.c:    cpu_x86_dump_seg_cache(env, f, cpu_fprintf, "TR", &env->tr);
target-i386/helper.c:    if (env->hflags & HF_LMA_MASK) {
target-i386/helper.c:                    env->gdt.base, env->gdt.limit);
target-i386/helper.c:                    env->idt.base, env->idt.limit);
target-i386/helper.c:                    (uint32_t)env->cr[0],
target-i386/helper.c:                    env->cr[2],
target-i386/helper.c:                    env->cr[3],
target-i386/helper.c:                    (uint32_t)env->cr[4]);
target-i386/helper.c:            cpu_fprintf(f, "DR%d=%016" PRIx64 " ", i, env->dr[i]);
target-i386/helper.c:                    env->dr[6], env->dr[7]);
target-i386/helper.c:                    (uint32_t)env->gdt.base, env->gdt.limit);
target-i386/helper.c:                    (uint32_t)env->idt.base, env->idt.limit);
target-i386/helper.c:                    (uint32_t)env->cr[0],
target-i386/helper.c:                    (uint32_t)env->cr[2],
target-i386/helper.c:                    (uint32_t)env->cr[3],
target-i386/helper.c:                    (uint32_t)env->cr[4]);
target-i386/helper.c:            cpu_fprintf(f, "DR%d=" TARGET_FMT_lx " ", i, env->dr[i]);
target-i386/helper.c:                    env->dr[6], env->dr[7]);
target-i386/helper.c:        if ((unsigned)env->cc_op < CC_OP_NB)
target-i386/helper.c:            snprintf(cc_op_name, sizeof(cc_op_name), "%s", cc_op_str[env->cc_op]);
target-i386/helper.c:            snprintf(cc_op_name, sizeof(cc_op_name), "[%d]", env->cc_op);
target-i386/helper.c:        if (env->hflags & HF_CS64_MASK) {
target-i386/helper.c:                        env->cc_src, env->cc_dst,
target-i386/helper.c:                        (uint32_t)env->cc_src, (uint32_t)env->cc_dst,
target-i386/helper.c:    cpu_fprintf(f, "EFER=%016" PRIx64 "\n", env->efer);
target-i386/helper.c:            fptag |= ((!env->fptags[i]) << i);
target-i386/helper.c:                    env->fpuc,
target-i386/helper.c:                    (env->fpus & ~0x3800) | (env->fpstt & 0x7) << 11,
target-i386/helper.c:                    env->fpstt,
target-i386/helper.c:                    env->mxcsr);
target-i386/helper.c:            u.d = env->fpregs[i].d;
target-i386/helper.c:        if (env->hflags & HF_CS64_MASK)
target-i386/helper.c:                        env->xmm_regs[i].XMM_L(3),
target-i386/helper.c:                        env->xmm_regs[i].XMM_L(2),
target-i386/helper.c:                        env->xmm_regs[i].XMM_L(1),
target-i386/helper.c:                        env->xmm_regs[i].XMM_L(0));
target-i386/helper.c:        target_ulong base = env->segs[R_CS].base + env->eip;
target-i386/helper.c:        target_ulong offs = MIN(env->eip, DUMP_CODE_BYTES_BACKWARD);
target-i386/helper.c:    if (a20_state != ((env->a20_mask >> 20) & 1)) {
target-i386/helper.c:        env->a20_mask = ~(1 << 20) | (a20_state << 20);
target-i386/helper.c:        (env->cr[0] & (CR0_PG_MASK | CR0_WP_MASK | CR0_PE_MASK))) {
target-i386/helper.c:    if (!(env->cr[0] & CR0_PG_MASK) && (new_cr0 & CR0_PG_MASK) &&
target-i386/helper.c:        (env->efer & MSR_EFER_LME)) {
target-i386/helper.c:        if (!(env->cr[4] & CR4_PAE_MASK))
target-i386/helper.c:        env->efer |= MSR_EFER_LMA;
target-i386/helper.c:        env->hflags |= HF_LMA_MASK;
target-i386/helper.c:    } else if ((env->cr[0] & CR0_PG_MASK) && !(new_cr0 & CR0_PG_MASK) &&
target-i386/helper.c:               (env->efer & MSR_EFER_LMA)) {
target-i386/helper.c:        env->efer &= ~MSR_EFER_LMA;
target-i386/helper.c:        env->hflags &= ~(HF_LMA_MASK | HF_CS64_MASK);
target-i386/helper.c:        env->eip &= 0xffffffff;
target-i386/helper.c:    env->cr[0] = new_cr0 | CR0_ET_MASK;
target-i386/helper.c:    pe_state = (env->cr[0] & CR0_PE_MASK);
target-i386/helper.c:    env->hflags = (env->hflags & ~HF_PE_MASK) | (pe_state << HF_PE_SHIFT);
target-i386/helper.c:    env->hflags |= ((pe_state ^ 1) << HF_ADDSEG_SHIFT);
target-i386/helper.c:    env->hflags = (env->hflags & ~(HF_MP_MASK | HF_EM_MASK | HF_TS_MASK)) |
target-i386/helper.c:    env->cr[3] = new_cr3;
target-i386/helper.c:    if (env->cr[0] & CR0_PG_MASK) {
target-i386/helper.c:    printf("CR4 update: CR4=%08x\n", (uint32_t)env->cr[4]);
target-i386/helper.c:        (env->cr[4] & (CR4_PGE_MASK | CR4_PAE_MASK | CR4_PSE_MASK))) {
target-i386/helper.c:    if (!(env->cpuid_features & CPUID_SSE))
target-i386/helper.c:        env->hflags |= HF_OSFXSR_MASK;
target-i386/helper.c:        env->hflags &= ~HF_OSFXSR_MASK;
target-i386/helper.c:    env->cr[4] = new_cr4;
target-i386/helper.c:    env->cr[2] = addr;
target-i386/helper.c:    env->error_code = (is_write << PG_ERROR_W_BIT);
target-i386/helper.c:    env->error_code |= PG_ERROR_U_MASK;
target-i386/helper.c:    env->exception_index = EXCP0E_PAGE;
target-i386/helper.c:           addr, is_write1, is_user, env->eip);
target-i386/helper.c:    if (!(env->cr[0] & CR0_PG_MASK)) {
target-i386/helper.c:    if (env->cr[4] & CR4_PAE_MASK) {
target-i386/helper.c:        if (env->hflags & HF_LMA_MASK) {
target-i386/helper.c:                env->error_code = 0;
target-i386/helper.c:                env->exception_index = EXCP0D_GPF;
target-i386/helper.c:            pml4e_addr = ((env->cr[3] & ~0xfff) + (((addr >> 39) & 0x1ff) << 3)) &
target-i386/helper.c:                env->a20_mask;
target-i386/helper.c:            if (!(env->efer & MSR_EFER_NXE) && (pml4e & PG_NX_MASK)) {
target-i386/helper.c:                env->a20_mask;
target-i386/helper.c:            if (!(env->efer & MSR_EFER_NXE) && (pdpe & PG_NX_MASK)) {
target-i386/helper.c:            pdpe_addr = ((env->cr[3] & ~0x1f) + ((addr >> 27) & 0x18)) &
target-i386/helper.c:                env->a20_mask;
target-i386/helper.c:            env->a20_mask;
target-i386/helper.c:        if (!(env->efer & MSR_EFER_NXE) && (pde & PG_NX_MASK)) {
target-i386/helper.c:                if ((env->cr[0] & CR0_WP_MASK) &&
target-i386/helper.c:                env->a20_mask;
target-i386/helper.c:            if (!(env->efer & MSR_EFER_NXE) && (pte & PG_NX_MASK)) {
target-i386/helper.c:                if ((env->cr[0] & CR0_WP_MASK) &&
target-i386/helper.c:        pde_addr = ((env->cr[3] & ~0xfff) + ((addr >> 20) & 0xffc)) &
target-i386/helper.c:            env->a20_mask;
target-i386/helper.c:        if ((pde & PG_PSE_MASK) && (env->cr[4] & CR4_PSE_MASK)) {
target-i386/helper.c:                if ((env->cr[0] & CR0_WP_MASK) &&
target-i386/helper.c:                env->a20_mask;
target-i386/helper.c:                if ((env->cr[0] & CR0_WP_MASK) &&
target-i386/helper.c:            if (!(env->cr[0] & CR0_WP_MASK) ||
target-i386/helper.c:    pte = pte & env->a20_mask;
target-i386/helper.c:        (env->efer & MSR_EFER_NXE) &&
target-i386/helper.c:        (env->cr[4] & CR4_PAE_MASK))
target-i386/helper.c:    if (env->intercept_exceptions & (1 << EXCP0E_PAGE)) {
target-i386/helper.c:        stq_phys(env->vm_vmcb + offsetof(struct vmcb, control.exit_info_2), 
target-i386/helper.c:        env->cr[2] = addr;
target-i386/helper.c:    env->error_code = error_code;
target-i386/helper.c:    env->exception_index = EXCP0E_PAGE;
target-i386/helper.c:    if (env->cr[4] & CR4_PAE_MASK) {
target-i386/helper.c:        if (env->hflags & HF_LMA_MASK) {
target-i386/helper.c:            pml4e_addr = ((env->cr[3] & ~0xfff) + (((addr >> 39) & 0x1ff) << 3)) &
target-i386/helper.c:                env->a20_mask;
target-i386/helper.c:                         (((addr >> 30) & 0x1ff) << 3)) & env->a20_mask;
target-i386/helper.c:            pdpe_addr = ((env->cr[3] & ~0x1f) + ((addr >> 27) & 0x18)) &
target-i386/helper.c:                env->a20_mask;
target-i386/helper.c:                    (((addr >> 21) & 0x1ff) << 3)) & env->a20_mask;
target-i386/helper.c:                        (((addr >> 12) & 0x1ff) << 3)) & env->a20_mask;
target-i386/helper.c:        if (!(env->cr[0] & CR0_PG_MASK)) {
target-i386/helper.c:            pde_addr = ((env->cr[3] & ~0xfff) + ((addr >> 20) & 0xffc)) & env->a20_mask;
target-i386/helper.c:            if ((pde & PG_PSE_MASK) && (env->cr[4] & CR4_PSE_MASK)) {
target-i386/helper.c:                pte_addr = ((pde & ~0xfff) + ((addr >> 10) & 0xffc)) & env->a20_mask;
target-i386/helper.c:        pte = pte & env->a20_mask;
target-i386/helper.c:    switch (hw_breakpoint_type(env->dr[7], index)) {
target-i386/helper.c:        if (hw_breakpoint_enabled(env->dr[7], index))
target-i386/helper.c:            err = cpu_breakpoint_insert(env, env->dr[index], BP_CPU,
target-i386/helper.c:                                        &env->cpu_breakpoint[index]);
target-i386/helper.c:        err = cpu_watchpoint_insert(env, env->dr[index],
target-i386/helper.c:                                    hw_breakpoint_len(env->dr[7], index),
target-i386/helper.c:                                    type, &env->cpu_watchpoint[index]);
target-i386/helper.c:        env->cpu_breakpoint[index] = NULL;
target-i386/helper.c:    if (!env->cpu_breakpoint[index])
target-i386/helper.c:    switch (hw_breakpoint_type(env->dr[7], index)) {
target-i386/helper.c:        if (hw_breakpoint_enabled(env->dr[7], index))
target-i386/helper.c:            cpu_breakpoint_remove_by_ref(env, env->cpu_breakpoint[index]);
target-i386/helper.c:        cpu_watchpoint_remove_by_ref(env, env->cpu_watchpoint[index]);
target-i386/helper.c:    dr6 = env->dr[6] & ~0xf;
target-i386/helper.c:        type = hw_breakpoint_type(env->dr[7], reg);
target-i386/helper.c:        if ((type == 0 && env->dr[reg] == env->eip) ||
target-i386/helper.c:            ((type & 1) && env->cpu_watchpoint[reg] &&
target-i386/helper.c:             (env->cpu_watchpoint[reg]->flags & BP_WATCHPOINT_HIT))) {
target-i386/helper.c:            if (hw_breakpoint_enabled(env->dr[7], reg))
target-i386/helper.c:        env->dr[6] = dr6;
target-i386/helper.c:    if (env->watchpoint_hit) {
target-i386/helper.c:        if (env->watchpoint_hit->flags & BP_CPU) {
target-i386/helper.c:            env->watchpoint_hit = NULL;
target-i386/helper.c:        QTAILQ_FOREACH(bp, &env->breakpoints, entry)
target-i386/helper.c:            if (bp->pc == env->eip) {
target-i386/helper.c:    uint64_t *banks = cenv->mce_banks + 4 * params->bank;
target-i386/helper.c:        && (cenv->mcg_status & MCG_STATUS_MCIP)) {
target-i386/helper.c:        if ((cenv->mcg_cap & MCG_CTL_P) && cenv->mcg_ctl != ~(uint64_t)0) {
target-i386/helper.c:                           cenv->cpu_index);
target-i386/helper.c:                           cenv->cpu_index, params->bank);
target-i386/helper.c:        if ((cenv->mcg_status & MCG_STATUS_MCIP) ||
target-i386/helper.c:            !(cenv->cr[4] & CR4_MCE_MASK)) {
target-i386/helper.c:                           cenv->cpu_index);
target-i386/helper.c:        cenv->mcg_status = params->mcg_status;
target-i386/helper.c:    unsigned bank_num = cenv->mcg_cap & 0xff;
target-i386/helper.c:    if (!cenv->mcg_cap) {
target-i386/helper.c:        for (env = first_cpu; env != NULL; env = env->next_cpu) {
target-i386/helper.c:        env->tpr_access_type = access;
target-i386/helper.c:        tb = tb_find_pc(env->mem_io_pc);
target-i386/helper.c:        cpu_restore_state(tb, env, env->mem_io_pc);
target-i386/helper.c:        apic_handle_tpr_access_report(env->apic_state, env->eip, access);
target-i386/helper.c:        dt = &env->ldt;
target-i386/helper.c:        dt = &env->gdt;
target-i386/helper.c:    env->cpu_model_str = cpu_model;
target-i386/helper.c:    int sipi = env->interrupt_request & CPU_INTERRUPT_SIPI;
target-i386/helper.c:    uint64_t pat = env->pat;
target-i386/helper.c:    env->interrupt_request = sipi;
target-i386/helper.c:    env->pat = pat;
target-i386/helper.c:    apic_init_reset(env->apic_state);
target-i386/helper.c:    env->halted = !cpu_is_bsp(env);
target-i386/helper.c:    apic_sipi(env->apic_state);
target-i386/ops_sse.h:#define FPU_ADD(size, a, b) float ## size ## _add(a, b, &env->sse_status)
target-i386/ops_sse.h:#define FPU_SUB(size, a, b) float ## size ## _sub(a, b, &env->sse_status)
target-i386/ops_sse.h:#define FPU_MUL(size, a, b) float ## size ## _mul(a, b, &env->sse_status)
target-i386/ops_sse.h:#define FPU_DIV(size, a, b) float ## size ## _div(a, b, &env->sse_status)
target-i386/ops_sse.h:#define FPU_SQRT(size, a, b) float ## size ## _sqrt(b, &env->sse_status)
target-i386/ops_sse.h:#define FPU_MIN(size, a, b) float ## size ## _lt(a, b, &env->sse_status) ? (a) : (b)
target-i386/ops_sse.h:#define FPU_MAX(size, a, b) float ## size ## _lt(b, a, &env->sse_status) ? (a) : (b)
target-i386/ops_sse.h:    d->XMM_D(0) = float32_to_float64(s0, &env->sse_status);
target-i386/ops_sse.h:    d->XMM_D(1) = float32_to_float64(s1, &env->sse_status);
target-i386/ops_sse.h:    d->XMM_S(0) = float64_to_float32(s->XMM_D(0), &env->sse_status);
target-i386/ops_sse.h:    d->XMM_S(1) = float64_to_float32(s->XMM_D(1), &env->sse_status);
target-i386/ops_sse.h:    d->XMM_D(0) = float32_to_float64(s->XMM_S(0), &env->sse_status);
target-i386/ops_sse.h:    d->XMM_S(0) = float64_to_float32(s->XMM_D(0), &env->sse_status);
target-i386/ops_sse.h:    d->XMM_S(0) = int32_to_float32(s->XMM_L(0), &env->sse_status);
target-i386/ops_sse.h:    d->XMM_S(1) = int32_to_float32(s->XMM_L(1), &env->sse_status);
target-i386/ops_sse.h:    d->XMM_S(2) = int32_to_float32(s->XMM_L(2), &env->sse_status);
target-i386/ops_sse.h:    d->XMM_S(3) = int32_to_float32(s->XMM_L(3), &env->sse_status);
target-i386/ops_sse.h:    d->XMM_D(0) = int32_to_float64(l0, &env->sse_status);
target-i386/ops_sse.h:    d->XMM_D(1) = int32_to_float64(l1, &env->sse_status);
target-i386/ops_sse.h:    d->XMM_S(0) = int32_to_float32(s->MMX_L(0), &env->sse_status);
target-i386/ops_sse.h:    d->XMM_S(1) = int32_to_float32(s->MMX_L(1), &env->sse_status);
target-i386/ops_sse.h:    d->XMM_D(0) = int32_to_float64(s->MMX_L(0), &env->sse_status);
target-i386/ops_sse.h:    d->XMM_D(1) = int32_to_float64(s->MMX_L(1), &env->sse_status);
target-i386/ops_sse.h:    d->XMM_S(0) = int32_to_float32(val, &env->sse_status);
target-i386/ops_sse.h:    d->XMM_D(0) = int32_to_float64(val, &env->sse_status);
target-i386/ops_sse.h:    d->XMM_S(0) = int64_to_float32(val, &env->sse_status);
target-i386/ops_sse.h:    d->XMM_D(0) = int64_to_float64(val, &env->sse_status);
target-i386/ops_sse.h:    d->XMM_L(0) = float32_to_int32(s->XMM_S(0), &env->sse_status);
target-i386/ops_sse.h:    d->XMM_L(1) = float32_to_int32(s->XMM_S(1), &env->sse_status);
target-i386/ops_sse.h:    d->XMM_L(2) = float32_to_int32(s->XMM_S(2), &env->sse_status);
target-i386/ops_sse.h:    d->XMM_L(3) = float32_to_int32(s->XMM_S(3), &env->sse_status);
target-i386/ops_sse.h:    d->XMM_L(0) = float64_to_int32(s->XMM_D(0), &env->sse_status);
target-i386/ops_sse.h:    d->XMM_L(1) = float64_to_int32(s->XMM_D(1), &env->sse_status);
target-i386/ops_sse.h:    d->MMX_L(0) = float32_to_int32(s->XMM_S(0), &env->sse_status);
target-i386/ops_sse.h:    d->MMX_L(1) = float32_to_int32(s->XMM_S(1), &env->sse_status);
target-i386/ops_sse.h:    d->MMX_L(0) = float64_to_int32(s->XMM_D(0), &env->sse_status);
target-i386/ops_sse.h:    d->MMX_L(1) = float64_to_int32(s->XMM_D(1), &env->sse_status);
target-i386/ops_sse.h:    return float32_to_int32(s->XMM_S(0), &env->sse_status);
target-i386/ops_sse.h:    return float64_to_int32(s->XMM_D(0), &env->sse_status);
target-i386/ops_sse.h:    return float32_to_int64(s->XMM_S(0), &env->sse_status);
target-i386/ops_sse.h:    return float64_to_int64(s->XMM_D(0), &env->sse_status);
target-i386/ops_sse.h:    d->XMM_L(0) = float32_to_int32_round_to_zero(s->XMM_S(0), &env->sse_status);
target-i386/ops_sse.h:    d->XMM_L(1) = float32_to_int32_round_to_zero(s->XMM_S(1), &env->sse_status);
target-i386/ops_sse.h:    d->XMM_L(2) = float32_to_int32_round_to_zero(s->XMM_S(2), &env->sse_status);
target-i386/ops_sse.h:    d->XMM_L(3) = float32_to_int32_round_to_zero(s->XMM_S(3), &env->sse_status);
target-i386/ops_sse.h:    d->XMM_L(0) = float64_to_int32_round_to_zero(s->XMM_D(0), &env->sse_status);
target-i386/ops_sse.h:    d->XMM_L(1) = float64_to_int32_round_to_zero(s->XMM_D(1), &env->sse_status);
target-i386/ops_sse.h:    d->MMX_L(0) = float32_to_int32_round_to_zero(s->XMM_S(0), &env->sse_status);
target-i386/ops_sse.h:    d->MMX_L(1) = float32_to_int32_round_to_zero(s->XMM_S(1), &env->sse_status);
target-i386/ops_sse.h:    d->MMX_L(0) = float64_to_int32_round_to_zero(s->XMM_D(0), &env->sse_status);
target-i386/ops_sse.h:    d->MMX_L(1) = float64_to_int32_round_to_zero(s->XMM_D(1), &env->sse_status);
target-i386/ops_sse.h:    return float32_to_int32_round_to_zero(s->XMM_S(0), &env->sse_status);
target-i386/ops_sse.h:    return float64_to_int32_round_to_zero(s->XMM_D(0), &env->sse_status);
target-i386/ops_sse.h:    return float32_to_int64_round_to_zero(s->XMM_S(0), &env->sse_status);
target-i386/ops_sse.h:    return float64_to_int64_round_to_zero(s->XMM_D(0), &env->sse_status);
target-i386/ops_sse.h:                              float32_sqrt(s->XMM_S(0), &env->sse_status),
target-i386/ops_sse.h:                              &env->sse_status);
target-i386/ops_sse.h:                              float32_sqrt(s->XMM_S(1), &env->sse_status),
target-i386/ops_sse.h:                              &env->sse_status);
target-i386/ops_sse.h:                              float32_sqrt(s->XMM_S(2), &env->sse_status),
target-i386/ops_sse.h:                              &env->sse_status);
target-i386/ops_sse.h:                              float32_sqrt(s->XMM_S(3), &env->sse_status),
target-i386/ops_sse.h:                              &env->sse_status);
target-i386/ops_sse.h:                              float32_sqrt(s->XMM_S(0), &env->sse_status),
target-i386/ops_sse.h:                              &env->sse_status);
target-i386/ops_sse.h:    d->XMM_S(0) = float32_div(float32_one, s->XMM_S(0), &env->sse_status);
target-i386/ops_sse.h:    d->XMM_S(1) = float32_div(float32_one, s->XMM_S(1), &env->sse_status);
target-i386/ops_sse.h:    d->XMM_S(2) = float32_div(float32_one, s->XMM_S(2), &env->sse_status);
target-i386/ops_sse.h:    d->XMM_S(3) = float32_div(float32_one, s->XMM_S(3), &env->sse_status);
target-i386/ops_sse.h:    d->XMM_S(0) = float32_div(float32_one, s->XMM_S(0), &env->sse_status);
target-i386/ops_sse.h:    r.XMM_S(0) = float32_add(d->XMM_S(0), d->XMM_S(1), &env->sse_status);
target-i386/ops_sse.h:    r.XMM_S(1) = float32_add(d->XMM_S(2), d->XMM_S(3), &env->sse_status);
target-i386/ops_sse.h:    r.XMM_S(2) = float32_add(s->XMM_S(0), s->XMM_S(1), &env->sse_status);
target-i386/ops_sse.h:    r.XMM_S(3) = float32_add(s->XMM_S(2), s->XMM_S(3), &env->sse_status);
target-i386/ops_sse.h:    r.XMM_D(0) = float64_add(d->XMM_D(0), d->XMM_D(1), &env->sse_status);
target-i386/ops_sse.h:    r.XMM_D(1) = float64_add(s->XMM_D(0), s->XMM_D(1), &env->sse_status);
target-i386/ops_sse.h:    r.XMM_S(0) = float32_sub(d->XMM_S(0), d->XMM_S(1), &env->sse_status);
target-i386/ops_sse.h:    r.XMM_S(1) = float32_sub(d->XMM_S(2), d->XMM_S(3), &env->sse_status);
target-i386/ops_sse.h:    r.XMM_S(2) = float32_sub(s->XMM_S(0), s->XMM_S(1), &env->sse_status);
target-i386/ops_sse.h:    r.XMM_S(3) = float32_sub(s->XMM_S(2), s->XMM_S(3), &env->sse_status);
target-i386/ops_sse.h:    r.XMM_D(0) = float64_sub(d->XMM_D(0), d->XMM_D(1), &env->sse_status);
target-i386/ops_sse.h:    r.XMM_D(1) = float64_sub(s->XMM_D(0), s->XMM_D(1), &env->sse_status);
target-i386/ops_sse.h:    d->XMM_S(0) = float32_sub(d->XMM_S(0), s->XMM_S(0), &env->sse_status);
target-i386/ops_sse.h:    d->XMM_S(1) = float32_add(d->XMM_S(1), s->XMM_S(1), &env->sse_status);
target-i386/ops_sse.h:    d->XMM_S(2) = float32_sub(d->XMM_S(2), s->XMM_S(2), &env->sse_status);
target-i386/ops_sse.h:    d->XMM_S(3) = float32_add(d->XMM_S(3), s->XMM_S(3), &env->sse_status);
target-i386/ops_sse.h:    d->XMM_D(0) = float64_sub(d->XMM_D(0), s->XMM_D(0), &env->sse_status);
target-i386/ops_sse.h:    d->XMM_D(1) = float64_add(d->XMM_D(1), s->XMM_D(1), &env->sse_status);
target-i386/ops_sse.h:#define FPU_CMPEQ(size, a, b) float ## size ## _eq_quiet(a, b, &env->sse_status) ? -1 : 0
target-i386/ops_sse.h:#define FPU_CMPLT(size, a, b) float ## size ## _lt(a, b, &env->sse_status) ? -1 : 0
target-i386/ops_sse.h:#define FPU_CMPLE(size, a, b) float ## size ## _le(a, b, &env->sse_status) ? -1 : 0
target-i386/ops_sse.h:#define FPU_CMPUNORD(size, a, b) float ## size ## _unordered_quiet(a, b, &env->sse_status) ? - 1 : 0
target-i386/ops_sse.h:#define FPU_CMPNEQ(size, a, b) float ## size ## _eq_quiet(a, b, &env->sse_status) ? 0 : -1
target-i386/ops_sse.h:#define FPU_CMPNLT(size, a, b) float ## size ## _lt(a, b, &env->sse_status) ? 0 : -1
target-i386/ops_sse.h:#define FPU_CMPNLE(size, a, b) float ## size ## _le(a, b, &env->sse_status) ? 0 : -1
target-i386/ops_sse.h:#define FPU_CMPORD(size, a, b) float ## size ## _unordered_quiet(a, b, &env->sse_status) ? 0 : -1
target-i386/ops_sse.h:    ret = float32_compare_quiet(s0, s1, &env->sse_status);
target-i386/ops_sse.h:    ret = float32_compare(s0, s1, &env->sse_status);
target-i386/ops_sse.h:    ret = float64_compare_quiet(d0, d1, &env->sse_status);
target-i386/ops_sse.h:    ret = float64_compare(d0, d1, &env->sse_status);
target-i386/ops_sse.h:    d->MMX_S(0) = int32_to_float32(s->MMX_L(0), &env->mmx_status);
target-i386/ops_sse.h:    d->MMX_S(1) = int32_to_float32(s->MMX_L(1), &env->mmx_status);
target-i386/ops_sse.h:    d->MMX_S(0) = int32_to_float32((int16_t)s->MMX_W(0), &env->mmx_status);
target-i386/ops_sse.h:    d->MMX_S(1) = int32_to_float32((int16_t)s->MMX_W(2), &env->mmx_status);
target-i386/ops_sse.h:    d->MMX_L(0) = float32_to_int32_round_to_zero(s->MMX_S(0), &env->mmx_status);
target-i386/ops_sse.h:    d->MMX_L(1) = float32_to_int32_round_to_zero(s->MMX_S(1), &env->mmx_status);
target-i386/ops_sse.h:    d->MMX_L(0) = satsw(float32_to_int32_round_to_zero(s->MMX_S(0), &env->mmx_status));
target-i386/ops_sse.h:    d->MMX_L(1) = satsw(float32_to_int32_round_to_zero(s->MMX_S(1), &env->mmx_status));
target-i386/ops_sse.h:    r.MMX_S(0) = float32_add(d->MMX_S(0), d->MMX_S(1), &env->mmx_status);
target-i386/ops_sse.h:    r.MMX_S(1) = float32_add(s->MMX_S(0), s->MMX_S(1), &env->mmx_status);
target-i386/ops_sse.h:    d->MMX_S(0) = float32_add(d->MMX_S(0), s->MMX_S(0), &env->mmx_status);
target-i386/ops_sse.h:    d->MMX_S(1) = float32_add(d->MMX_S(1), s->MMX_S(1), &env->mmx_status);
target-i386/ops_sse.h:    d->MMX_L(0) = float32_eq_quiet(d->MMX_S(0), s->MMX_S(0), &env->mmx_status) ? -1 : 0;
target-i386/ops_sse.h:    d->MMX_L(1) = float32_eq_quiet(d->MMX_S(1), s->MMX_S(1), &env->mmx_status) ? -1 : 0;
target-i386/ops_sse.h:    d->MMX_L(0) = float32_le(s->MMX_S(0), d->MMX_S(0), &env->mmx_status) ? -1 : 0;
target-i386/ops_sse.h:    d->MMX_L(1) = float32_le(s->MMX_S(1), d->MMX_S(1), &env->mmx_status) ? -1 : 0;
target-i386/ops_sse.h:    d->MMX_L(0) = float32_lt(s->MMX_S(0), d->MMX_S(0), &env->mmx_status) ? -1 : 0;
target-i386/ops_sse.h:    d->MMX_L(1) = float32_lt(s->MMX_S(1), d->MMX_S(1), &env->mmx_status) ? -1 : 0;
target-i386/ops_sse.h:    if (float32_lt(d->MMX_S(0), s->MMX_S(0), &env->mmx_status))
target-i386/ops_sse.h:    if (float32_lt(d->MMX_S(1), s->MMX_S(1), &env->mmx_status))
target-i386/ops_sse.h:    if (float32_lt(s->MMX_S(0), d->MMX_S(0), &env->mmx_status))
target-i386/ops_sse.h:    if (float32_lt(s->MMX_S(1), d->MMX_S(1), &env->mmx_status))
target-i386/ops_sse.h:    d->MMX_S(0) = float32_mul(d->MMX_S(0), s->MMX_S(0), &env->mmx_status);
target-i386/ops_sse.h:    d->MMX_S(1) = float32_mul(d->MMX_S(1), s->MMX_S(1), &env->mmx_status);
target-i386/ops_sse.h:    r.MMX_S(0) = float32_sub(d->MMX_S(0), d->MMX_S(1), &env->mmx_status);
target-i386/ops_sse.h:    r.MMX_S(1) = float32_sub(s->MMX_S(0), s->MMX_S(1), &env->mmx_status);
target-i386/ops_sse.h:    r.MMX_S(0) = float32_sub(d->MMX_S(0), d->MMX_S(1), &env->mmx_status);
target-i386/ops_sse.h:    r.MMX_S(1) = float32_add(s->MMX_S(0), s->MMX_S(1), &env->mmx_status);
target-i386/ops_sse.h:    d->MMX_S(0) = float32_div(float32_one, s->MMX_S(0), &env->mmx_status);
target-i386/ops_sse.h:                              float32_sqrt(d->MMX_S(1), &env->mmx_status),
target-i386/ops_sse.h:                              &env->mmx_status);
target-i386/ops_sse.h:    d->MMX_S(0) = float32_sub(d->MMX_S(0), s->MMX_S(0), &env->mmx_status);
target-i386/ops_sse.h:    d->MMX_S(1) = float32_sub(d->MMX_S(1), s->MMX_S(1), &env->mmx_status);
target-i386/ops_sse.h:    d->MMX_S(0) = float32_sub(s->MMX_S(0), d->MMX_S(0), &env->mmx_status);
target-i386/ops_sse.h:    d->MMX_S(1) = float32_sub(s->MMX_S(1), d->MMX_S(1), &env->mmx_status);
target-i386/ops_sse.h:#define XMM0 env->xmm_regs[0]
target-i386/ops_sse.h:    prev_rounding_mode = env->sse_status.float_rounding_mode;
target-i386/ops_sse.h:            set_float_rounding_mode(float_round_nearest_even, &env->sse_status);
target-i386/ops_sse.h:            set_float_rounding_mode(float_round_down, &env->sse_status);
target-i386/ops_sse.h:            set_float_rounding_mode(float_round_up, &env->sse_status);
target-i386/ops_sse.h:            set_float_rounding_mode(float_round_to_zero, &env->sse_status);
target-i386/ops_sse.h:    d->XMM_S(0) = float32_round_to_int(s->XMM_S(0), &env->sse_status);
target-i386/ops_sse.h:    d->XMM_S(1) = float32_round_to_int(s->XMM_S(1), &env->sse_status);
target-i386/ops_sse.h:    d->XMM_S(2) = float32_round_to_int(s->XMM_S(2), &env->sse_status);
target-i386/ops_sse.h:    d->XMM_S(3) = float32_round_to_int(s->XMM_S(3), &env->sse_status);
target-i386/ops_sse.h:                        get_float_exception_flags(&env->sse_status) &
target-i386/ops_sse.h:                        &env->sse_status);
target-i386/ops_sse.h:    env->sse_status.float_rounding_mode = prev_rounding_mode;
target-i386/ops_sse.h:    prev_rounding_mode = env->sse_status.float_rounding_mode;
target-i386/ops_sse.h:            set_float_rounding_mode(float_round_nearest_even, &env->sse_status);
target-i386/ops_sse.h:            set_float_rounding_mode(float_round_down, &env->sse_status);
target-i386/ops_sse.h:            set_float_rounding_mode(float_round_up, &env->sse_status);
target-i386/ops_sse.h:            set_float_rounding_mode(float_round_to_zero, &env->sse_status);
target-i386/ops_sse.h:    d->XMM_D(0) = float64_round_to_int(s->XMM_D(0), &env->sse_status);
target-i386/ops_sse.h:    d->XMM_D(1) = float64_round_to_int(s->XMM_D(1), &env->sse_status);
target-i386/ops_sse.h:                        get_float_exception_flags(&env->sse_status) &
target-i386/ops_sse.h:                        &env->sse_status);
target-i386/ops_sse.h:    env->sse_status.float_rounding_mode = prev_rounding_mode;
target-i386/ops_sse.h:    prev_rounding_mode = env->sse_status.float_rounding_mode;
target-i386/ops_sse.h:            set_float_rounding_mode(float_round_nearest_even, &env->sse_status);
target-i386/ops_sse.h:            set_float_rounding_mode(float_round_down, &env->sse_status);
target-i386/ops_sse.h:            set_float_rounding_mode(float_round_up, &env->sse_status);
target-i386/ops_sse.h:            set_float_rounding_mode(float_round_to_zero, &env->sse_status);
target-i386/ops_sse.h:    d->XMM_S(0) = float32_round_to_int(s->XMM_S(0), &env->sse_status);
target-i386/ops_sse.h:                        get_float_exception_flags(&env->sse_status) &
target-i386/ops_sse.h:                        &env->sse_status);
target-i386/ops_sse.h:    env->sse_status.float_rounding_mode = prev_rounding_mode;
target-i386/ops_sse.h:    prev_rounding_mode = env->sse_status.float_rounding_mode;
target-i386/ops_sse.h:            set_float_rounding_mode(float_round_nearest_even, &env->sse_status);
target-i386/ops_sse.h:            set_float_rounding_mode(float_round_down, &env->sse_status);
target-i386/ops_sse.h:            set_float_rounding_mode(float_round_up, &env->sse_status);
target-i386/ops_sse.h:            set_float_rounding_mode(float_round_to_zero, &env->sse_status);
target-i386/ops_sse.h:    d->XMM_D(0) = float64_round_to_int(s->XMM_D(0), &env->sse_status);
target-i386/ops_sse.h:                        get_float_exception_flags(&env->sse_status) &
target-i386/ops_sse.h:                        &env->sse_status);
target-i386/ops_sse.h:    env->sse_status.float_rounding_mode = prev_rounding_mode;
target-i386/ops_sse.h:                        float32_mul(d->XMM_S(0), s->XMM_S(0), &env->sse_status),
target-i386/ops_sse.h:                        &env->sse_status);
target-i386/ops_sse.h:                        float32_mul(d->XMM_S(1), s->XMM_S(1), &env->sse_status),
target-i386/ops_sse.h:                        &env->sse_status);
target-i386/ops_sse.h:                        float32_mul(d->XMM_S(2), s->XMM_S(2), &env->sse_status),
target-i386/ops_sse.h:                        &env->sse_status);
target-i386/ops_sse.h:                        float32_mul(d->XMM_S(3), s->XMM_S(3), &env->sse_status),
target-i386/ops_sse.h:                        &env->sse_status);
target-i386/ops_sse.h:                        float64_mul(d->XMM_D(0), s->XMM_D(0), &env->sse_status),
target-i386/ops_sse.h:                        &env->sse_status);
target-i386/ops_sse.h:                        float64_mul(d->XMM_D(1), s->XMM_D(1), &env->sse_status),
target-i386/ops_sse.h:                        &env->sse_status);
target-i386/ops_sse.h:        val = abs1((int64_t) env->regs[reg]);
target-i386/ops_sse.h:        val = abs1((int32_t) env->regs[reg]);
target-i386/ops_sse.h:        env->regs[R_ECX] = ((ctrl & (1 << 6)) ? rffs1 : ffs1)(res) - 1;
target-i386/ops_sse.h:        env->regs[R_ECX] = 16 >> (ctrl & (1 << 0));
target-i386/ops_sse.h:        env->regs[R_ECX] = ((ctrl & (1 << 6)) ? rffs1 : ffs1)(res) - 1;
target-i386/ops_sse.h:        env->regs[R_ECX] = 16 >> (ctrl & (1 << 0));
target-i386/cpu.c:    value = (env->cpuid_version >> 8) & 0xf;
target-i386/cpu.c:        value += (env->cpuid_version >> 20) & 0xff;
target-i386/cpu.c:    env->cpuid_version &= ~0xff00f00;
target-i386/cpu.c:        env->cpuid_version |= 0xf00 | ((value - 0x0f) << 20);
target-i386/cpu.c:        env->cpuid_version |= value << 8;
target-i386/cpu.c:    value = (env->cpuid_version >> 4) & 0xf;
target-i386/cpu.c:    value |= ((env->cpuid_version >> 16) & 0xf) << 4;
target-i386/cpu.c:    env->cpuid_version &= ~0xf00f0;
target-i386/cpu.c:    env->cpuid_version |= ((value & 0xf) << 4) | ((value >> 4) << 16);
target-i386/cpu.c:    value = env->cpuid_version & 0xf;
target-i386/cpu.c:    env->cpuid_version &= ~0xf;
target-i386/cpu.c:    env->cpuid_version |= value & 0xf;
target-i386/cpu.c:        value[i    ] = env->cpuid_vendor1 >> (8 * i);
target-i386/cpu.c:        value[i + 4] = env->cpuid_vendor2 >> (8 * i);
target-i386/cpu.c:        value[i + 8] = env->cpuid_vendor3 >> (8 * i);
target-i386/cpu.c:    env->cpuid_vendor1 = 0;
target-i386/cpu.c:    env->cpuid_vendor2 = 0;
target-i386/cpu.c:    env->cpuid_vendor3 = 0;
target-i386/cpu.c:        env->cpuid_vendor1 |= ((uint8_t)value[i    ]) << (8 * i);
target-i386/cpu.c:        env->cpuid_vendor2 |= ((uint8_t)value[i + 4]) << (8 * i);
target-i386/cpu.c:        env->cpuid_vendor3 |= ((uint8_t)value[i + 8]) << (8 * i);
target-i386/cpu.c:    env->cpuid_vendor_override = 1;
target-i386/cpu.c:        value[i] = env->cpuid_model[i >> 2] >> (8 * (i & 3));
target-i386/cpu.c:    memset(env->cpuid_model, 0, 48);
target-i386/cpu.c:        env->cpuid_model[i >> 2] |= c << (8 * (i & 3));
target-i386/cpu.c:        env->cpuid_vendor1 = def->vendor1;
target-i386/cpu.c:        env->cpuid_vendor2 = def->vendor2;
target-i386/cpu.c:        env->cpuid_vendor3 = def->vendor3;
target-i386/cpu.c:        env->cpuid_vendor1 = CPUID_VENDOR_INTEL_1;
target-i386/cpu.c:        env->cpuid_vendor2 = CPUID_VENDOR_INTEL_2;
target-i386/cpu.c:        env->cpuid_vendor3 = CPUID_VENDOR_INTEL_3;
target-i386/cpu.c:    env->cpuid_vendor_override = def->vendor_override;
target-i386/cpu.c:    env->cpuid_features = def->features;
target-i386/cpu.c:    env->cpuid_ext_features = def->ext_features;
target-i386/cpu.c:    env->cpuid_ext2_features = def->ext2_features;
target-i386/cpu.c:    env->cpuid_ext3_features = def->ext3_features;
target-i386/cpu.c:    env->cpuid_kvm_features = def->kvm_features;
target-i386/cpu.c:    env->cpuid_svm_features = def->svm_features;
target-i386/cpu.c:    env->cpuid_ext4_features = def->ext4_features;
target-i386/cpu.c:    env->cpuid_xlevel2 = def->xlevel2;
target-i386/cpu.c:        env->cpuid_features &= TCG_FEATURES;
target-i386/cpu.c:        env->cpuid_ext_features &= TCG_EXT_FEATURES;
target-i386/cpu.c:        env->cpuid_ext2_features &= (TCG_EXT2_FEATURES
target-i386/cpu.c:        env->cpuid_ext3_features &= TCG_EXT3_FEATURES;
target-i386/cpu.c:        env->cpuid_svm_features &= TCG_SVM_FEATURES;
target-i386/cpu.c:    env->cpuid_features &= ~CPUID_APIC;
target-i386/cpu.c:    *ebx = env->cpuid_vendor1;
target-i386/cpu.c:    *edx = env->cpuid_vendor2;
target-i386/cpu.c:    *ecx = env->cpuid_vendor3;
target-i386/cpu.c:    if (kvm_enabled() && ! env->cpuid_vendor_override) {
target-i386/cpu.c:        if (index > env->cpuid_xlevel) {
target-i386/cpu.c:            if (env->cpuid_xlevel2 > 0) {
target-i386/cpu.c:                if (index > env->cpuid_xlevel2) {
target-i386/cpu.c:                    index = env->cpuid_xlevel2;
target-i386/cpu.c:                    index = env->cpuid_xlevel;
target-i386/cpu.c:                index =  env->cpuid_xlevel;
target-i386/cpu.c:        if (index > env->cpuid_level)
target-i386/cpu.c:            index = env->cpuid_level;
target-i386/cpu.c:        *eax = env->cpuid_level;
target-i386/cpu.c:        *eax = env->cpuid_version;
target-i386/cpu.c:        *ebx = (env->cpuid_apic_id << 24) | 8 << 8; /* CLFLUSH size in quad words, Linux wants it. */
target-i386/cpu.c:        *ecx = env->cpuid_ext_features;
target-i386/cpu.c:        *edx = env->cpuid_features;
target-i386/cpu.c:        if (env->nr_cores * env->nr_threads > 1) {
target-i386/cpu.c:            *ebx |= (env->nr_cores * env->nr_threads) << 16;
target-i386/cpu.c:        if (env->nr_cores > 1) {
target-i386/cpu.c:            *eax = (env->nr_cores - 1) << 26;
target-i386/cpu.c:                if (env->nr_threads > 1) {
target-i386/cpu.c:                    *eax |= (env->nr_threads - 1) << 14;
target-i386/cpu.c:            KVMState *s = env->kvm_state;
target-i386/cpu.c:            KVMState *s = env->kvm_state;
target-i386/cpu.c:        if (!(env->cpuid_ext_features & CPUID_EXT_XSAVE)) {
target-i386/cpu.c:            KVMState *s = env->kvm_state;
target-i386/cpu.c:        *eax = env->cpuid_xlevel;
target-i386/cpu.c:        *ebx = env->cpuid_vendor1;
target-i386/cpu.c:        *edx = env->cpuid_vendor2;
target-i386/cpu.c:        *ecx = env->cpuid_vendor3;
target-i386/cpu.c:        *eax = env->cpuid_version;
target-i386/cpu.c:        *ecx = env->cpuid_ext3_features;
target-i386/cpu.c:        *edx = env->cpuid_ext2_features;
target-i386/cpu.c:        if (env->nr_cores * env->nr_threads > 1) {
target-i386/cpu.c:        *eax = env->cpuid_model[(index - 0x80000002) * 4 + 0];
target-i386/cpu.c:        *ebx = env->cpuid_model[(index - 0x80000002) * 4 + 1];
target-i386/cpu.c:        *ecx = env->cpuid_model[(index - 0x80000002) * 4 + 2];
target-i386/cpu.c:        *edx = env->cpuid_model[(index - 0x80000002) * 4 + 3];
target-i386/cpu.c:        if (env->cpuid_ext2_features & CPUID_EXT2_LM) {
target-i386/cpu.c:            if (env->cpuid_features & CPUID_PSE36)
target-i386/cpu.c:        if (env->nr_cores * env->nr_threads > 1) {
target-i386/cpu.c:            *ecx |= (env->nr_cores * env->nr_threads) - 1;
target-i386/cpu.c:	if (env->cpuid_ext3_features & CPUID_EXT3_SVM) {
target-i386/cpu.c:		*edx = env->cpuid_svm_features; /* optional features */
target-i386/cpu.c:        *eax = env->cpuid_xlevel2;
target-i386/cpu.c:        *eax = env->cpuid_version;
target-i386/cpu.c:        *edx = env->cpuid_ext4_features;
target-i386/cpu.c:        qemu_log("CPU Reset (CPU %d)\n", env->cpu_index);
target-i386/cpu.c:    env->old_exception = -1;
target-i386/cpu.c:    env->hflags |= HF_SOFTMMU_MASK;
target-i386/cpu.c:    env->hflags2 |= HF2_GIF_MASK;
target-i386/cpu.c:    env->a20_mask = ~0x0;
target-i386/cpu.c:    env->smbase = 0x30000;
target-i386/cpu.c:    env->idt.limit = 0xffff;
target-i386/cpu.c:    env->gdt.limit = 0xffff;
target-i386/cpu.c:    env->ldt.limit = 0xffff;
target-i386/cpu.c:    env->ldt.flags = DESC_P_MASK | (2 << DESC_TYPE_SHIFT);
target-i386/cpu.c:    env->tr.limit = 0xffff;
target-i386/cpu.c:    env->tr.flags = DESC_P_MASK | (11 << DESC_TYPE_SHIFT);
target-i386/cpu.c:    env->eip = 0xfff0;
target-i386/cpu.c:    env->regs[R_EDX] = env->cpuid_version;
target-i386/cpu.c:    env->eflags = 0x2;
target-i386/cpu.c:        env->fptags[i] = 1;
target-i386/cpu.c:    env->fpuc = 0x37f;
target-i386/cpu.c:    env->mxcsr = 0x1f80;
target-i386/cpu.c:    env->pat = 0x0007040600070406ULL;
target-i386/cpu.c:    env->msr_ia32_misc_enable = MSR_IA32_MISC_ENABLE_DEFAULT;
target-i386/cpu.c:    memset(env->dr, 0, sizeof(env->dr));
target-i386/cpu.c:    env->dr[6] = DR6_FIXED_1;
target-i386/cpu.c:    env->dr[7] = DR7_FIXED_1;
target-i386/cpu.c:    if (((cenv->cpuid_version >> 8) & 0xf) >= 6
target-i386/cpu.c:        && (cenv->cpuid_features & (CPUID_MCE | CPUID_MCA)) ==
target-i386/cpu.c:        cenv->mcg_cap = MCE_CAP_DEF | MCE_BANKS_DEF;
target-i386/cpu.c:        cenv->mcg_ctl = ~(uint64_t)0;
target-i386/cpu.c:            cenv->mce_banks[bank * 4] = ~(uint64_t)0;
target-i386/cpu.c:    env->cpuid_apic_id = env->cpu_index;
target-i386/kvm.c:    if ((env->mcg_cap & MCG_SER_P) && addr
target-i386/kvm.c:            !kvm_physical_memory_addr_from_host(env->kvm_state, addr, &paddr)) {
target-i386/kvm.c:    if (!kvm_has_vcpu_events() && env->exception_injected == EXCP12_MCHK) {
target-i386/kvm.c:        unsigned int bank, bank_num = env->mcg_cap & 0xff;
target-i386/kvm.c:        env->exception_injected = -1;
target-i386/kvm.c:            if (env->mce_banks[bank * 4 + 1] & MCI_STATUS_VAL) {
target-i386/kvm.c:        mce.status = env->mce_banks[bank * 4 + 1];
target-i386/kvm.c:        mce.mcg_status = env->mcg_status;
target-i386/kvm.c:        mce.addr = env->mce_banks[bank * 4 + 2];
target-i386/kvm.c:        mce.misc = env->mce_banks[bank * 4 + 3];
target-i386/kvm.c:        env->tsc_valid = false;
target-i386/kvm.c:    KVMState *s = env->kvm_state;
target-i386/kvm.c:    env->cpuid_features &= kvm_arch_get_supported_cpuid(s, 1, 0, R_EDX);
target-i386/kvm.c:    i = env->cpuid_ext_features & CPUID_EXT_HYPERVISOR;
target-i386/kvm.c:    env->cpuid_ext_features &= kvm_arch_get_supported_cpuid(s, 1, 0, R_ECX);
target-i386/kvm.c:    env->cpuid_ext_features |= i;
target-i386/kvm.c:    env->cpuid_ext2_features &= kvm_arch_get_supported_cpuid(s, 0x80000001,
target-i386/kvm.c:    env->cpuid_ext3_features &= kvm_arch_get_supported_cpuid(s, 0x80000001,
target-i386/kvm.c:    env->cpuid_svm_features  &= kvm_arch_get_supported_cpuid(s, 0x8000000A,
target-i386/kvm.c:    c->eax = env->cpuid_kvm_features &
target-i386/kvm.c:    if (env->cpuid_xlevel2 > 0) {
target-i386/kvm.c:        env->cpuid_ext4_features &=
target-i386/kvm.c:    if (((env->cpuid_version >> 8)&0xF) >= 6
target-i386/kvm.c:        && (env->cpuid_features&(CPUID_MCE|CPUID_MCA)) == (CPUID_MCE|CPUID_MCA)
target-i386/kvm.c:        && kvm_check_extension(env->kvm_state, KVM_CAP_MCE) > 0) {
target-i386/kvm.c:        ret = kvm_get_mce_cap_supported(env->kvm_state, &mcg_cap, &banks);
target-i386/kvm.c:        env->mcg_cap = mcg_cap;
target-i386/kvm.c:    r = kvm_check_extension(env->kvm_state, KVM_CAP_TSC_CONTROL);
target-i386/kvm.c:    if (r && env->tsc_khz) {
target-i386/kvm.c:        r = kvm_vcpu_ioctl(env, KVM_SET_TSC_KHZ, env->tsc_khz);
target-i386/kvm.c:        env->kvm_xsave_buf = qemu_memalign(4096, sizeof(struct kvm_xsave));
target-i386/kvm.c:    env->exception_injected = -1;
target-i386/kvm.c:    env->interrupt_injected = -1;
target-i386/kvm.c:    env->xcr0 = 1;
target-i386/kvm.c:        env->mp_state = cpu_is_bsp(env) ? KVM_MP_STATE_RUNNABLE :
target-i386/kvm.c:        env->mp_state = KVM_MP_STATE_RUNNABLE;
target-i386/kvm.c:    kvm_getput_reg(&regs.rax, &env->regs[R_EAX], set);
target-i386/kvm.c:    kvm_getput_reg(&regs.rbx, &env->regs[R_EBX], set);
target-i386/kvm.c:    kvm_getput_reg(&regs.rcx, &env->regs[R_ECX], set);
target-i386/kvm.c:    kvm_getput_reg(&regs.rdx, &env->regs[R_EDX], set);
target-i386/kvm.c:    kvm_getput_reg(&regs.rsi, &env->regs[R_ESI], set);
target-i386/kvm.c:    kvm_getput_reg(&regs.rdi, &env->regs[R_EDI], set);
target-i386/kvm.c:    kvm_getput_reg(&regs.rsp, &env->regs[R_ESP], set);
target-i386/kvm.c:    kvm_getput_reg(&regs.rbp, &env->regs[R_EBP], set);
target-i386/kvm.c:    kvm_getput_reg(&regs.r8, &env->regs[8], set);
target-i386/kvm.c:    kvm_getput_reg(&regs.r9, &env->regs[9], set);
target-i386/kvm.c:    kvm_getput_reg(&regs.r10, &env->regs[10], set);
target-i386/kvm.c:    kvm_getput_reg(&regs.r11, &env->regs[11], set);
target-i386/kvm.c:    kvm_getput_reg(&regs.r12, &env->regs[12], set);
target-i386/kvm.c:    kvm_getput_reg(&regs.r13, &env->regs[13], set);
target-i386/kvm.c:    kvm_getput_reg(&regs.r14, &env->regs[14], set);
target-i386/kvm.c:    kvm_getput_reg(&regs.r15, &env->regs[15], set);
target-i386/kvm.c:    kvm_getput_reg(&regs.rflags, &env->eflags, set);
target-i386/kvm.c:    kvm_getput_reg(&regs.rip, &env->eip, set);
target-i386/kvm.c:    fpu.fsw = env->fpus & ~(7 << 11);
target-i386/kvm.c:    fpu.fsw |= (env->fpstt & 7) << 11;
target-i386/kvm.c:    fpu.fcw = env->fpuc;
target-i386/kvm.c:    fpu.last_opcode = env->fpop;
target-i386/kvm.c:    fpu.last_ip = env->fpip;
target-i386/kvm.c:    fpu.last_dp = env->fpdp;
target-i386/kvm.c:        fpu.ftwx |= (!env->fptags[i]) << i;
target-i386/kvm.c:    memcpy(fpu.fpr, env->fpregs, sizeof env->fpregs);
target-i386/kvm.c:    memcpy(fpu.xmm, env->xmm_regs, sizeof env->xmm_regs);
target-i386/kvm.c:    fpu.mxcsr = env->mxcsr;
target-i386/kvm.c:    struct kvm_xsave* xsave = env->kvm_xsave_buf;
target-i386/kvm.c:    swd = env->fpus & ~(7 << 11);
target-i386/kvm.c:    swd |= (env->fpstt & 7) << 11;
target-i386/kvm.c:    cwd = env->fpuc;
target-i386/kvm.c:        twd |= (!env->fptags[i]) << i;
target-i386/kvm.c:    xsave->region[XSAVE_FTW_FOP] = (uint32_t)(env->fpop << 16) + twd;
target-i386/kvm.c:    memcpy(&xsave->region[XSAVE_CWD_RIP], &env->fpip, sizeof(env->fpip));
target-i386/kvm.c:    memcpy(&xsave->region[XSAVE_CWD_RDP], &env->fpdp, sizeof(env->fpdp));
target-i386/kvm.c:    memcpy(&xsave->region[XSAVE_ST_SPACE], env->fpregs,
target-i386/kvm.c:            sizeof env->fpregs);
target-i386/kvm.c:    memcpy(&xsave->region[XSAVE_XMM_SPACE], env->xmm_regs,
target-i386/kvm.c:            sizeof env->xmm_regs);
target-i386/kvm.c:    xsave->region[XSAVE_MXCSR] = env->mxcsr;
target-i386/kvm.c:    *(uint64_t *)&xsave->region[XSAVE_XSTATE_BV] = env->xstate_bv;
target-i386/kvm.c:    memcpy(&xsave->region[XSAVE_YMMH_SPACE], env->ymmh_regs,
target-i386/kvm.c:            sizeof env->ymmh_regs);
target-i386/kvm.c:    xcrs.xcrs[0].value = env->xcr0;
target-i386/kvm.c:    if (env->interrupt_injected >= 0) {
target-i386/kvm.c:        sregs.interrupt_bitmap[env->interrupt_injected / 64] |=
target-i386/kvm.c:                (uint64_t)1 << (env->interrupt_injected % 64);
target-i386/kvm.c:    if ((env->eflags & VM_MASK)) {
target-i386/kvm.c:        set_v8086_seg(&sregs.cs, &env->segs[R_CS]);
target-i386/kvm.c:        set_v8086_seg(&sregs.ds, &env->segs[R_DS]);
target-i386/kvm.c:        set_v8086_seg(&sregs.es, &env->segs[R_ES]);
target-i386/kvm.c:        set_v8086_seg(&sregs.fs, &env->segs[R_FS]);
target-i386/kvm.c:        set_v8086_seg(&sregs.gs, &env->segs[R_GS]);
target-i386/kvm.c:        set_v8086_seg(&sregs.ss, &env->segs[R_SS]);
target-i386/kvm.c:        set_seg(&sregs.cs, &env->segs[R_CS]);
target-i386/kvm.c:        set_seg(&sregs.ds, &env->segs[R_DS]);
target-i386/kvm.c:        set_seg(&sregs.es, &env->segs[R_ES]);
target-i386/kvm.c:        set_seg(&sregs.fs, &env->segs[R_FS]);
target-i386/kvm.c:        set_seg(&sregs.gs, &env->segs[R_GS]);
target-i386/kvm.c:        set_seg(&sregs.ss, &env->segs[R_SS]);
target-i386/kvm.c:    set_seg(&sregs.tr, &env->tr);
target-i386/kvm.c:    set_seg(&sregs.ldt, &env->ldt);
target-i386/kvm.c:    sregs.idt.limit = env->idt.limit;
target-i386/kvm.c:    sregs.idt.base = env->idt.base;
target-i386/kvm.c:    sregs.gdt.limit = env->gdt.limit;
target-i386/kvm.c:    sregs.gdt.base = env->gdt.base;
target-i386/kvm.c:    sregs.cr0 = env->cr[0];
target-i386/kvm.c:    sregs.cr2 = env->cr[2];
target-i386/kvm.c:    sregs.cr3 = env->cr[3];
target-i386/kvm.c:    sregs.cr4 = env->cr[4];
target-i386/kvm.c:    sregs.cr8 = cpu_get_apic_tpr(env->apic_state);
target-i386/kvm.c:    sregs.apic_base = cpu_get_apic_base(env->apic_state);
target-i386/kvm.c:    sregs.efer = env->efer;
target-i386/kvm.c:    kvm_msr_entry_set(&msrs[n++], MSR_IA32_SYSENTER_CS, env->sysenter_cs);
target-i386/kvm.c:    kvm_msr_entry_set(&msrs[n++], MSR_IA32_SYSENTER_ESP, env->sysenter_esp);
target-i386/kvm.c:    kvm_msr_entry_set(&msrs[n++], MSR_IA32_SYSENTER_EIP, env->sysenter_eip);
target-i386/kvm.c:    kvm_msr_entry_set(&msrs[n++], MSR_PAT, env->pat);
target-i386/kvm.c:        kvm_msr_entry_set(&msrs[n++], MSR_STAR, env->star);
target-i386/kvm.c:        kvm_msr_entry_set(&msrs[n++], MSR_VM_HSAVE_PA, env->vm_hsave);
target-i386/kvm.c:        kvm_msr_entry_set(&msrs[n++], MSR_IA32_TSCDEADLINE, env->tsc_deadline);
target-i386/kvm.c:                          env->msr_ia32_misc_enable);
target-i386/kvm.c:        kvm_msr_entry_set(&msrs[n++], MSR_CSTAR, env->cstar);
target-i386/kvm.c:        kvm_msr_entry_set(&msrs[n++], MSR_KERNELGSBASE, env->kernelgsbase);
target-i386/kvm.c:        kvm_msr_entry_set(&msrs[n++], MSR_FMASK, env->fmask);
target-i386/kvm.c:        kvm_msr_entry_set(&msrs[n++], MSR_LSTAR, env->lstar);
target-i386/kvm.c:        if (smp_cpus == 1 || env->tsc != 0) {
target-i386/kvm.c:            kvm_msr_entry_set(&msrs[n++], MSR_IA32_TSC, env->tsc);
target-i386/kvm.c:                          env->system_time_msr);
target-i386/kvm.c:        kvm_msr_entry_set(&msrs[n++], MSR_KVM_WALL_CLOCK, env->wall_clock_msr);
target-i386/kvm.c:                              env->async_pf_en_msr);
target-i386/kvm.c:    if (env->mcg_cap) {
target-i386/kvm.c:        kvm_msr_entry_set(&msrs[n++], MSR_MCG_STATUS, env->mcg_status);
target-i386/kvm.c:        kvm_msr_entry_set(&msrs[n++], MSR_MCG_CTL, env->mcg_ctl);
target-i386/kvm.c:        for (i = 0; i < (env->mcg_cap & 0xff) * 4; i++) {
target-i386/kvm.c:            kvm_msr_entry_set(&msrs[n++], MSR_MC0_CTL + i, env->mce_banks[i]);
target-i386/kvm.c:    env->fpstt = (fpu.fsw >> 11) & 7;
target-i386/kvm.c:    env->fpus = fpu.fsw;
target-i386/kvm.c:    env->fpuc = fpu.fcw;
target-i386/kvm.c:    env->fpop = fpu.last_opcode;
target-i386/kvm.c:    env->fpip = fpu.last_ip;
target-i386/kvm.c:    env->fpdp = fpu.last_dp;
target-i386/kvm.c:        env->fptags[i] = !((fpu.ftwx >> i) & 1);
target-i386/kvm.c:    memcpy(env->fpregs, fpu.fpr, sizeof env->fpregs);
target-i386/kvm.c:    memcpy(env->xmm_regs, fpu.xmm, sizeof env->xmm_regs);
target-i386/kvm.c:    env->mxcsr = fpu.mxcsr;
target-i386/kvm.c:    struct kvm_xsave* xsave = env->kvm_xsave_buf;
target-i386/kvm.c:    env->fpop = (uint16_t)(xsave->region[XSAVE_FTW_FOP] >> 16);
target-i386/kvm.c:    env->fpstt = (swd >> 11) & 7;
target-i386/kvm.c:    env->fpus = swd;
target-i386/kvm.c:    env->fpuc = cwd;
target-i386/kvm.c:        env->fptags[i] = !((twd >> i) & 1);
target-i386/kvm.c:    memcpy(&env->fpip, &xsave->region[XSAVE_CWD_RIP], sizeof(env->fpip));
target-i386/kvm.c:    memcpy(&env->fpdp, &xsave->region[XSAVE_CWD_RDP], sizeof(env->fpdp));
target-i386/kvm.c:    env->mxcsr = xsave->region[XSAVE_MXCSR];
target-i386/kvm.c:    memcpy(env->fpregs, &xsave->region[XSAVE_ST_SPACE],
target-i386/kvm.c:            sizeof env->fpregs);
target-i386/kvm.c:    memcpy(env->xmm_regs, &xsave->region[XSAVE_XMM_SPACE],
target-i386/kvm.c:            sizeof env->xmm_regs);
target-i386/kvm.c:    env->xstate_bv = *(uint64_t *)&xsave->region[XSAVE_XSTATE_BV];
target-i386/kvm.c:    memcpy(env->ymmh_regs, &xsave->region[XSAVE_YMMH_SPACE],
target-i386/kvm.c:            sizeof env->ymmh_regs);
target-i386/kvm.c:            env->xcr0 = xcrs.xcrs[0].value;
target-i386/kvm.c:    env->interrupt_injected = -1;
target-i386/kvm.c:            env->interrupt_injected = i * 64 + bit;
target-i386/kvm.c:    get_seg(&env->segs[R_CS], &sregs.cs);
target-i386/kvm.c:    get_seg(&env->segs[R_DS], &sregs.ds);
target-i386/kvm.c:    get_seg(&env->segs[R_ES], &sregs.es);
target-i386/kvm.c:    get_seg(&env->segs[R_FS], &sregs.fs);
target-i386/kvm.c:    get_seg(&env->segs[R_GS], &sregs.gs);
target-i386/kvm.c:    get_seg(&env->segs[R_SS], &sregs.ss);
target-i386/kvm.c:    get_seg(&env->tr, &sregs.tr);
target-i386/kvm.c:    get_seg(&env->ldt, &sregs.ldt);
target-i386/kvm.c:    env->idt.limit = sregs.idt.limit;
target-i386/kvm.c:    env->idt.base = sregs.idt.base;
target-i386/kvm.c:    env->gdt.limit = sregs.gdt.limit;
target-i386/kvm.c:    env->gdt.base = sregs.gdt.base;
target-i386/kvm.c:    env->cr[0] = sregs.cr0;
target-i386/kvm.c:    env->cr[2] = sregs.cr2;
target-i386/kvm.c:    env->cr[3] = sregs.cr3;
target-i386/kvm.c:    env->cr[4] = sregs.cr4;
target-i386/kvm.c:    env->efer = sregs.efer;
target-i386/kvm.c:    hflags = (env->segs[R_CS].flags >> DESC_DPL_SHIFT) & HF_CPL_MASK;
target-i386/kvm.c:    hflags |= (env->cr[0] & CR0_PE_MASK) << (HF_PE_SHIFT - CR0_PE_SHIFT);
target-i386/kvm.c:    hflags |= (env->cr[0] << (HF_MP_SHIFT - CR0_MP_SHIFT)) &
target-i386/kvm.c:    hflags |= (env->eflags & (HF_TF_MASK | HF_VM_MASK | HF_IOPL_MASK));
target-i386/kvm.c:    hflags |= (env->cr[4] & CR4_OSFXSR_MASK) <<
target-i386/kvm.c:    if (env->efer & MSR_EFER_LMA) {
target-i386/kvm.c:    if ((hflags & HF_LMA_MASK) && (env->segs[R_CS].flags & DESC_L_MASK)) {
target-i386/kvm.c:        hflags |= (env->segs[R_CS].flags & DESC_B_MASK) >>
target-i386/kvm.c:        hflags |= (env->segs[R_SS].flags & DESC_B_MASK) >>
target-i386/kvm.c:        if (!(env->cr[0] & CR0_PE_MASK) || (env->eflags & VM_MASK) ||
target-i386/kvm.c:            hflags |= ((env->segs[R_DS].base | env->segs[R_ES].base |
target-i386/kvm.c:                        env->segs[R_SS].base) != 0) << HF_ADDSEG_SHIFT;
target-i386/kvm.c:    env->hflags = (env->hflags & HFLAG_COPY_MASK) | hflags;
target-i386/kvm.c:    if (!env->tsc_valid) {
target-i386/kvm.c:        env->tsc_valid = !runstate_is_running();
target-i386/kvm.c:    if (env->mcg_cap) {
target-i386/kvm.c:        for (i = 0; i < (env->mcg_cap & 0xff) * 4; i++) {
target-i386/kvm.c:            env->sysenter_cs = msrs[i].data;
target-i386/kvm.c:            env->sysenter_esp = msrs[i].data;
target-i386/kvm.c:            env->sysenter_eip = msrs[i].data;
target-i386/kvm.c:            env->pat = msrs[i].data;
target-i386/kvm.c:            env->star = msrs[i].data;
target-i386/kvm.c:            env->cstar = msrs[i].data;
target-i386/kvm.c:            env->kernelgsbase = msrs[i].data;
target-i386/kvm.c:            env->fmask = msrs[i].data;
target-i386/kvm.c:            env->lstar = msrs[i].data;
target-i386/kvm.c:            env->tsc = msrs[i].data;
target-i386/kvm.c:            env->tsc_deadline = msrs[i].data;
target-i386/kvm.c:            env->vm_hsave = msrs[i].data;
target-i386/kvm.c:            env->system_time_msr = msrs[i].data;
target-i386/kvm.c:            env->wall_clock_msr = msrs[i].data;
target-i386/kvm.c:            env->mcg_status = msrs[i].data;
target-i386/kvm.c:            env->mcg_ctl = msrs[i].data;
target-i386/kvm.c:            env->msr_ia32_misc_enable = msrs[i].data;
target-i386/kvm.c:                msrs[i].index < MSR_MC0_CTL + (env->mcg_cap & 0xff) * 4) {
target-i386/kvm.c:                env->mce_banks[msrs[i].index - MSR_MC0_CTL] = msrs[i].data;
target-i386/kvm.c:            env->async_pf_en_msr = msrs[i].data;
target-i386/kvm.c:    struct kvm_mp_state mp_state = { .mp_state = env->mp_state };
target-i386/kvm.c:    env->mp_state = mp_state.mp_state;
target-i386/kvm.c:        env->halted = (mp_state.mp_state == KVM_MP_STATE_HALTED);
target-i386/kvm.c:    DeviceState *apic = env->apic_state;
target-i386/kvm.c:    DeviceState *apic = env->apic_state;
target-i386/kvm.c:    events.exception.injected = (env->exception_injected >= 0);
target-i386/kvm.c:    events.exception.nr = env->exception_injected;
target-i386/kvm.c:    events.exception.has_error_code = env->has_error_code;
target-i386/kvm.c:    events.exception.error_code = env->error_code;
target-i386/kvm.c:    events.interrupt.injected = (env->interrupt_injected >= 0);
target-i386/kvm.c:    events.interrupt.nr = env->interrupt_injected;
target-i386/kvm.c:    events.interrupt.soft = env->soft_interrupt;
target-i386/kvm.c:    events.nmi.injected = env->nmi_injected;
target-i386/kvm.c:    events.nmi.pending = env->nmi_pending;
target-i386/kvm.c:    events.nmi.masked = !!(env->hflags2 & HF2_NMI_MASK);
target-i386/kvm.c:    events.sipi_vector = env->sipi_vector;
target-i386/kvm.c:    env->exception_injected =
target-i386/kvm.c:    env->has_error_code = events.exception.has_error_code;
target-i386/kvm.c:    env->error_code = events.exception.error_code;
target-i386/kvm.c:    env->interrupt_injected =
target-i386/kvm.c:    env->soft_interrupt = events.interrupt.soft;
target-i386/kvm.c:    env->nmi_injected = events.nmi.injected;
target-i386/kvm.c:    env->nmi_pending = events.nmi.pending;
target-i386/kvm.c:        env->hflags2 |= HF2_NMI_MASK;
target-i386/kvm.c:        env->hflags2 &= ~HF2_NMI_MASK;
target-i386/kvm.c:    env->sipi_vector = events.sipi_vector;
target-i386/kvm.c:        if (env->exception_injected == 1) {
target-i386/kvm.c:        } else if (env->exception_injected == 3) {
target-i386/kvm.c:        env->exception_injected = -1;
target-i386/kvm.c:        (!kvm_has_robust_singlestep() && env->singlestep_enabled)) {
target-i386/kvm.c:        dbgregs.db[i] = env->dr[i];
target-i386/kvm.c:    dbgregs.dr6 = env->dr[6];
target-i386/kvm.c:    dbgregs.dr7 = env->dr[7];
target-i386/kvm.c:        env->dr[i] = dbgregs.db[i];
target-i386/kvm.c:    env->dr[4] = env->dr[6] = dbgregs.dr6;
target-i386/kvm.c:    env->dr[5] = env->dr[7] = dbgregs.dr7;
target-i386/kvm.c:    if (env->interrupt_request & CPU_INTERRUPT_NMI) {
target-i386/kvm.c:        env->interrupt_request &= ~CPU_INTERRUPT_NMI;
target-i386/kvm.c:        if (env->interrupt_request &
target-i386/kvm.c:            env->exit_request = 1;
target-i386/kvm.c:            (env->interrupt_request & CPU_INTERRUPT_HARD) &&
target-i386/kvm.c:            (env->eflags & IF_MASK)) {
target-i386/kvm.c:            env->interrupt_request &= ~CPU_INTERRUPT_HARD;
target-i386/kvm.c:        if ((env->interrupt_request & CPU_INTERRUPT_HARD)) {
target-i386/kvm.c:        run->cr8 = cpu_get_apic_tpr(env->apic_state);
target-i386/kvm.c:        env->eflags |= IF_MASK;
target-i386/kvm.c:        env->eflags &= ~IF_MASK;
target-i386/kvm.c:    cpu_set_apic_tpr(env->apic_state, run->cr8);
target-i386/kvm.c:    cpu_set_apic_base(env->apic_state, run->apic_base);
target-i386/kvm.c:    if (env->interrupt_request & CPU_INTERRUPT_MCE) {
target-i386/kvm.c:        assert(env->mcg_cap);
target-i386/kvm.c:        env->interrupt_request &= ~CPU_INTERRUPT_MCE;
target-i386/kvm.c:        if (env->exception_injected == EXCP08_DBLE) {
target-i386/kvm.c:            env->exit_request = 1;
target-i386/kvm.c:        env->exception_injected = EXCP12_MCHK;
target-i386/kvm.c:        env->has_error_code = 0;
target-i386/kvm.c:        env->halted = 0;
target-i386/kvm.c:        if (kvm_irqchip_in_kernel() && env->mp_state == KVM_MP_STATE_HALTED) {
target-i386/kvm.c:            env->mp_state = KVM_MP_STATE_RUNNABLE;
target-i386/kvm.c:    if (((env->interrupt_request & CPU_INTERRUPT_HARD) &&
target-i386/kvm.c:         (env->eflags & IF_MASK)) ||
target-i386/kvm.c:        (env->interrupt_request & CPU_INTERRUPT_NMI)) {
target-i386/kvm.c:        env->halted = 0;
target-i386/kvm.c:    if (env->interrupt_request & CPU_INTERRUPT_INIT) {
target-i386/kvm.c:    if (env->interrupt_request & CPU_INTERRUPT_SIPI) {
target-i386/kvm.c:    if (env->interrupt_request & CPU_INTERRUPT_TPR) {
target-i386/kvm.c:        env->interrupt_request &= ~CPU_INTERRUPT_TPR;
target-i386/kvm.c:        apic_handle_tpr_access_report(env->apic_state, env->eip,
target-i386/kvm.c:                                      env->tpr_access_type);
target-i386/kvm.c:    return env->halted;
target-i386/kvm.c:    if (!((env->interrupt_request & CPU_INTERRUPT_HARD) &&
target-i386/kvm.c:          (env->eflags & IF_MASK)) &&
target-i386/kvm.c:        !(env->interrupt_request & CPU_INTERRUPT_NMI)) {
target-i386/kvm.c:        env->halted = 1;
target-i386/kvm.c:    struct kvm_run *run = env->kvm_run;
target-i386/kvm.c:    apic_handle_tpr_access_report(env->apic_state, run->tpr_access.rip,
target-i386/kvm.c:            if (cpu_single_env->singlestep_enabled) {
target-i386/kvm.c:                        cpu_single_env->watchpoint_hit = &hw_watchpoint;
target-i386/kvm.c:                        cpu_single_env->watchpoint_hit = &hw_watchpoint;
target-i386/kvm.c:        assert(cpu_single_env->exception_injected == -1);
target-i386/kvm.c:        cpu_single_env->exception_injected = arch_info->exception;
target-i386/kvm.c:        cpu_single_env->has_error_code = 0;
target-i386/kvm.c:    return !(env->cr[0] & CR0_PE_MASK) ||
target-i386/kvm.c:           ((env->segs[R_CS].selector  & 3) != 3);
target-i386/helper_template.h:        env->cc_tmp = (eflags & ~(CC_C | CC_O)) |
target-i386/helper_template.h:        env->cc_tmp = -1;
target-i386/helper_template.h:        env->cc_tmp = (eflags & ~(CC_C | CC_O)) |
target-i386/helper_template.h:        env->cc_tmp = -1;
target-i386/machine.c:    return (env->fpregs_format_vmstate == 0);
target-i386/machine.c:    guess_mmx = ((env->fptag_vmstate == 0xff) &&
target-i386/machine.c:                 (env->fpus_vmstate & 0x3800) == 0);
target-i386/machine.c:    return (guess_mmx && (env->fpregs_format_vmstate == 1));
target-i386/machine.c:    guess_mmx = ((env->fptag_vmstate == 0xff) &&
target-i386/machine.c:                 (env->fpus_vmstate & 0x3800) == 0);
target-i386/machine.c:    return (!guess_mmx && (env->fpregs_format_vmstate == 1));
target-i386/machine.c:    env->fpus_vmstate = (env->fpus & ~0x3800) | (env->fpstt & 0x7) << 11;
target-i386/machine.c:    env->fptag_vmstate = 0;
target-i386/machine.c:        env->fptag_vmstate |= ((!env->fptags[i]) << i);
target-i386/machine.c:    env->fpregs_format_vmstate = 0;
target-i386/machine.c:    env->fpstt = (env->fpus_vmstate >> 11) & 7;
target-i386/machine.c:    env->fpus = env->fpus_vmstate & ~0x3800;
target-i386/machine.c:    env->fptag_vmstate ^= 0xff;
target-i386/machine.c:        env->fptags[i] = (env->fptag_vmstate >> i) & 1;
target-i386/machine.c:    return env->fpop != 0 || env->fpip != 0 || env->fpdp != 0;
target-i386/machine.c:    return env->tsc_deadline != 0;
target-i386/machine.c:    return env->msr_ia32_misc_enable != MSR_IA32_MISC_ENABLE_DEFAULT;
target-i386/translate.c:        if (CODE64(s) && cpu_single_env->cpuid_vendor1 != CPUID_VENDOR_INTEL_1)
target-i386/translate.c:        if (CODE64(s) && cpu_single_env->cpuid_vendor1 != CPUID_VENDOR_INTEL_1)
target-i386/translate.c:    dc->singlestep_enabled = env->singlestep_enabled;
target-i386/translate.c:    dc->cpuid_features = env->cpuid_features;
target-i386/translate.c:    dc->cpuid_ext_features = env->cpuid_ext_features;
target-i386/translate.c:    dc->cpuid_ext2_features = env->cpuid_ext2_features;
target-i386/translate.c:    dc->cpuid_ext3_features = env->cpuid_ext3_features;
target-i386/translate.c:    dc->jmp_opt = !(dc->tf || env->singlestep_enabled ||
target-i386/translate.c:        if (unlikely(!QTAILQ_EMPTY(&env->breakpoints))) {
target-i386/translate.c:            QTAILQ_FOREACH(bp, &env->breakpoints, entry) {
target-i386/translate.c:        qemu_log("EAX=%08x  EBX=%08x  ECX=%08x  EDX=%08x\n", (uint32_t)env->regs[0], (uint32_t)env->regs[3], (uint32_t)env->regs[1], (uint32_t)env->regs[2]);
target-i386/translate.c:        qemu_log("ESP=%08x  EBP=%08x  ESI=%08x  EDI=%08x\n", (uint32_t)env->regs[4], (uint32_t)env->regs[5], (uint32_t)env->regs[6], (uint32_t)env->regs[7]);
target-i386/translate.c:        qemu_log("CR3=%08x\n", (uint32_t)env->cr[3] );
target-i386/translate.c:    env->eip = gen_opc_pc[pc_pos] - tb->cs_base;
target-i386/translate.c:        env->cc_op = cc_op;
target-lm32/op_helper.c:    env->exception_index = index;
target-lm32/op_helper.c:    env->halted = 1;
target-lm32/op_helper.c:    env->exception_index = EXCP_HLT;
target-lm32/op_helper.c:    lm32_pic_set_im(env->pic_state, im);
target-lm32/op_helper.c:    lm32_pic_set_ip(env->pic_state, im);
target-lm32/op_helper.c:    lm32_juart_set_jtx(env->juart_state, jtx);
target-lm32/op_helper.c:    lm32_juart_set_jrx(env->juart_state, jrx);
target-lm32/op_helper.c:    return lm32_pic_get_im(env->pic_state);
target-lm32/op_helper.c:    return lm32_pic_get_ip(env->pic_state);
target-lm32/op_helper.c:    return lm32_juart_get_jtx(env->juart_state);
target-lm32/op_helper.c:    return lm32_juart_get_jrx(env->juart_state);
target-lm32/cpu.h:        env->regs[R_SP] = newsp;
target-lm32/cpu.h:    env->regs[R_R1] = 0;
target-lm32/cpu.h:    return env->ie & IE_IE;
target-lm32/cpu.h:    return env->pc;
target-lm32/cpu.h:    *pc = env->pc;
target-lm32/cpu.h:    return env->interrupt_request & CPU_INTERRUPT_HARD;
target-lm32/cpu.h:    env->pc = tb->pc;
target-lm32/helper.c:    if (env->flags & LM32_FLAG_IGNORE_MSB) {
target-lm32/helper.c:            "exception at pc=%x type=%x\n", env->pc, env->exception_index);
target-lm32/helper.c:    switch (env->exception_index) {
target-lm32/helper.c:        env->regs[R_EA] = env->pc;
target-lm32/helper.c:        env->ie |= (env->ie & IE_IE) ? IE_EIE : 0;
target-lm32/helper.c:        env->ie &= ~IE_IE;
target-lm32/helper.c:        if (env->dc & DC_RE) {
target-lm32/helper.c:            env->pc = env->deba + (env->exception_index * 32);
target-lm32/helper.c:            env->pc = env->eba + (env->exception_index * 32);
target-lm32/helper.c:        env->regs[R_BA] = env->pc;
target-lm32/helper.c:        env->ie |= (env->ie & IE_IE) ? IE_BIE : 0;
target-lm32/helper.c:        env->ie &= ~IE_IE;
target-lm32/helper.c:        env->pc = env->deba + (env->exception_index * 32);
target-lm32/helper.c:                  env->exception_index);
target-lm32/helper.c:    env->features = def->features;
target-lm32/helper.c:    env->num_bps = def->num_breakpoints;
target-lm32/helper.c:    env->num_wps = def->num_watchpoints;
target-lm32/helper.c:    env->cfg = cfg_by_def(def);
target-lm32/helper.c:        env->flags |= LM32_FLAG_IGNORE_MSB;
target-lm32/helper.c:        env->flags &= ~LM32_FLAG_IGNORE_MSB;
target-lm32/cpu.c:        qemu_log("CPU Reset (CPU %d)\n", env->cpu_index);
target-lm32/cpu.c:    env->flags = 0;
target-lm32/translate.c:    if (!(dc->env->features & LM32_FEATURE_DIVIDE)) {
target-lm32/translate.c:    if (!(dc->env->features & LM32_FEATURE_DIVIDE)) {
target-lm32/translate.c:    if (!(dc->env->features & LM32_FEATURE_MULTIPLY)) {
target-lm32/translate.c:    if (!(dc->env->features & LM32_FEATURE_SIGN_EXTEND)) {
target-lm32/translate.c:    if (!(dc->env->features & LM32_FEATURE_SIGN_EXTEND)) {
target-lm32/translate.c:    if (!(dc->env->features & LM32_FEATURE_SHIFT)) {
target-lm32/translate.c:    if (!(dc->env->features & LM32_FEATURE_SHIFT)) {
target-lm32/translate.c:    if (!(dc->env->features & LM32_FEATURE_SHIFT)) {
target-lm32/translate.c:        if (dc->env->num_bps <= no) {
target-lm32/translate.c:        if (dc->env->num_wps <= no) {
target-lm32/translate.c:    if (unlikely(!QTAILQ_EMPTY(&env->breakpoints))) {
target-lm32/translate.c:        QTAILQ_FOREACH(bp, &env->breakpoints, entry) {
target-lm32/translate.c:    dc->singlestep_enabled = env->singlestep_enabled;
target-lm32/translate.c:         && !env->singlestep_enabled
target-lm32/translate.c:    if (unlikely(env->singlestep_enabled)) {
target-lm32/translate.c:                env->pc, lookup_symbol(env->pc));
target-lm32/translate.c:             env->ie,
target-lm32/translate.c:             (env->ie & IE_IE) ? 1 : 0,
target-lm32/translate.c:             (env->ie & IE_EIE) ? 1 : 0,
target-lm32/translate.c:             (env->ie & IE_BIE) ? 1 : 0,
target-lm32/translate.c:             lm32_pic_get_im(env->pic_state),
target-lm32/translate.c:             lm32_pic_get_ip(env->pic_state));
target-lm32/translate.c:             env->eba,
target-lm32/translate.c:             env->deba);
target-lm32/translate.c:        cpu_fprintf(f, "r%2.2d=%8.8x ", i, env->regs[i]);
target-lm32/translate.c:    env->pc = gen_opc_pc[pc_pos];
target-m68k/op_helper.c:    sp = env->aregs[7];
target-m68k/op_helper.c:    env->pc = ldl_kernel(sp + 4);
target-m68k/op_helper.c:    env->sr = fmt & 0xffff;
target-m68k/op_helper.c:    env->aregs[7] = sp + 8;
target-m68k/op_helper.c:    retaddr = env->pc;
target-m68k/op_helper.c:        switch (env->exception_index) {
target-m68k/op_helper.c:                    && (env->sr & SR_S) != 0
target-m68k/op_helper.c:                    && (env->pc & 3) == 0
target-m68k/op_helper.c:                    && lduw_code(env->pc - 4) == 0x4e71
target-m68k/op_helper.c:                    && ldl_code(env->pc) == 0x4e7bf000) {
target-m68k/op_helper.c:                env->pc += 4;
target-m68k/op_helper.c:                do_m68k_semihosting(env, env->dregs[0]);
target-m68k/op_helper.c:            env->halted = 1;
target-m68k/op_helper.c:            env->exception_index = EXCP_HLT;
target-m68k/op_helper.c:        if (env->exception_index >= EXCP_TRAP0
target-m68k/op_helper.c:            && env->exception_index <= EXCP_TRAP15) {
target-m68k/op_helper.c:    vector = env->exception_index << 2;
target-m68k/op_helper.c:    sp = env->aregs[7];
target-m68k/op_helper.c:    fmt |= env->sr;
target-m68k/op_helper.c:    env->sr |= SR_S;
target-m68k/op_helper.c:        env->sr = (env->sr & ~SR_I) | (env->pending_level << SR_I_SHIFT);
target-m68k/op_helper.c:        env->sr &= ~SR_M;
target-m68k/op_helper.c:    env->aregs[7] = sp;
target-m68k/op_helper.c:    env->pc = ldl_kernel(env->vbr + vector);
target-m68k/op_helper.c:    env->exception_index = tt;
target-m68k/op_helper.c:    num = env->div1;
target-m68k/op_helper.c:    den = env->div2;
target-m68k/op_helper.c:    env->div1 = quot;
target-m68k/op_helper.c:    env->div2 = rem;
target-m68k/op_helper.c:    env->cc_dest = flags;
target-m68k/op_helper.c:    num = env->div1;
target-m68k/op_helper.c:    den = env->div2;
target-m68k/op_helper.c:    env->div1 = quot;
target-m68k/op_helper.c:    env->div2 = rem;
target-m68k/op_helper.c:    env->cc_dest = flags;
target-m68k/cpu.h:    CC_OP_DYNAMIC, /* Use env->cc_op  */
target-m68k/cpu.h:    return (env->features & (1u << feature)) != 0;
target-m68k/cpu.h:    return (env->sr & SR_S) == 0 ? 1 : 0;
target-m68k/cpu.h:        env->aregs[7] = newsp;
target-m68k/cpu.h:    env->dregs[0] = 0;
target-m68k/cpu.h:    *pc = env->pc;
target-m68k/cpu.h:    *flags = (env->fpcr & M68K_FPCR_PREC)       /* Bit  6 */
target-m68k/cpu.h:            | (env->sr & SR_S)                  /* Bit  13 */
target-m68k/cpu.h:            | ((env->macsr >> 4) & 0xf);        /* Bits 0-3 */
target-m68k/cpu.h:    return env->interrupt_request & CPU_INTERRUPT_HARD;
target-m68k/cpu.h:    env->pc = tb->pc;
target-m68k/helper.c:        stfq_p(mem_buf, env->fregs[n]);
target-m68k/helper.c:        env->fregs[n] = ldfq_p(mem_buf);
target-m68k/helper.c:    env->cpu_model_str = cpu_model;
target-m68k/helper.c:    src = env->cc_src;
target-m68k/helper.c:    dest = env->cc_dest;
target-m68k/helper.c:    env->cc_op = CC_OP_FLAGS;
target-m68k/helper.c:    env->cc_dest = flags;
target-m68k/helper.c:        env->cacr = val;
target-m68k/helper.c:        env->vbr = val;
target-m68k/helper.c:    if ((env->macsr ^ val) & (MACSR_FI | MACSR_SU)) {
target-m68k/helper.c:            regval = env->macc[i];
target-m68k/helper.c:            if (env->macsr & MACSR_FI) {
target-m68k/helper.c:            if (env->macsr & MACSR_FI) {
target-m68k/helper.c:            } else if (env->macsr & MACSR_SU) {
target-m68k/helper.c:            env->macc[i] = regval;
target-m68k/helper.c:    env->macsr = val;
target-m68k/helper.c:    env->sp[env->current_sp] = env->aregs[7];
target-m68k/helper.c:    new_sp = (env->sr & SR_S && env->cacr & M68K_CACR_EUSP)
target-m68k/helper.c:    env->aregs[7] = env->sp[new_sp];
target-m68k/helper.c:    env->current_sp = new_sp;
target-m68k/helper.c:    env->exception_index = EXCP_ACCESS;
target-m68k/helper.c:    env->mmu.ar = address;
target-m68k/helper.c:    env->pending_level = level;
target-m68k/helper.c:    env->pending_vector = vector;
target-m68k/helper.c:    old_flags = env->cc_dest;
target-m68k/helper.c:    if (env->cc_x) {
target-m68k/helper.c:        env->cc_x = (op1 <= op2);
target-m68k/helper.c:        env->cc_op = CC_OP_SUBX;
target-m68k/helper.c:        env->cc_x = (op1 < op2);
target-m68k/helper.c:        env->cc_op = CC_OP_SUB;
target-m68k/helper.c:    env->cc_dest = res;
target-m68k/helper.c:    env->cc_src = op2;
target-m68k/helper.c:    cpu_m68k_flush_flags(env, env->cc_op);
target-m68k/helper.c:    env->cc_dest &= (old_flags | ~CCF_Z);
target-m68k/helper.c:    old_flags = env->cc_dest;
target-m68k/helper.c:    if (env->cc_x) {
target-m68k/helper.c:        env->cc_x = (res <= op2);
target-m68k/helper.c:        env->cc_op = CC_OP_ADDX;
target-m68k/helper.c:        env->cc_x = (res < op2);
target-m68k/helper.c:        env->cc_op = CC_OP_ADD;
target-m68k/helper.c:    env->cc_dest = res;
target-m68k/helper.c:    env->cc_src = op2;
target-m68k/helper.c:    cpu_m68k_flush_flags(env, env->cc_op);
target-m68k/helper.c:    env->cc_dest &= (old_flags | ~CCF_Z);
target-m68k/helper.c:    env->sr = val & 0xffff;
target-m68k/helper.c:        cf = env->cc_src & CCF_C;
target-m68k/helper.c:    env->cc_src = cf;
target-m68k/helper.c:    env->cc_x = (cf != 0);
target-m68k/helper.c:    env->cc_dest = result;
target-m68k/helper.c:        cf = env->cc_src & CCF_C;
target-m68k/helper.c:    env->cc_src = cf;
target-m68k/helper.c:    env->cc_x = (cf != 0);
target-m68k/helper.c:    env->cc_dest = result;
target-m68k/helper.c:        cf = (env->cc_src & CCF_C) != 0;
target-m68k/helper.c:    env->cc_src = cf;
target-m68k/helper.c:    env->cc_x = cf;
target-m68k/helper.c:    env->cc_dest = result;
target-m68k/helper.c:    return float64_to_int32(val, &env->fp_status);
target-m68k/helper.c:    return float64_to_float32(val, &env->fp_status);
target-m68k/helper.c:    return int32_to_float64(val, &env->fp_status);
target-m68k/helper.c:    return float32_to_float64(val, &env->fp_status);
target-m68k/helper.c:    return float64_round_to_int(val, &env->fp_status);
target-m68k/helper.c:    return float64_trunc_to_int(val, &env->fp_status);
target-m68k/helper.c:    return float64_sqrt(val, &env->fp_status);
target-m68k/helper.c:    return float64_add(a, b, &env->fp_status);
target-m68k/helper.c:    return float64_sub(a, b, &env->fp_status);
target-m68k/helper.c:    return float64_mul(a, b, &env->fp_status);
target-m68k/helper.c:    return float64_div(a, b, &env->fp_status);
target-m68k/helper.c:    res = float64_sub(a, b, &env->fp_status);
target-m68k/helper.c:            if (float64_lt_quiet(a, res, &env->fp_status))
target-m68k/helper.c:    return float64_compare_quiet(val, float64_zero, &env->fp_status);
target-m68k/helper.c:    env->macc[dest] = env->macc[src];
target-m68k/helper.c:    if (env->macsr & (MACSR_PAV0 << src))
target-m68k/helper.c:        env->macsr |= mask;
target-m68k/helper.c:        env->macsr &= ~mask;
target-m68k/helper.c:        env->macsr |= MACSR_V;
target-m68k/helper.c:        if (env->macsr & MACSR_OMC) {
target-m68k/helper.c:        env->macsr |= MACSR_V;
target-m68k/helper.c:        if (env->macsr & MACSR_OMC) {
target-m68k/helper.c:    if (env->macsr & MACSR_RT) {
target-m68k/helper.c:    tmp = env->macc[acc];
target-m68k/helper.c:        env->macsr |= MACSR_V;
target-m68k/helper.c:    if (env->macsr & MACSR_V) {
target-m68k/helper.c:        env->macsr |= MACSR_PAV0 << acc;
target-m68k/helper.c:        if (env->macsr & MACSR_OMC) {
target-m68k/helper.c:    env->macc[acc] = result;
target-m68k/helper.c:    val = env->macc[acc];
target-m68k/helper.c:        env->macsr |= MACSR_V;
target-m68k/helper.c:    if (env->macsr & MACSR_V) {
target-m68k/helper.c:        env->macsr |= MACSR_PAV0 << acc;
target-m68k/helper.c:        if (env->macsr & MACSR_OMC) {
target-m68k/helper.c:    env->macc[acc] = val;
target-m68k/helper.c:    sum = env->macc[acc];
target-m68k/helper.c:        env->macsr |= MACSR_V;
target-m68k/helper.c:    if (env->macsr & MACSR_V) {
target-m68k/helper.c:        env->macsr |= MACSR_PAV0 << acc;
target-m68k/helper.c:        if (env->macsr & MACSR_OMC) {
target-m68k/helper.c:    env->macc[acc] = result;
target-m68k/helper.c:    val = env->macc[acc];
target-m68k/helper.c:        env->macsr |= MACSR_Z;
target-m68k/helper.c:        env->macsr |= MACSR_N;
target-m68k/helper.c:    if (env->macsr & (MACSR_PAV0 << acc)) {
target-m68k/helper.c:        env->macsr |= MACSR_V;
target-m68k/helper.c:    if (env->macsr & MACSR_FI) {
target-m68k/helper.c:            env->macsr |= MACSR_EV;
target-m68k/helper.c:    } else if (env->macsr & MACSR_SU) {
target-m68k/helper.c:            env->macsr |= MACSR_EV;
target-m68k/helper.c:            env->macsr |= MACSR_EV;
target-m68k/helper.c:    if (env->macsr & MACSR_SU) {
target-m68k/helper.c:    } else if (env->macsr & MACSR_RT) {
target-m68k/helper.c:    if (env->macsr & MACSR_OMC) {
target-m68k/helper.c:        if (env->macsr & MACSR_SU) {
target-m68k/helper.c:        if (env->macsr & MACSR_SU) {
target-m68k/helper.c:    val = env->macc[acc] & 0x00ff;
target-m68k/helper.c:    val = (env->macc[acc] >> 32) & 0xff00;
target-m68k/helper.c:    val |= (env->macc[acc + 1] << 16) & 0x00ff0000;
target-m68k/helper.c:    val |= (env->macc[acc + 1] >> 16) & 0xff000000;
target-m68k/helper.c:    val = (env->macc[acc] >> 32) & 0xffff;
target-m68k/helper.c:    val |= (env->macc[acc + 1] >> 16) & 0xffff0000;
target-m68k/helper.c:    res = env->macc[acc] & 0xffffffff00ull;
target-m68k/helper.c:    env->macc[acc] = res;
target-m68k/helper.c:    res = env->macc[acc + 1] & 0xffffffff00ull;
target-m68k/helper.c:    env->macc[acc + 1] = res;
target-m68k/helper.c:    res = (uint32_t)env->macc[acc];
target-m68k/helper.c:    env->macc[acc] = res;
target-m68k/helper.c:    res = (uint32_t)env->macc[acc + 1];
target-m68k/helper.c:    env->macc[acc + 1] = res;
target-m68k/helper.c:    res = (uint32_t)env->macc[acc];
target-m68k/helper.c:    env->macc[acc] = res;
target-m68k/helper.c:    res = (uint32_t)env->macc[acc + 1];
target-m68k/helper.c:    env->macc[acc + 1] = res;
target-m68k/cpu.c:    env->features |= (1u << feature);
target-m68k/cpu.c:        qemu_log("CPU Reset (CPU %d)\n", env->cpu_index);
target-m68k/cpu.c:    env->sr = 0x2700;
target-m68k/cpu.c:    env->cc_op = CC_OP_FLAGS;
target-m68k/cpu.c:    env->pc = 0;
target-m68k/translate.c:    if (s->env->macsr & MACSR_FI) {
target-m68k/translate.c:    } else if (s->env->macsr & MACSR_SU) {
target-m68k/translate.c:    if ((s->env->macsr & MACSR_OMC) != 0 && !dual) {
target-m68k/translate.c:    if (s->env->macsr & MACSR_FI) {
target-m68k/translate.c:        if (s->env->macsr & MACSR_SU)
target-m68k/translate.c:    if ((s->env->macsr & MACSR_OMC) != 0 && dual) {
target-m68k/translate.c:    if (s->env->macsr & MACSR_FI)
target-m68k/translate.c:    else if (s->env->macsr & MACSR_SU)
target-m68k/translate.c:        if ((s->env->macsr & MACSR_OMC) != 0) {
target-m68k/translate.c:        if (s->env->macsr & MACSR_FI)
target-m68k/translate.c:        else if (s->env->macsr & MACSR_SU)
target-m68k/translate.c:    if (s->env->macsr & MACSR_FI) {
target-m68k/translate.c:    } else if ((s->env->macsr & MACSR_OMC) == 0) {
target-m68k/translate.c:    } else if (s->env->macsr & MACSR_SU) {
target-m68k/translate.c:    if (s->env->macsr & MACSR_FI)
target-m68k/translate.c:    if (s->env->macsr & MACSR_FI) {
target-m68k/translate.c:    } else if (s->env->macsr & MACSR_SU) {
target-m68k/translate.c:    if (s->env->macsr & MACSR_FI)
target-m68k/translate.c:    else if (s->env->macsr & MACSR_SU)
target-m68k/translate.c:    dc->singlestep_enabled = env->singlestep_enabled;
target-m68k/translate.c:    dc->fpcr = env->fpcr;
target-m68k/translate.c:    dc->user = (env->sr & SR_S) == 0;
target-m68k/translate.c:        if (unlikely(!QTAILQ_EMPTY(&env->breakpoints))) {
target-m68k/translate.c:            QTAILQ_FOREACH(bp, &env->breakpoints, entry) {
target-m68k/translate.c:             !env->singlestep_enabled &&
target-m68k/translate.c:    if (unlikely(env->singlestep_enabled)) {
target-m68k/translate.c:        u.d = env->fregs[i];
target-m68k/translate.c:                     i, env->dregs[i], i, env->aregs[i],
target-m68k/translate.c:    cpu_fprintf (f, "PC = %08x   ", env->pc);
target-m68k/translate.c:    sr = env->sr;
target-m68k/translate.c:    cpu_fprintf (f, "FPRESULT = %12g\n", *(double *)&env->fp_result);
target-m68k/translate.c:    env->pc = gen_opc_pc[pc_pos];
target-microblaze/op_helper.c:    env->exception_index = index;
target-microblaze/op_helper.c:    qemu_log("PC=%8.8x\n", env->sregs[SR_PC]);
target-microblaze/op_helper.c:             env->sregs[SR_MSR], env->sregs[SR_ESR], env->sregs[SR_EAR],
target-microblaze/op_helper.c:             env->debug, env->imm, env->iflags);
target-microblaze/op_helper.c:             env->btaken, env->btarget,
target-microblaze/op_helper.c:             (env->sregs[SR_MSR] & MSR_UM) ? "user" : "kernel",
target-microblaze/op_helper.c:             (env->sregs[SR_MSR] & MSR_UMS) ? "user" : "kernel",
target-microblaze/op_helper.c:             (env->sregs[SR_MSR] & MSR_EIP),
target-microblaze/op_helper.c:             (env->sregs[SR_MSR] & MSR_IE));
target-microblaze/op_helper.c:        qemu_log("r%2.2d=%8.8x ", i, env->regs[i]);
target-microblaze/op_helper.c:        env->sregs[SR_MSR] |= MSR_DZ;
target-microblaze/op_helper.c:        if ((env->sregs[SR_MSR] & MSR_EE)
target-microblaze/op_helper.c:            && !(env->pvr.regs[2] & PVR2_DIV_ZERO_EXC_MASK)) {
target-microblaze/op_helper.c:            env->sregs[SR_ESR] = ESR_EC_DIVZERO;
target-microblaze/op_helper.c:    env->sregs[SR_MSR] &= ~MSR_DZ;
target-microblaze/op_helper.c:    env->sregs[SR_ESR] = ESR_EC_FPU;
target-microblaze/op_helper.c:        env->sregs[SR_FSR] |= FSR_IO;
target-microblaze/op_helper.c:        env->sregs[SR_FSR] |= FSR_DZ;
target-microblaze/op_helper.c:        env->sregs[SR_FSR] |= FSR_OF;
target-microblaze/op_helper.c:        env->sregs[SR_FSR] |= FSR_UF;
target-microblaze/op_helper.c:        && (env->pvr.regs[2] & PVR2_FPU_EXC_MASK)
target-microblaze/op_helper.c:        && (env->sregs[SR_MSR] & MSR_EE)) {
target-microblaze/op_helper.c:    set_float_exception_flags(0, &env->fp_status);
target-microblaze/op_helper.c:    fd.f = float32_add(fa.f, fb.f, &env->fp_status);
target-microblaze/op_helper.c:    flags = get_float_exception_flags(&env->fp_status);
target-microblaze/op_helper.c:    set_float_exception_flags(0, &env->fp_status);
target-microblaze/op_helper.c:    fd.f = float32_sub(fb.f, fa.f, &env->fp_status);
target-microblaze/op_helper.c:    flags = get_float_exception_flags(&env->fp_status);
target-microblaze/op_helper.c:    set_float_exception_flags(0, &env->fp_status);
target-microblaze/op_helper.c:    fd.f = float32_mul(fa.f, fb.f, &env->fp_status);
target-microblaze/op_helper.c:    flags = get_float_exception_flags(&env->fp_status);
target-microblaze/op_helper.c:    set_float_exception_flags(0, &env->fp_status);
target-microblaze/op_helper.c:    fd.f = float32_div(fb.f, fa.f, &env->fp_status);
target-microblaze/op_helper.c:    flags = get_float_exception_flags(&env->fp_status);
target-microblaze/op_helper.c:    set_float_exception_flags(0, &env->fp_status);
target-microblaze/op_helper.c:    r = float32_lt(fb.f, fa.f, &env->fp_status);
target-microblaze/op_helper.c:    flags = get_float_exception_flags(&env->fp_status);
target-microblaze/op_helper.c:    set_float_exception_flags(0, &env->fp_status);
target-microblaze/op_helper.c:    r = float32_eq_quiet(fa.f, fb.f, &env->fp_status);
target-microblaze/op_helper.c:    flags = get_float_exception_flags(&env->fp_status);
target-microblaze/op_helper.c:    set_float_exception_flags(0, &env->fp_status);
target-microblaze/op_helper.c:    r = float32_le(fa.f, fb.f, &env->fp_status);
target-microblaze/op_helper.c:    flags = get_float_exception_flags(&env->fp_status);
target-microblaze/op_helper.c:    set_float_exception_flags(0, &env->fp_status);
target-microblaze/op_helper.c:    r = float32_lt(fa.f, fb.f, &env->fp_status);
target-microblaze/op_helper.c:    flags = get_float_exception_flags(&env->fp_status);
target-microblaze/op_helper.c:    set_float_exception_flags(0, &env->fp_status);
target-microblaze/op_helper.c:    r = !float32_eq_quiet(fa.f, fb.f, &env->fp_status);
target-microblaze/op_helper.c:    flags = get_float_exception_flags(&env->fp_status);
target-microblaze/op_helper.c:    set_float_exception_flags(0, &env->fp_status);
target-microblaze/op_helper.c:    r = !float32_lt(fa.f, fb.f, &env->fp_status);
target-microblaze/op_helper.c:    flags = get_float_exception_flags(&env->fp_status);
target-microblaze/op_helper.c:    fd.f = int32_to_float32(fa.l, &env->fp_status);
target-microblaze/op_helper.c:    set_float_exception_flags(0, &env->fp_status);
target-microblaze/op_helper.c:    r = float32_to_int32(fa.f, &env->fp_status);
target-microblaze/op_helper.c:    flags = get_float_exception_flags(&env->fp_status);
target-microblaze/op_helper.c:    set_float_exception_flags(0, &env->fp_status);
target-microblaze/op_helper.c:    fd.l = float32_sqrt(fa.f, &env->fp_status);
target-microblaze/op_helper.c:    flags = get_float_exception_flags(&env->fp_status);
target-microblaze/op_helper.c:            env->sregs[SR_EAR] = addr;
target-microblaze/op_helper.c:            env->sregs[SR_ESR] = ESR_EC_UNALIGNED_DATA | (wr << 10) \
target-microblaze/op_helper.c:                env->sregs[SR_ESR] |= 1 << 11;
target-microblaze/op_helper.c:            if (!(env->sregs[SR_MSR] & MSR_EE)) {
target-microblaze/op_helper.c:    if (addr < env->slr || addr > env->shr) {
target-microblaze/op_helper.c:                     addr, env->slr, env->shr);
target-microblaze/op_helper.c:            env->sregs[SR_EAR] = addr;
target-microblaze/op_helper.c:            env->sregs[SR_ESR] = ESR_EC_STACKPROT;
target-microblaze/op_helper.c:    if (!(env->sregs[SR_MSR] & MSR_EE)) {
target-microblaze/op_helper.c:    env->sregs[SR_EAR] = addr;
target-microblaze/op_helper.c:        if ((env->pvr.regs[2] & PVR2_IOPB_BUS_EXC_MASK)) {
target-microblaze/op_helper.c:            env->sregs[SR_ESR] = ESR_EC_INSN_BUS;
target-microblaze/op_helper.c:        if ((env->pvr.regs[2] & PVR2_DOPB_BUS_EXC_MASK)) {
target-microblaze/op_helper.c:            env->sregs[SR_ESR] = ESR_EC_DATA_BUS;
target-microblaze/cpu.h:    CC_OP_DYNAMIC, /* Use env->cc_op  */
target-microblaze/cpu.h:        if (!(env->sregs[SR_MSR] & MSR_VM))
target-microblaze/cpu.h:	if (env->sregs[SR_MSR] & MSR_UM)
target-microblaze/cpu.h:        env->regs[R_SP] = newsp;
target-microblaze/cpu.h:    env->regs[3] = 0;
target-microblaze/cpu.h:    return env->sregs[SR_MSR] & MSR_IE;
target-microblaze/cpu.h:    return env->sregs[SR_PC];
target-microblaze/cpu.h:    *pc = env->sregs[SR_PC];
target-microblaze/cpu.h:    *flags = (env->iflags & IFLAGS_TB_MASK) |
target-microblaze/cpu.h:                 (env->sregs[SR_MSR] & (MSR_UM | MSR_VM | MSR_EE));
target-microblaze/cpu.h:    return env->interrupt_request & (CPU_INTERRUPT_HARD | CPU_INTERRUPT_NMI);
target-microblaze/cpu.h:    env->sregs[SR_PC] = tb->pc;
target-microblaze/helper.c:    env->exception_index = -1;
target-microblaze/helper.c:    env->regs[14] = env->sregs[SR_PC];
target-microblaze/helper.c:    env->exception_index = 0xaa;
target-microblaze/helper.c:    if (env->pvr.regs[0] & PVR0_USE_MMU) {
target-microblaze/helper.c:        if ((env->pvr.regs[0] & PVR0_PVR_FULL_MASK)
target-microblaze/helper.c:            && (env->pvr.regs[11] & PVR11_USE_MMU) != PVR11_USE_MMU) {
target-microblaze/helper.c:    if (mmu_available && (env->sregs[SR_MSR] & MSR_VM)) {
target-microblaze/helper.c:        hit = mmu_translate(&env->mmu, &lu, address, rw, mmu_idx);
target-microblaze/helper.c:            env->sregs[SR_EAR] = address;
target-microblaze/helper.c:                    env->sregs[SR_ESR] = rw == 2 ? 17 : 16;
target-microblaze/helper.c:                    env->sregs[SR_ESR] |= (rw == 1) << 10;
target-microblaze/helper.c:                    env->sregs[SR_ESR] = rw == 2 ? 19 : 18;
target-microblaze/helper.c:                    env->sregs[SR_ESR] |= (rw == 1) << 10;
target-microblaze/helper.c:            if (env->exception_index == EXCP_MMU) {
target-microblaze/helper.c:            env->exception_index = EXCP_MMU;
target-microblaze/helper.c:    assert(!((env->iflags & D_FLAG) && (env->iflags & IMM_FLAG)));
target-microblaze/helper.c:    assert(!(env->iflags & (DRTI_FLAG | DRTE_FLAG | DRTB_FLAG)));
target-microblaze/helper.c:/*    assert(env->sregs[SR_MSR] & (MSR_EE)); Only for HW exceptions.  */
target-microblaze/helper.c:    switch (env->exception_index) {
target-microblaze/helper.c:            if (!(env->pvr.regs[0] & PVR0_USE_EXC_MASK)) {
target-microblaze/helper.c:            env->regs[17] = env->sregs[SR_PC] + 4;
target-microblaze/helper.c:            env->sregs[SR_ESR] &= ~(1 << 12);
target-microblaze/helper.c:            if (env->iflags & D_FLAG) {
target-microblaze/helper.c:                env->sregs[SR_ESR] |= 1 << 12 ;
target-microblaze/helper.c:                env->sregs[SR_BTR] = env->btarget;
target-microblaze/helper.c:            t = (env->sregs[SR_MSR] & (MSR_VM | MSR_UM)) << 1;
target-microblaze/helper.c:            env->sregs[SR_MSR] &= ~(MSR_VMS | MSR_UMS | MSR_VM | MSR_UM);
target-microblaze/helper.c:            env->sregs[SR_MSR] |= t;
target-microblaze/helper.c:            env->sregs[SR_MSR] |= MSR_EIP;
target-microblaze/helper.c:                          env->sregs[SR_PC], env->sregs[SR_EAR],
target-microblaze/helper.c:                          env->sregs[SR_ESR], env->iflags);
target-microblaze/helper.c:            env->iflags &= ~(IMM_FLAG | D_FLAG);
target-microblaze/helper.c:            env->sregs[SR_PC] = 0x20;
target-microblaze/helper.c:            env->regs[17] = env->sregs[SR_PC];
target-microblaze/helper.c:            env->sregs[SR_ESR] &= ~(1 << 12);
target-microblaze/helper.c:            if (env->iflags & D_FLAG) {
target-microblaze/helper.c:                D(qemu_log("D_FLAG set at exception bimm=%d\n", env->bimm));
target-microblaze/helper.c:                env->sregs[SR_ESR] |= 1 << 12 ;
target-microblaze/helper.c:                env->sregs[SR_BTR] = env->btarget;
target-microblaze/helper.c:                env->regs[17] -= 4;
target-microblaze/helper.c:                if (env->bimm) {
target-microblaze/helper.c:                                  env->sregs[SR_PC], env->iflags);
target-microblaze/helper.c:                    env->regs[17] -= 4;
target-microblaze/helper.c:            } else if (env->iflags & IMM_FLAG) {
target-microblaze/helper.c:                env->regs[17] -= 4;
target-microblaze/helper.c:            t = (env->sregs[SR_MSR] & (MSR_VM | MSR_UM)) << 1;
target-microblaze/helper.c:            env->sregs[SR_MSR] &= ~(MSR_VMS | MSR_UMS | MSR_VM | MSR_UM);
target-microblaze/helper.c:            env->sregs[SR_MSR] |= t;
target-microblaze/helper.c:            env->sregs[SR_MSR] |= MSR_EIP;
target-microblaze/helper.c:                          env->sregs[SR_PC], env->sregs[SR_EAR], env->iflags);
target-microblaze/helper.c:            env->iflags &= ~(IMM_FLAG | D_FLAG);
target-microblaze/helper.c:            env->sregs[SR_PC] = 0x20;
target-microblaze/helper.c:            assert(!(env->sregs[SR_MSR] & (MSR_EIP | MSR_BIP)));
target-microblaze/helper.c:            assert(env->sregs[SR_MSR] & MSR_IE);
target-microblaze/helper.c:            assert(!(env->iflags & D_FLAG));
target-microblaze/helper.c:            t = (env->sregs[SR_MSR] & (MSR_VM | MSR_UM)) << 1;
target-microblaze/helper.c:                sym = lookup_symbol(env->sregs[SR_PC]);
target-microblaze/helper.c:                         env->sregs[SR_PC], env->sregs[SR_MSR], t, env->iflags,
target-microblaze/helper.c:                         env->sregs[SR_PC], env->sregs[SR_MSR], t, env->iflags);
target-microblaze/helper.c:            env->sregs[SR_MSR] &= ~(MSR_VMS | MSR_UMS | MSR_VM \
target-microblaze/helper.c:            env->sregs[SR_MSR] |= t;
target-microblaze/helper.c:            env->regs[14] = env->sregs[SR_PC];
target-microblaze/helper.c:            env->sregs[SR_PC] = 0x10;
target-microblaze/helper.c:            assert(!(env->iflags & IMM_FLAG));
target-microblaze/helper.c:            assert(!(env->iflags & D_FLAG));
target-microblaze/helper.c:            t = (env->sregs[SR_MSR] & (MSR_VM | MSR_UM)) << 1;
target-microblaze/helper.c:                        env->sregs[SR_PC], env->sregs[SR_MSR], t, env->iflags);
target-microblaze/helper.c:            env->sregs[SR_MSR] &= ~(MSR_VMS | MSR_UMS | MSR_VM | MSR_UM);
target-microblaze/helper.c:            env->sregs[SR_MSR] |= t;
target-microblaze/helper.c:            env->sregs[SR_MSR] |= MSR_BIP;
target-microblaze/helper.c:            if (env->exception_index == EXCP_HW_BREAK) {
target-microblaze/helper.c:                env->regs[16] = env->sregs[SR_PC];
target-microblaze/helper.c:                env->sregs[SR_MSR] |= MSR_BIP;
target-microblaze/helper.c:                env->sregs[SR_PC] = 0x18;
target-microblaze/helper.c:                env->sregs[SR_PC] = env->btarget;
target-microblaze/helper.c:                      env->exception_index);
target-microblaze/helper.c:    if (env->sregs[SR_MSR] & MSR_VM) {
target-microblaze/helper.c:        hit = mmu_translate(&env->mmu, &lu, addr, 0, 0);
target-microblaze/mmu.c:    struct microblaze_mmu *mmu = &env->mmu;
target-microblaze/mmu.c:    struct microblaze_mmu *mmu = &env->mmu;
target-microblaze/mmu.c:    if (env->mmu.c_mmu < 2 || !env->mmu.c_mmu_tlb_access) {
target-microblaze/mmu.c:            if (!(env->mmu.c_mmu_tlb_access & 1)) {
target-microblaze/mmu.c:            i = env->mmu.regs[MMU_R_TLBX] & 0xff;
target-microblaze/mmu.c:            r = env->mmu.rams[rn & 1][i];
target-microblaze/mmu.c:                env->mmu.regs[MMU_R_PID] = env->mmu.tids[i];
target-microblaze/mmu.c:            if (!(env->mmu.c_mmu_tlb_access & 1)) {
target-microblaze/mmu.c:            r = env->mmu.regs[rn];
target-microblaze/mmu.c:            r = env->mmu.regs[rn];
target-microblaze/mmu.c:    D(qemu_log("%s rn=%d=%x old=%x\n", __func__, rn, v, env->mmu.regs[rn]));
target-microblaze/mmu.c:    if (env->mmu.c_mmu < 2 || !env->mmu.c_mmu_tlb_access) {
target-microblaze/mmu.c:            i = env->mmu.regs[MMU_R_TLBX] & 0xff;
target-microblaze/mmu.c:                             i, env->sregs[SR_PC]);
target-microblaze/mmu.c:                env->mmu.tids[i] = env->mmu.regs[MMU_R_PID] & 0xff;
target-microblaze/mmu.c:            env->mmu.rams[rn & 1][i] = v;
target-microblaze/mmu.c:            if (env->mmu.c_mmu_tlb_access <= 1) {
target-microblaze/mmu.c:            if (v != env->mmu.regs[rn]) {
target-microblaze/mmu.c:            env->mmu.regs[rn] = v;
target-microblaze/mmu.c:            if (env->mmu.c_mmu_tlb_access <= 1) {
target-microblaze/mmu.c:            if (v != env->mmu.regs[rn]) {
target-microblaze/mmu.c:                env->mmu.regs[rn] = v;
target-microblaze/mmu.c:            if (env->mmu.c_mmu_tlb_access <= 1) {
target-microblaze/mmu.c:            hit = mmu_translate(&env->mmu, &lu,
target-microblaze/mmu.c:                env->mmu.regs[MMU_R_TLBX] = lu.idx;
target-microblaze/mmu.c:                env->mmu.regs[MMU_R_TLBX] |= 0x80000000;
target-microblaze/mmu.c:            env->mmu.regs[rn] = v;
target-microblaze/cpu.c:        qemu_log("CPU Reset (CPU %d)\n", env->cpu_index);
target-microblaze/cpu.c:    env->shr = ~0;
target-microblaze/cpu.c:    env->pvr.regs[0] = PVR0_PVR_FULL_MASK \
target-microblaze/cpu.c:    env->pvr.regs[2] = PVR2_D_OPB_MASK \
target-microblaze/cpu.c:    env->pvr.regs[10] = 0x0c000000; /* Default to spartan 3a dsp family.  */
target-microblaze/cpu.c:    env->pvr.regs[11] = PVR11_USE_MMU | (16 << 17);
target-microblaze/cpu.c:    env->sregs[SR_MSR] = MSR_EE | MSR_IE | MSR_VM | MSR_UM;
target-microblaze/cpu.c:    env->pvr.regs[10] = 0x0c000000; /* Spartan 3a dsp.  */
target-microblaze/cpu.c:    env->sregs[SR_MSR] = 0;
target-microblaze/cpu.c:    mmu_init(&env->mmu);
target-microblaze/cpu.c:    env->mmu.c_mmu = 3;
target-microblaze/cpu.c:    env->mmu.c_mmu_tlb_access = 3;
target-microblaze/cpu.c:    env->mmu.c_mmu_zones = 16;
target-microblaze/cpu.c:    set_float_rounding_mode(float_round_nearest_even, &env->fp_status);
target-microblaze/translate.c:          && (dc->env->pvr.regs[2] & PVR2_ILL_OPCODE_EXC_MASK)
target-microblaze/translate.c:          && !((dc->env->pvr.regs[2] & PVR2_USE_PCMP_INSTR))) {
target-microblaze/translate.c:        if (!(dc->env->pvr.regs[2] & PVR2_USE_MSR_INSTR)) {
target-microblaze/translate.c:         && (dc->env->pvr.regs[2] & PVR2_ILL_OPCODE_EXC_MASK)
target-microblaze/translate.c:         && !(dc->env->pvr.regs[0] & PVR0_USE_HW_MUL_MASK)) {
target-microblaze/translate.c:        && !((dc->env->pvr.regs[2] & PVR2_USE_MUL64_MASK))) {
target-microblaze/translate.c:    if ((dc->env->pvr.regs[2] & PVR2_ILL_OPCODE_EXC_MASK)
target-microblaze/translate.c:          && !((dc->env->pvr.regs[0] & PVR0_USE_DIV_MASK))) {
target-microblaze/translate.c:          && (dc->env->pvr.regs[2] & PVR2_ILL_OPCODE_EXC_MASK)
target-microblaze/translate.c:          && !(dc->env->pvr.regs[0] & PVR0_USE_BARREL_MASK)) {
target-microblaze/translate.c:                && (dc->env->pvr.regs[2] & PVR2_ILL_OPCODE_EXC_MASK)
target-microblaze/translate.c:                && !((dc->env->pvr.regs[2] & PVR2_USE_PCMP_INSTR))) {
target-microblaze/translate.c:            if (dc->env->pvr.regs[2] & PVR2_USE_PCMP_INSTR) {
target-microblaze/translate.c:          && (dc->env->pvr.regs[2] & PVR2_ILL_OPCODE_EXC_MASK)) {
target-microblaze/translate.c:    if ((dc->env->pvr.regs[2] & PVR2_UNALIGNED_EXC_MASK) && size > 1) {
target-microblaze/translate.c:          && (dc->env->pvr.regs[2] & PVR2_ILL_OPCODE_EXC_MASK)) {
target-microblaze/translate.c:    if ((dc->env->pvr.regs[2] & PVR2_UNALIGNED_EXC_MASK) && size > 1) {
target-microblaze/translate.c:    r = dc->env->pvr.regs[2] & PVR2_USE_FPU2_MASK;
target-microblaze/translate.c:          && (dc->env->pvr.regs[2] & PVR2_ILL_OPCODE_EXC_MASK)
target-microblaze/translate.c:          && !((dc->env->pvr.regs[2] & PVR2_USE_FPU_MASK))) {
target-microblaze/translate.c:          && (dc->env->pvr.regs[2] & PVR2_ILL_OPCODE_EXC_MASK)) {
target-microblaze/translate.c:              && (dc->env->pvr.regs[2] & PVR2_ILL_OPCODE_EXC_MASK)
target-microblaze/translate.c:              && (dc->env->pvr.regs[2] & PVR2_OPCODE_0x0_ILL_MASK)) {
target-microblaze/translate.c:    if (unlikely(!QTAILQ_EMPTY(&env->breakpoints))) {
target-microblaze/translate.c:        QTAILQ_FOREACH(bp, &env->breakpoints, entry) {
target-microblaze/translate.c:    dc->singlestep_enabled = env->singlestep_enabled;
target-microblaze/translate.c:        if (env->singlestep_enabled)
target-microblaze/translate.c:    if (unlikely(env->singlestep_enabled)) {
target-microblaze/translate.c:                env->sregs[SR_PC], lookup_symbol(env->sregs[SR_PC]));
target-microblaze/translate.c:             env->sregs[SR_MSR], env->sregs[SR_ESR], env->sregs[SR_EAR],
target-microblaze/translate.c:             env->debug, env->imm, env->iflags, env->sregs[SR_FSR]);
target-microblaze/translate.c:             env->btaken, env->btarget,
target-microblaze/translate.c:             (env->sregs[SR_MSR] & MSR_UM) ? "user" : "kernel",
target-microblaze/translate.c:             (env->sregs[SR_MSR] & MSR_UMS) ? "user" : "kernel",
target-microblaze/translate.c:             (env->sregs[SR_MSR] & MSR_EIP),
target-microblaze/translate.c:             (env->sregs[SR_MSR] & MSR_IE));
target-microblaze/translate.c:        cpu_fprintf(f, "r%2.2d=%8.8x ", i, env->regs[i]);
target-microblaze/translate.c:    env->sregs[SR_PC] = gen_opc_pc[pc_pos];
target-mips/op_helper.c:    env->hflags &= ~(MIPS_HFLAG_COP1X | MIPS_HFLAG_64 | MIPS_HFLAG_CP0 |
target-mips/op_helper.c:    if (!(env->CP0_Status & (1 << CP0St_EXL)) &&
target-mips/op_helper.c:        !(env->CP0_Status & (1 << CP0St_ERL)) &&
target-mips/op_helper.c:        !(env->hflags & MIPS_HFLAG_DM)) {
target-mips/op_helper.c:        env->hflags |= (env->CP0_Status >> CP0St_KSU) & MIPS_HFLAG_KSU;
target-mips/op_helper.c:    if (((env->hflags & MIPS_HFLAG_KSU) != MIPS_HFLAG_UM) ||
target-mips/op_helper.c:        (env->CP0_Status & (1 << CP0St_PX)) ||
target-mips/op_helper.c:        (env->CP0_Status & (1 << CP0St_UX))) {
target-mips/op_helper.c:        env->hflags |= MIPS_HFLAG_64;
target-mips/op_helper.c:    if (env->CP0_Status & (1 << CP0St_UX)) {
target-mips/op_helper.c:        env->hflags |= MIPS_HFLAG_UX;
target-mips/op_helper.c:    if ((env->CP0_Status & (1 << CP0St_CU0)) ||
target-mips/op_helper.c:        !(env->hflags & MIPS_HFLAG_KSU)) {
target-mips/op_helper.c:        env->hflags |= MIPS_HFLAG_CP0;
target-mips/op_helper.c:    if (env->CP0_Status & (1 << CP0St_CU1)) {
target-mips/op_helper.c:        env->hflags |= MIPS_HFLAG_FPU;
target-mips/op_helper.c:    if (env->CP0_Status & (1 << CP0St_FR)) {
target-mips/op_helper.c:        env->hflags |= MIPS_HFLAG_F64;
target-mips/op_helper.c:    if (env->insn_flags & ISA_MIPS32R2) {
target-mips/op_helper.c:        if (env->active_fpu.fcr0 & (1 << FCR0_F64)) {
target-mips/op_helper.c:            env->hflags |= MIPS_HFLAG_COP1X;
target-mips/op_helper.c:    } else if (env->insn_flags & ISA_MIPS32) {
target-mips/op_helper.c:        if (env->hflags & MIPS_HFLAG_64) {
target-mips/op_helper.c:            env->hflags |= MIPS_HFLAG_COP1X;
target-mips/op_helper.c:    } else if (env->insn_flags & ISA_MIPS4) {
target-mips/op_helper.c:        if (env->CP0_Status & (1 << CP0St_CU3)) {
target-mips/op_helper.c:            env->hflags |= MIPS_HFLAG_COP1X;
target-mips/op_helper.c:    env->exception_index = exception;
target-mips/op_helper.c:    env->error_code = error_code;
target-mips/op_helper.c:    return ((uint64_t)(env->active_tc.HI[0]) << 32) | (uint32_t)env->active_tc.LO[0];
target-mips/op_helper.c:    env->active_tc.LO[0] = (int32_t)HILO;
target-mips/op_helper.c:    env->active_tc.HI[0] = (int32_t)(HILO >> 32);
target-mips/op_helper.c:    env->active_tc.LO[0] = (int32_t)(HILO & 0xFFFFFFFF);
target-mips/op_helper.c:    arg1 = env->active_tc.HI[0] = (int32_t)(HILO >> 32);
target-mips/op_helper.c:    arg1 = env->active_tc.LO[0] = (int32_t)(HILO & 0xFFFFFFFF);
target-mips/op_helper.c:    env->active_tc.HI[0] = (int32_t)(HILO >> 32);
target-mips/op_helper.c:    muls64(&(env->active_tc.LO[0]), &(env->active_tc.HI[0]), arg1, arg2);
target-mips/op_helper.c:    mulu64(&(env->active_tc.LO[0]), &(env->active_tc.HI[0]), arg1, arg2);
target-mips/op_helper.c:    env->lladdr = do_translate_address(arg, 0);                               \
target-mips/op_helper.c:    env->llval = do_##insn(arg, mem_idx);                                     \
target-mips/op_helper.c:    return env->llval;                                                        \
target-mips/op_helper.c:        env->CP0_BadVAddr = arg2;                                             \
target-mips/op_helper.c:    if (do_translate_address(arg2, 1) == env->lladdr) {                       \
target-mips/op_helper.c:        if (tmp == env->llval) {                                              \
target-mips/op_helper.c:            env->active_tc.gpr[multiple_regs[i]] = (target_long) ldfun(addr);
target-mips/op_helper.c:        env->active_tc.gpr[31] = (target_long) ldfun(addr);
target-mips/op_helper.c:            stfun(addr, env->active_tc.gpr[multiple_regs[i]]);
target-mips/op_helper.c:        stfun(addr, env->active_tc.gpr[31]);
target-mips/op_helper.c:            env->active_tc.gpr[multiple_regs[i]] = ldfun(addr);
target-mips/op_helper.c:        env->active_tc.gpr[31] = ldfun(addr);
target-mips/op_helper.c:            stfun(addr, env->active_tc.gpr[multiple_regs[i]]);
target-mips/op_helper.c:        stfun(addr, env->active_tc.gpr[31]);
target-mips/op_helper.c:    int vpe_idx, nr_threads = env->nr_threads;
target-mips/op_helper.c:    if (!(env->CP0_VPEConf0 & (1 << CP0VPEC0_MVP))) {
target-mips/op_helper.c:        *tc = env->current_tc;
target-mips/op_helper.c:    asid = env->CP0_EntryHi & 0xff;
target-mips/op_helper.c:    return env->mvp->CP0_MVPControl;
target-mips/op_helper.c:    return env->mvp->CP0_MVPConf0;
target-mips/op_helper.c:    return env->mvp->CP0_MVPConf1;
target-mips/op_helper.c:    return env->active_tc.CP0_TCStatus;
target-mips/op_helper.c:    int other_tc = env->CP0_VPEControl & (0xff << CP0VPECo_TargTC);
target-mips/op_helper.c:    return env->active_tc.CP0_TCBind;
target-mips/op_helper.c:    int other_tc = env->CP0_VPEControl & (0xff << CP0VPECo_TargTC);
target-mips/op_helper.c:    return env->active_tc.PC;
target-mips/op_helper.c:    int other_tc = env->CP0_VPEControl & (0xff << CP0VPECo_TargTC);
target-mips/op_helper.c:    return env->active_tc.CP0_TCHalt;
target-mips/op_helper.c:    int other_tc = env->CP0_VPEControl & (0xff << CP0VPECo_TargTC);
target-mips/op_helper.c:    return env->active_tc.CP0_TCContext;
target-mips/op_helper.c:    int other_tc = env->CP0_VPEControl & (0xff << CP0VPECo_TargTC);
target-mips/op_helper.c:    return env->active_tc.CP0_TCSchedule;
target-mips/op_helper.c:    int other_tc = env->CP0_VPEControl & (0xff << CP0VPECo_TargTC);
target-mips/op_helper.c:    return env->active_tc.CP0_TCScheFBack;
target-mips/op_helper.c:    int other_tc = env->CP0_VPEControl & (0xff << CP0VPECo_TargTC);
target-mips/op_helper.c:    int other_tc = env->CP0_VPEControl & (0xff << CP0VPECo_TargTC);
target-mips/op_helper.c:    int other_tc = env->CP0_VPEControl & (0xff << CP0VPECo_TargTC);
target-mips/op_helper.c:    int other_tc = env->CP0_VPEControl & (0xff << CP0VPECo_TargTC);
target-mips/op_helper.c:    return (int32_t)(env->lladdr >> env->CP0_LLAddr_shift);
target-mips/op_helper.c:    return (int32_t)env->CP0_WatchLo[sel];
target-mips/op_helper.c:    return env->CP0_WatchHi[sel];
target-mips/op_helper.c:    target_ulong t0 = env->CP0_Debug;
target-mips/op_helper.c:    if (env->hflags & MIPS_HFLAG_DM)
target-mips/op_helper.c:    int other_tc = env->CP0_VPEControl & (0xff << CP0VPECo_TargTC);
target-mips/op_helper.c:    return env->active_tc.PC;
target-mips/op_helper.c:    return env->active_tc.CP0_TCHalt;
target-mips/op_helper.c:    return env->active_tc.CP0_TCContext;
target-mips/op_helper.c:    return env->active_tc.CP0_TCSchedule;
target-mips/op_helper.c:    return env->active_tc.CP0_TCScheFBack;
target-mips/op_helper.c:    return env->lladdr >> env->CP0_LLAddr_shift;
target-mips/op_helper.c:    return env->CP0_WatchLo[sel];
target-mips/op_helper.c:    unsigned int tmp = env->tlb->nb_tlb;
target-mips/op_helper.c:    env->CP0_Index = (env->CP0_Index & 0x80000000) | (arg1 & (num - 1));
target-mips/op_helper.c:    if (env->CP0_VPEConf0 & (1 << CP0VPEC0_MVP))
target-mips/op_helper.c:    if (env->mvp->CP0_MVPControl & (1 << CP0MVPCo_VPC))
target-mips/op_helper.c:    newval = (env->mvp->CP0_MVPControl & ~mask) | (arg1 & mask);
target-mips/op_helper.c:    env->mvp->CP0_MVPControl = newval;
target-mips/op_helper.c:    newval = (env->CP0_VPEControl & ~mask) | (arg1 & mask);
target-mips/op_helper.c:    env->CP0_VPEControl = newval;
target-mips/op_helper.c:    int other_tc = env->CP0_VPEControl & (0xff << CP0VPECo_TargTC);
target-mips/op_helper.c:    int other_tc = env->CP0_VPEControl & (0xff << CP0VPECo_TargTC);
target-mips/op_helper.c:    int other_tc = env->CP0_VPEControl & (0xff << CP0VPECo_TargTC);
target-mips/op_helper.c:    if (env->CP0_VPEConf0 & (1 << CP0VPEC0_MVP)) {
target-mips/op_helper.c:        if (env->CP0_VPEConf0 & (1 << CP0VPEC0_VPA))
target-mips/op_helper.c:    newval = (env->CP0_VPEConf0 & ~mask) | (arg1 & mask);
target-mips/op_helper.c:    env->CP0_VPEConf0 = newval;
target-mips/op_helper.c:    int other_tc = env->CP0_VPEControl & (0xff << CP0VPECo_TargTC);
target-mips/op_helper.c:    if (env->mvp->CP0_MVPControl & (1 << CP0MVPCo_VPC))
target-mips/op_helper.c:    newval = (env->CP0_VPEConf1 & ~mask) | (arg1 & mask);
target-mips/op_helper.c:    env->CP0_VPEConf1 = newval;
target-mips/op_helper.c:    env->CP0_YQMask = 0x00000000;
target-mips/op_helper.c:    env->CP0_VPEOpt = arg1 & 0x0000ffff;
target-mips/op_helper.c:    env->CP0_EntryLo0 = arg1 & 0x3FFFFFFF;
target-mips/op_helper.c:    uint32_t mask = env->CP0_TCStatus_rw_bitmask;
target-mips/op_helper.c:    newval = (env->active_tc.CP0_TCStatus & ~mask) | (arg1 & mask);
target-mips/op_helper.c:    env->active_tc.CP0_TCStatus = newval;
target-mips/op_helper.c:    sync_c0_tcstatus(env, env->current_tc, newval);
target-mips/op_helper.c:    int other_tc = env->CP0_VPEControl & (0xff << CP0VPECo_TargTC);
target-mips/op_helper.c:    if (env->mvp->CP0_MVPControl & (1 << CP0MVPCo_VPC))
target-mips/op_helper.c:    newval = (env->active_tc.CP0_TCBind & ~mask) | (arg1 & mask);
target-mips/op_helper.c:    env->active_tc.CP0_TCBind = newval;
target-mips/op_helper.c:    int other_tc = env->CP0_VPEControl & (0xff << CP0VPECo_TargTC);
target-mips/op_helper.c:    env->active_tc.PC = arg1;
target-mips/op_helper.c:    env->active_tc.CP0_TCStatus &= ~(1 << CP0TCSt_TDS);
target-mips/op_helper.c:    env->lladdr = 0ULL;
target-mips/op_helper.c:    int other_tc = env->CP0_VPEControl & (0xff << CP0VPECo_TargTC);
target-mips/op_helper.c:    env->active_tc.CP0_TCHalt = arg1 & 0x1;
target-mips/op_helper.c:    if (env->active_tc.CP0_TCHalt & 1) {
target-mips/op_helper.c:        mips_tc_sleep(env, env->current_tc);
target-mips/op_helper.c:        mips_tc_wake(env, env->current_tc);
target-mips/op_helper.c:    int other_tc = env->CP0_VPEControl & (0xff << CP0VPECo_TargTC);
target-mips/op_helper.c:    env->active_tc.CP0_TCContext = arg1;
target-mips/op_helper.c:    int other_tc = env->CP0_VPEControl & (0xff << CP0VPECo_TargTC);
target-mips/op_helper.c:    env->active_tc.CP0_TCSchedule = arg1;
target-mips/op_helper.c:    int other_tc = env->CP0_VPEControl & (0xff << CP0VPECo_TargTC);
target-mips/op_helper.c:    env->active_tc.CP0_TCScheFBack = arg1;
target-mips/op_helper.c:    int other_tc = env->CP0_VPEControl & (0xff << CP0VPECo_TargTC);
target-mips/op_helper.c:    env->CP0_EntryLo1 = arg1 & 0x3FFFFFFF;
target-mips/op_helper.c:    env->CP0_Context = (env->CP0_Context & 0x007FFFFF) | (arg1 & ~0x007FFFFF);
target-mips/op_helper.c:    env->CP0_PageMask = arg1 & (0x1FFFFFFF & (TARGET_PAGE_MASK << 1));
target-mips/op_helper.c:    env->CP0_PageGrain = 0;
target-mips/op_helper.c:    env->CP0_Wired = arg1 % env->tlb->nb_tlb;
target-mips/op_helper.c:    env->CP0_SRSConf0 |= arg1 & env->CP0_SRSConf0_rw_bitmask;
target-mips/op_helper.c:    env->CP0_SRSConf1 |= arg1 & env->CP0_SRSConf1_rw_bitmask;
target-mips/op_helper.c:    env->CP0_SRSConf2 |= arg1 & env->CP0_SRSConf2_rw_bitmask;
target-mips/op_helper.c:    env->CP0_SRSConf3 |= arg1 & env->CP0_SRSConf3_rw_bitmask;
target-mips/op_helper.c:    env->CP0_SRSConf4 |= arg1 & env->CP0_SRSConf4_rw_bitmask;
target-mips/op_helper.c:    env->CP0_HWREna = arg1 & 0x0000000F;
target-mips/op_helper.c:    val &= env->SEGMask;
target-mips/op_helper.c:    old = env->CP0_EntryHi;
target-mips/op_helper.c:    env->CP0_EntryHi = val;
target-mips/op_helper.c:    if (env->CP0_Config3 & (1 << CP0C3_MT)) {
target-mips/op_helper.c:        sync_c0_entryhi(env, env->current_tc);
target-mips/op_helper.c:    int other_tc = env->CP0_VPEControl & (0xff << CP0VPECo_TargTC);
target-mips/op_helper.c:    uint32_t mask = env->CP0_Status_rw_bitmask;
target-mips/op_helper.c:    old = env->CP0_Status;
target-mips/op_helper.c:    env->CP0_Status = (env->CP0_Status & ~mask) | val;
target-mips/op_helper.c:    if (env->CP0_Config3 & (1 << CP0C3_MT)) {
target-mips/op_helper.c:        sync_c0_status(env, env->current_tc);
target-mips/op_helper.c:                old, old & env->CP0_Cause & CP0Ca_IP_mask,
target-mips/op_helper.c:                val, val & env->CP0_Cause & CP0Ca_IP_mask,
target-mips/op_helper.c:                env->CP0_Cause);
target-mips/op_helper.c:        switch (env->hflags & MIPS_HFLAG_KSU) {
target-mips/op_helper.c:    int other_tc = env->CP0_VPEControl & (0xff << CP0VPECo_TargTC);
target-mips/op_helper.c:    env->CP0_IntCtl = (env->CP0_IntCtl & ~0x000003e0) | (arg1 & 0x000003e0);
target-mips/op_helper.c:    env->CP0_SRSCtl = (env->CP0_SRSCtl & ~mask) | (arg1 & mask);
target-mips/op_helper.c:    int other_tc = env->CP0_VPEControl & (0xff << CP0VPECo_TargTC);
target-mips/op_helper.c:    int other_tc = env->CP0_VPEControl & (0xff << CP0VPECo_TargTC);
target-mips/op_helper.c:    int other_tc = env->CP0_VPEControl & (0xff << CP0VPECo_TargTC);
target-mips/op_helper.c:    env->CP0_EBase = (env->CP0_EBase & ~0x3FFFF000) | (arg1 & 0x3FFFF000);
target-mips/op_helper.c:    int other_tc = env->CP0_VPEControl & (0xff << CP0VPECo_TargTC);
target-mips/op_helper.c:    int other_tc = env->CP0_VPEControl & (0xff << CP0VPECo_TargTC);
target-mips/op_helper.c:    env->CP0_Config0 = (env->CP0_Config0 & 0x81FFFFF8) | (arg1 & 0x00000007);
target-mips/op_helper.c:    env->CP0_Config2 = (env->CP0_Config2 & 0x8FFF0FFF);
target-mips/op_helper.c:    target_long mask = env->CP0_LLAddr_rw_bitmask;
target-mips/op_helper.c:    arg1 = arg1 << env->CP0_LLAddr_shift;
target-mips/op_helper.c:    env->lladdr = (env->lladdr & ~mask) | (arg1 & mask);
target-mips/op_helper.c:    env->CP0_WatchLo[sel] = (arg1 & ~0x7);
target-mips/op_helper.c:    env->CP0_WatchHi[sel] = (arg1 & 0x40FF0FF8);
target-mips/op_helper.c:    env->CP0_WatchHi[sel] &= ~(env->CP0_WatchHi[sel] & arg1 & 0x7);
target-mips/op_helper.c:    target_ulong mask = (1ULL << (env->SEGBITS - 7)) - 1;
target-mips/op_helper.c:    env->CP0_XContext = (env->CP0_XContext & mask) | (arg1 & ~mask);
target-mips/op_helper.c:    env->CP0_Framemask = arg1; /* XXX */
target-mips/op_helper.c:    env->CP0_Debug = (env->CP0_Debug & 0x8C03FC1F) | (arg1 & 0x13300120);
target-mips/op_helper.c:        env->hflags |= MIPS_HFLAG_DM;
target-mips/op_helper.c:        env->hflags &= ~MIPS_HFLAG_DM;
target-mips/op_helper.c:    int other_tc = env->CP0_VPEControl & (0xff << CP0VPECo_TargTC);
target-mips/op_helper.c:    env->CP0_Performance0 = arg1 & 0x000007ff;
target-mips/op_helper.c:    env->CP0_TagLo = arg1 & 0xFFFFFCF6;
target-mips/op_helper.c:    env->CP0_DataLo = arg1; /* XXX */
target-mips/op_helper.c:    env->CP0_TagHi = arg1; /* XXX */
target-mips/op_helper.c:    env->CP0_DataHi = arg1; /* XXX */
target-mips/op_helper.c:    int other_tc = env->CP0_VPEControl & (0xff << CP0VPECo_TargTC);
target-mips/op_helper.c:    int other_tc = env->CP0_VPEControl & (0xff << CP0VPECo_TargTC);
target-mips/op_helper.c:    int other_tc = env->CP0_VPEControl & (0xff << CP0VPECo_TargTC);
target-mips/op_helper.c:    int other_tc = env->CP0_VPEControl & (0xff << CP0VPECo_TargTC);
target-mips/op_helper.c:    int other_tc = env->CP0_VPEControl & (0xff << CP0VPECo_TargTC);
target-mips/op_helper.c:    int other_tc = env->CP0_VPEControl & (0xff << CP0VPECo_TargTC);
target-mips/op_helper.c:    int other_tc = env->CP0_VPEControl & (0xff << CP0VPECo_TargTC);
target-mips/op_helper.c:    int other_tc = env->CP0_VPEControl & (0xff << CP0VPECo_TargTC);
target-mips/op_helper.c:    int other_tc = env->CP0_VPEControl & (0xff << CP0VPECo_TargTC);
target-mips/op_helper.c:    int other_tc = env->CP0_VPEControl & (0xff << CP0VPECo_TargTC);
target-mips/op_helper.c:    target_ulong prev = env->mvp->CP0_MVPControl;
target-mips/op_helper.c:    target_ulong prev = env->mvp->CP0_MVPControl;
target-mips/op_helper.c:            if (env->CP0_VPEControl & (1 << CP0VPECo_YSI) &&
target-mips/op_helper.c:                env->active_tc.CP0_TCStatus & (1 << CP0TCSt_DT)) {
target-mips/op_helper.c:                env->CP0_VPEControl &= ~(0x7 << CP0VPECo_EXCPT);
target-mips/op_helper.c:                env->CP0_VPEControl |= 4 << CP0VPECo_EXCPT;
target-mips/op_helper.c:            env->CP0_VPEControl &= ~(0x7 << CP0VPECo_EXCPT);
target-mips/op_helper.c:        env->CP0_VPEControl &= ~(0x7 << CP0VPECo_EXCPT);
target-mips/op_helper.c:        env->CP0_VPEControl |= 2 << CP0VPECo_EXCPT;
target-mips/op_helper.c:    return env->CP0_YQMask;
target-mips/op_helper.c:    env->tlb->tlb_in_use = env->tlb->nb_tlb;
target-mips/op_helper.c:    /* Discard entries from env->tlb[first] onwards.  */
target-mips/op_helper.c:    while (env->tlb->tlb_in_use > first) {
target-mips/op_helper.c:        r4k_invalidate_tlb(env, --env->tlb->tlb_in_use, 0);
target-mips/op_helper.c:    tlb = &env->tlb->mmu.r4k.tlb[idx];
target-mips/op_helper.c:    tlb->VPN = env->CP0_EntryHi & (TARGET_PAGE_MASK << 1);
target-mips/op_helper.c:    tlb->VPN &= env->SEGMask;
target-mips/op_helper.c:    tlb->ASID = env->CP0_EntryHi & 0xFF;
target-mips/op_helper.c:    tlb->PageMask = env->CP0_PageMask;
target-mips/op_helper.c:    tlb->G = env->CP0_EntryLo0 & env->CP0_EntryLo1 & 1;
target-mips/op_helper.c:    tlb->V0 = (env->CP0_EntryLo0 & 2) != 0;
target-mips/op_helper.c:    tlb->D0 = (env->CP0_EntryLo0 & 4) != 0;
target-mips/op_helper.c:    tlb->C0 = (env->CP0_EntryLo0 >> 3) & 0x7;
target-mips/op_helper.c:    tlb->PFN[0] = (env->CP0_EntryLo0 >> 6) << 12;
target-mips/op_helper.c:    tlb->V1 = (env->CP0_EntryLo1 & 2) != 0;
target-mips/op_helper.c:    tlb->D1 = (env->CP0_EntryLo1 & 4) != 0;
target-mips/op_helper.c:    tlb->C1 = (env->CP0_EntryLo1 >> 3) & 0x7;
target-mips/op_helper.c:    tlb->PFN[1] = (env->CP0_EntryLo1 >> 6) << 12;
target-mips/op_helper.c:    idx = (env->CP0_Index & ~0x80000000) % env->tlb->nb_tlb;
target-mips/op_helper.c:    r4k_mips_tlb_flush_extra (env, env->tlb->nb_tlb);
target-mips/op_helper.c:    ASID = env->CP0_EntryHi & 0xFF;
target-mips/op_helper.c:    for (i = 0; i < env->tlb->nb_tlb; i++) {
target-mips/op_helper.c:        tlb = &env->tlb->mmu.r4k.tlb[i];
target-mips/op_helper.c:        tag = env->CP0_EntryHi & ~mask;
target-mips/op_helper.c:            env->CP0_Index = i;
target-mips/op_helper.c:    if (i == env->tlb->nb_tlb) {
target-mips/op_helper.c:        for (i = env->tlb->nb_tlb; i < env->tlb->tlb_in_use; i++) {
target-mips/op_helper.c:            tlb = &env->tlb->mmu.r4k.tlb[i];
target-mips/op_helper.c:            tag = env->CP0_EntryHi & ~mask;
target-mips/op_helper.c:        env->CP0_Index |= 0x80000000;
target-mips/op_helper.c:    ASID = env->CP0_EntryHi & 0xFF;
target-mips/op_helper.c:    idx = (env->CP0_Index & ~0x80000000) % env->tlb->nb_tlb;
target-mips/op_helper.c:    tlb = &env->tlb->mmu.r4k.tlb[idx];
target-mips/op_helper.c:    r4k_mips_tlb_flush_extra(env, env->tlb->nb_tlb);
target-mips/op_helper.c:    env->CP0_EntryHi = tlb->VPN | tlb->ASID;
target-mips/op_helper.c:    env->CP0_PageMask = tlb->PageMask;
target-mips/op_helper.c:    env->CP0_EntryLo0 = tlb->G | (tlb->V0 << 1) | (tlb->D0 << 2) |
target-mips/op_helper.c:    env->CP0_EntryLo1 = tlb->G | (tlb->V1 << 1) | (tlb->D1 << 2) |
target-mips/op_helper.c:    env->tlb->helper_tlbwi();
target-mips/op_helper.c:    env->tlb->helper_tlbwr();
target-mips/op_helper.c:    env->tlb->helper_tlbp();
target-mips/op_helper.c:    env->tlb->helper_tlbr();
target-mips/op_helper.c:    target_ulong t0 = env->CP0_Status;
target-mips/op_helper.c:    env->CP0_Status = t0 & ~(1 << CP0St_IE);
target-mips/op_helper.c:    target_ulong t0 = env->CP0_Status;
target-mips/op_helper.c:    env->CP0_Status = t0 | (1 << CP0St_IE);
target-mips/op_helper.c:                env->active_tc.PC, env->CP0_EPC);
target-mips/op_helper.c:        if (env->CP0_Status & (1 << CP0St_ERL))
target-mips/op_helper.c:            qemu_log(" ErrorEPC " TARGET_FMT_lx, env->CP0_ErrorEPC);
target-mips/op_helper.c:        if (env->hflags & MIPS_HFLAG_DM)
target-mips/op_helper.c:            qemu_log(" DEPC " TARGET_FMT_lx, env->CP0_DEPC);
target-mips/op_helper.c:                env->active_tc.PC, env->CP0_EPC);
target-mips/op_helper.c:        if (env->CP0_Status & (1 << CP0St_ERL))
target-mips/op_helper.c:            qemu_log(" ErrorEPC " TARGET_FMT_lx, env->CP0_ErrorEPC);
target-mips/op_helper.c:        if (env->hflags & MIPS_HFLAG_DM)
target-mips/op_helper.c:            qemu_log(" DEPC " TARGET_FMT_lx, env->CP0_DEPC);
target-mips/op_helper.c:        switch (env->hflags & MIPS_HFLAG_KSU) {
target-mips/op_helper.c:    env->active_tc.PC = error_pc & ~(target_ulong)1;
target-mips/op_helper.c:        env->hflags |= MIPS_HFLAG_M16;
target-mips/op_helper.c:        env->hflags &= ~(MIPS_HFLAG_M16);
target-mips/op_helper.c:    if (env->CP0_Status & (1 << CP0St_ERL)) {
target-mips/op_helper.c:        set_pc(env->CP0_ErrorEPC);
target-mips/op_helper.c:        env->CP0_Status &= ~(1 << CP0St_ERL);
target-mips/op_helper.c:        set_pc(env->CP0_EPC);
target-mips/op_helper.c:        env->CP0_Status &= ~(1 << CP0St_EXL);
target-mips/op_helper.c:    env->lladdr = 1;
target-mips/op_helper.c:    set_pc(env->CP0_DEPC);
target-mips/op_helper.c:    env->hflags &= MIPS_HFLAG_DM;
target-mips/op_helper.c:    env->lladdr = 1;
target-mips/op_helper.c:    if ((env->hflags & MIPS_HFLAG_CP0) ||
target-mips/op_helper.c:        (env->CP0_HWREna & (1 << 0)))
target-mips/op_helper.c:        return env->CP0_EBase & 0x3ff;
target-mips/op_helper.c:    if ((env->hflags & MIPS_HFLAG_CP0) ||
target-mips/op_helper.c:        (env->CP0_HWREna & (1 << 1)))
target-mips/op_helper.c:        return env->SYNCI_Step;
target-mips/op_helper.c:    if ((env->hflags & MIPS_HFLAG_CP0) ||
target-mips/op_helper.c:        (env->CP0_HWREna & (1 << 2)))
target-mips/op_helper.c:        return env->CP0_Count;
target-mips/op_helper.c:    if ((env->hflags & MIPS_HFLAG_CP0) ||
target-mips/op_helper.c:        (env->CP0_HWREna & (1 << 3)))
target-mips/op_helper.c:        return env->CCRes;
target-mips/op_helper.c:        if (env->active_tc.gpr[4] == 0)
target-mips/op_helper.c:            env->active_tc.gpr[2] = -1;
target-mips/op_helper.c:        env->active_tc.gpr[2] = -1;
target-mips/op_helper.c:        printf("%c", (char)(env->active_tc.gpr[4] & 0xFF));
target-mips/op_helper.c:            unsigned char *fmt = (void *)(uintptr_t)env->active_tc.gpr[4];
target-mips/op_helper.c:    env->halted = 1;
target-mips/op_helper.c:    env->CP0_BadVAddr = addr;
target-mips/op_helper.c:        helper_raise_exception_err(env->exception_index, env->error_code);
target-mips/op_helper.c:    set_float_rounding_mode(ieee_rm[env->active_fpu.fcr31 & 3], &env->active_fpu.fp_status)
target-mips/op_helper.c:    set_flush_to_zero((env->active_fpu.fcr31 & (1 << 24)) != 0, &env->active_fpu.fp_status);
target-mips/op_helper.c:        arg1 = (int32_t)env->active_fpu.fcr0;
target-mips/op_helper.c:        arg1 = ((env->active_fpu.fcr31 >> 24) & 0xfe) | ((env->active_fpu.fcr31 >> 23) & 0x1);
target-mips/op_helper.c:        arg1 = env->active_fpu.fcr31 & 0x0003f07c;
target-mips/op_helper.c:        arg1 = (env->active_fpu.fcr31 & 0x00000f83) | ((env->active_fpu.fcr31 >> 22) & 0x4);
target-mips/op_helper.c:        arg1 = (int32_t)env->active_fpu.fcr31;
target-mips/op_helper.c:        env->active_fpu.fcr31 = (env->active_fpu.fcr31 & 0x017fffff) | ((arg1 & 0xfe) << 24) |
target-mips/op_helper.c:        env->active_fpu.fcr31 = (env->active_fpu.fcr31 & 0xfffc0f83) | (arg1 & 0x0003f07c);
target-mips/op_helper.c:        env->active_fpu.fcr31 = (env->active_fpu.fcr31 & 0xfefff07c) | (arg1 & 0x00000f83) |
target-mips/op_helper.c:        env->active_fpu.fcr31 = arg1;
target-mips/op_helper.c:    set_float_exception_flags(0, &env->active_fpu.fp_status);
target-mips/op_helper.c:    if ((GET_FP_ENABLE(env->active_fpu.fcr31) | 0x20) & GET_FP_CAUSE(env->active_fpu.fcr31))
target-mips/op_helper.c:    int tmp = ieee_ex_to_mips(get_float_exception_flags(&env->active_fpu.fp_status));
target-mips/op_helper.c:    SET_FP_CAUSE(env->active_fpu.fcr31, tmp);
target-mips/op_helper.c:    if (GET_FP_ENABLE(env->active_fpu.fcr31) & tmp)
target-mips/op_helper.c:        UPDATE_FP_FLAGS(env->active_fpu.fcr31, tmp);
target-mips/op_helper.c:    return float64_sqrt(fdt0, &env->active_fpu.fp_status);
target-mips/op_helper.c:    return float32_sqrt(fst0, &env->active_fpu.fp_status);
target-mips/op_helper.c:    set_float_exception_flags(0, &env->active_fpu.fp_status);
target-mips/op_helper.c:    fdt2 = float32_to_float64(fst0, &env->active_fpu.fp_status);
target-mips/op_helper.c:    set_float_exception_flags(0, &env->active_fpu.fp_status);
target-mips/op_helper.c:    fdt2 = int32_to_float64(wt0, &env->active_fpu.fp_status);
target-mips/op_helper.c:    set_float_exception_flags(0, &env->active_fpu.fp_status);
target-mips/op_helper.c:    fdt2 = int64_to_float64(dt0, &env->active_fpu.fp_status);
target-mips/op_helper.c:    set_float_exception_flags(0, &env->active_fpu.fp_status);
target-mips/op_helper.c:    dt2 = float64_to_int64(fdt0, &env->active_fpu.fp_status);
target-mips/op_helper.c:    if (GET_FP_CAUSE(env->active_fpu.fcr31) & (FP_OVERFLOW | FP_INVALID))
target-mips/op_helper.c:    set_float_exception_flags(0, &env->active_fpu.fp_status);
target-mips/op_helper.c:    dt2 = float32_to_int64(fst0, &env->active_fpu.fp_status);
target-mips/op_helper.c:    if (GET_FP_CAUSE(env->active_fpu.fcr31) & (FP_OVERFLOW | FP_INVALID))
target-mips/op_helper.c:    set_float_exception_flags(0, &env->active_fpu.fp_status);
target-mips/op_helper.c:    fst2 = int32_to_float32(dt0 & 0XFFFFFFFF, &env->active_fpu.fp_status);
target-mips/op_helper.c:    fsth2 = int32_to_float32(dt0 >> 32, &env->active_fpu.fp_status);
target-mips/op_helper.c:    set_float_exception_flags(0, &env->active_fpu.fp_status);
target-mips/op_helper.c:    wt2 = float32_to_int32(fdt0 & 0XFFFFFFFF, &env->active_fpu.fp_status);
target-mips/op_helper.c:    wth2 = float32_to_int32(fdt0 >> 32, &env->active_fpu.fp_status);
target-mips/op_helper.c:    if (GET_FP_CAUSE(env->active_fpu.fcr31) & (FP_OVERFLOW | FP_INVALID)) {
target-mips/op_helper.c:    set_float_exception_flags(0, &env->active_fpu.fp_status);
target-mips/op_helper.c:    fst2 = float64_to_float32(fdt0, &env->active_fpu.fp_status);
target-mips/op_helper.c:    set_float_exception_flags(0, &env->active_fpu.fp_status);
target-mips/op_helper.c:    fst2 = int32_to_float32(wt0, &env->active_fpu.fp_status);
target-mips/op_helper.c:    set_float_exception_flags(0, &env->active_fpu.fp_status);
target-mips/op_helper.c:    fst2 = int64_to_float32(dt0, &env->active_fpu.fp_status);
target-mips/op_helper.c:    set_float_exception_flags(0, &env->active_fpu.fp_status);
target-mips/op_helper.c:    set_float_exception_flags(0, &env->active_fpu.fp_status);
target-mips/op_helper.c:    set_float_exception_flags(0, &env->active_fpu.fp_status);
target-mips/op_helper.c:    wt2 = float32_to_int32(fst0, &env->active_fpu.fp_status);
target-mips/op_helper.c:    if (GET_FP_CAUSE(env->active_fpu.fcr31) & (FP_OVERFLOW | FP_INVALID))
target-mips/op_helper.c:    set_float_exception_flags(0, &env->active_fpu.fp_status);
target-mips/op_helper.c:    wt2 = float64_to_int32(fdt0, &env->active_fpu.fp_status);
target-mips/op_helper.c:    if (GET_FP_CAUSE(env->active_fpu.fcr31) & (FP_OVERFLOW | FP_INVALID))
target-mips/op_helper.c:    set_float_exception_flags(0, &env->active_fpu.fp_status);
target-mips/op_helper.c:    set_float_rounding_mode(float_round_nearest_even, &env->active_fpu.fp_status);
target-mips/op_helper.c:    dt2 = float64_to_int64(fdt0, &env->active_fpu.fp_status);
target-mips/op_helper.c:    if (GET_FP_CAUSE(env->active_fpu.fcr31) & (FP_OVERFLOW | FP_INVALID))
target-mips/op_helper.c:    set_float_exception_flags(0, &env->active_fpu.fp_status);
target-mips/op_helper.c:    set_float_rounding_mode(float_round_nearest_even, &env->active_fpu.fp_status);
target-mips/op_helper.c:    dt2 = float32_to_int64(fst0, &env->active_fpu.fp_status);
target-mips/op_helper.c:    if (GET_FP_CAUSE(env->active_fpu.fcr31) & (FP_OVERFLOW | FP_INVALID))
target-mips/op_helper.c:    set_float_exception_flags(0, &env->active_fpu.fp_status);
target-mips/op_helper.c:    set_float_rounding_mode(float_round_nearest_even, &env->active_fpu.fp_status);
target-mips/op_helper.c:    wt2 = float64_to_int32(fdt0, &env->active_fpu.fp_status);
target-mips/op_helper.c:    if (GET_FP_CAUSE(env->active_fpu.fcr31) & (FP_OVERFLOW | FP_INVALID))
target-mips/op_helper.c:    set_float_exception_flags(0, &env->active_fpu.fp_status);
target-mips/op_helper.c:    set_float_rounding_mode(float_round_nearest_even, &env->active_fpu.fp_status);
target-mips/op_helper.c:    wt2 = float32_to_int32(fst0, &env->active_fpu.fp_status);
target-mips/op_helper.c:    if (GET_FP_CAUSE(env->active_fpu.fcr31) & (FP_OVERFLOW | FP_INVALID))
target-mips/op_helper.c:    set_float_exception_flags(0, &env->active_fpu.fp_status);
target-mips/op_helper.c:    dt2 = float64_to_int64_round_to_zero(fdt0, &env->active_fpu.fp_status);
target-mips/op_helper.c:    if (GET_FP_CAUSE(env->active_fpu.fcr31) & (FP_OVERFLOW | FP_INVALID))
target-mips/op_helper.c:    set_float_exception_flags(0, &env->active_fpu.fp_status);
target-mips/op_helper.c:    dt2 = float32_to_int64_round_to_zero(fst0, &env->active_fpu.fp_status);
target-mips/op_helper.c:    if (GET_FP_CAUSE(env->active_fpu.fcr31) & (FP_OVERFLOW | FP_INVALID))
target-mips/op_helper.c:    set_float_exception_flags(0, &env->active_fpu.fp_status);
target-mips/op_helper.c:    wt2 = float64_to_int32_round_to_zero(fdt0, &env->active_fpu.fp_status);
target-mips/op_helper.c:    if (GET_FP_CAUSE(env->active_fpu.fcr31) & (FP_OVERFLOW | FP_INVALID))
target-mips/op_helper.c:    set_float_exception_flags(0, &env->active_fpu.fp_status);
target-mips/op_helper.c:    wt2 = float32_to_int32_round_to_zero(fst0, &env->active_fpu.fp_status);
target-mips/op_helper.c:    if (GET_FP_CAUSE(env->active_fpu.fcr31) & (FP_OVERFLOW | FP_INVALID))
target-mips/op_helper.c:    set_float_exception_flags(0, &env->active_fpu.fp_status);
target-mips/op_helper.c:    set_float_rounding_mode(float_round_up, &env->active_fpu.fp_status);
target-mips/op_helper.c:    dt2 = float64_to_int64(fdt0, &env->active_fpu.fp_status);
target-mips/op_helper.c:    if (GET_FP_CAUSE(env->active_fpu.fcr31) & (FP_OVERFLOW | FP_INVALID))
target-mips/op_helper.c:    set_float_exception_flags(0, &env->active_fpu.fp_status);
target-mips/op_helper.c:    set_float_rounding_mode(float_round_up, &env->active_fpu.fp_status);
target-mips/op_helper.c:    dt2 = float32_to_int64(fst0, &env->active_fpu.fp_status);
target-mips/op_helper.c:    if (GET_FP_CAUSE(env->active_fpu.fcr31) & (FP_OVERFLOW | FP_INVALID))
target-mips/op_helper.c:    set_float_exception_flags(0, &env->active_fpu.fp_status);
target-mips/op_helper.c:    set_float_rounding_mode(float_round_up, &env->active_fpu.fp_status);
target-mips/op_helper.c:    wt2 = float64_to_int32(fdt0, &env->active_fpu.fp_status);
target-mips/op_helper.c:    if (GET_FP_CAUSE(env->active_fpu.fcr31) & (FP_OVERFLOW | FP_INVALID))
target-mips/op_helper.c:    set_float_exception_flags(0, &env->active_fpu.fp_status);
target-mips/op_helper.c:    set_float_rounding_mode(float_round_up, &env->active_fpu.fp_status);
target-mips/op_helper.c:    wt2 = float32_to_int32(fst0, &env->active_fpu.fp_status);
target-mips/op_helper.c:    if (GET_FP_CAUSE(env->active_fpu.fcr31) & (FP_OVERFLOW | FP_INVALID))
target-mips/op_helper.c:    set_float_exception_flags(0, &env->active_fpu.fp_status);
target-mips/op_helper.c:    set_float_rounding_mode(float_round_down, &env->active_fpu.fp_status);
target-mips/op_helper.c:    dt2 = float64_to_int64(fdt0, &env->active_fpu.fp_status);
target-mips/op_helper.c:    if (GET_FP_CAUSE(env->active_fpu.fcr31) & (FP_OVERFLOW | FP_INVALID))
target-mips/op_helper.c:    set_float_exception_flags(0, &env->active_fpu.fp_status);
target-mips/op_helper.c:    set_float_rounding_mode(float_round_down, &env->active_fpu.fp_status);
target-mips/op_helper.c:    dt2 = float32_to_int64(fst0, &env->active_fpu.fp_status);
target-mips/op_helper.c:    if (GET_FP_CAUSE(env->active_fpu.fcr31) & (FP_OVERFLOW | FP_INVALID))
target-mips/op_helper.c:    set_float_exception_flags(0, &env->active_fpu.fp_status);
target-mips/op_helper.c:    set_float_rounding_mode(float_round_down, &env->active_fpu.fp_status);
target-mips/op_helper.c:    wt2 = float64_to_int32(fdt0, &env->active_fpu.fp_status);
target-mips/op_helper.c:    if (GET_FP_CAUSE(env->active_fpu.fcr31) & (FP_OVERFLOW | FP_INVALID))
target-mips/op_helper.c:    set_float_exception_flags(0, &env->active_fpu.fp_status);
target-mips/op_helper.c:    set_float_rounding_mode(float_round_down, &env->active_fpu.fp_status);
target-mips/op_helper.c:    wt2 = float32_to_int32(fst0, &env->active_fpu.fp_status);
target-mips/op_helper.c:    if (GET_FP_CAUSE(env->active_fpu.fcr31) & (FP_OVERFLOW | FP_INVALID))
target-mips/op_helper.c:    set_float_exception_flags(0, &env->active_fpu.fp_status);
target-mips/op_helper.c:    fdt2 = float64_div(FLOAT_ONE64, fdt0, &env->active_fpu.fp_status);
target-mips/op_helper.c:    set_float_exception_flags(0, &env->active_fpu.fp_status);
target-mips/op_helper.c:    fst2 = float32_div(FLOAT_ONE32, fst0, &env->active_fpu.fp_status);
target-mips/op_helper.c:    set_float_exception_flags(0, &env->active_fpu.fp_status);
target-mips/op_helper.c:    fdt2 = float64_sqrt(fdt0, &env->active_fpu.fp_status);
target-mips/op_helper.c:    fdt2 = float64_div(FLOAT_ONE64, fdt2, &env->active_fpu.fp_status);
target-mips/op_helper.c:    set_float_exception_flags(0, &env->active_fpu.fp_status);
target-mips/op_helper.c:    fst2 = float32_sqrt(fst0, &env->active_fpu.fp_status);
target-mips/op_helper.c:    fst2 = float32_div(FLOAT_ONE32, fst2, &env->active_fpu.fp_status);
target-mips/op_helper.c:    set_float_exception_flags(0, &env->active_fpu.fp_status);
target-mips/op_helper.c:    fdt2 = float64_div(FLOAT_ONE64, fdt0, &env->active_fpu.fp_status);
target-mips/op_helper.c:    set_float_exception_flags(0, &env->active_fpu.fp_status);
target-mips/op_helper.c:    fst2 = float32_div(FLOAT_ONE32, fst0, &env->active_fpu.fp_status);
target-mips/op_helper.c:    set_float_exception_flags(0, &env->active_fpu.fp_status);
target-mips/op_helper.c:    fst2 = float32_div(FLOAT_ONE32, fdt0 & 0XFFFFFFFF, &env->active_fpu.fp_status);
target-mips/op_helper.c:    fsth2 = float32_div(FLOAT_ONE32, fdt0 >> 32, &env->active_fpu.fp_status);
target-mips/op_helper.c:    set_float_exception_flags(0, &env->active_fpu.fp_status);
target-mips/op_helper.c:    fdt2 = float64_sqrt(fdt0, &env->active_fpu.fp_status);
target-mips/op_helper.c:    fdt2 = float64_div(FLOAT_ONE64, fdt2, &env->active_fpu.fp_status);
target-mips/op_helper.c:    set_float_exception_flags(0, &env->active_fpu.fp_status);
target-mips/op_helper.c:    fst2 = float32_sqrt(fst0, &env->active_fpu.fp_status);
target-mips/op_helper.c:    fst2 = float32_div(FLOAT_ONE32, fst2, &env->active_fpu.fp_status);
target-mips/op_helper.c:    set_float_exception_flags(0, &env->active_fpu.fp_status);
target-mips/op_helper.c:    fst2 = float32_sqrt(fdt0 & 0XFFFFFFFF, &env->active_fpu.fp_status);
target-mips/op_helper.c:    fsth2 = float32_sqrt(fdt0 >> 32, &env->active_fpu.fp_status);
target-mips/op_helper.c:    fst2 = float32_div(FLOAT_ONE32, fst2, &env->active_fpu.fp_status);
target-mips/op_helper.c:    fsth2 = float32_div(FLOAT_ONE32, fsth2, &env->active_fpu.fp_status);
target-mips/op_helper.c:    set_float_exception_flags(0, &env->active_fpu.fp_status);            \
target-mips/op_helper.c:    dt2 = float64_ ## name (fdt0, fdt1, &env->active_fpu.fp_status);     \
target-mips/op_helper.c:    if (GET_FP_CAUSE(env->active_fpu.fcr31) & FP_INVALID)                \
target-mips/op_helper.c:    set_float_exception_flags(0, &env->active_fpu.fp_status);            \
target-mips/op_helper.c:    wt2 = float32_ ## name (fst0, fst1, &env->active_fpu.fp_status);     \
target-mips/op_helper.c:    if (GET_FP_CAUSE(env->active_fpu.fcr31) & FP_INVALID)                \
target-mips/op_helper.c:    set_float_exception_flags(0, &env->active_fpu.fp_status);            \
target-mips/op_helper.c:    wt2 = float32_ ## name (fst0, fst1, &env->active_fpu.fp_status);     \
target-mips/op_helper.c:    wth2 = float32_ ## name (fsth0, fsth1, &env->active_fpu.fp_status);  \
target-mips/op_helper.c:    if (GET_FP_CAUSE(env->active_fpu.fcr31) & FP_INVALID) {              \
target-mips/op_helper.c:    fdt0 = float64_ ## name1 (fdt0, fdt1, &env->active_fpu.fp_status);          \
target-mips/op_helper.c:    return float64_ ## name2 (fdt0, fdt2, &env->active_fpu.fp_status);          \
target-mips/op_helper.c:    fst0 = float32_ ## name1 (fst0, fst1, &env->active_fpu.fp_status);          \
target-mips/op_helper.c:    return float32_ ## name2 (fst0, fst2, &env->active_fpu.fp_status);          \
target-mips/op_helper.c:    fst0 = float32_ ## name1 (fst0, fst1, &env->active_fpu.fp_status);          \
target-mips/op_helper.c:    fsth0 = float32_ ## name1 (fsth0, fsth1, &env->active_fpu.fp_status);       \
target-mips/op_helper.c:    fst2 = float32_ ## name2 (fst0, fst2, &env->active_fpu.fp_status);          \
target-mips/op_helper.c:    fsth2 = float32_ ## name2 (fsth0, fsth2, &env->active_fpu.fp_status);       \
target-mips/op_helper.c:    fdt0 = float64_ ## name1 (fdt0, fdt1, &env->active_fpu.fp_status);          \
target-mips/op_helper.c:    fdt2 = float64_ ## name2 (fdt0, fdt2, &env->active_fpu.fp_status);          \
target-mips/op_helper.c:    fst0 = float32_ ## name1 (fst0, fst1, &env->active_fpu.fp_status);          \
target-mips/op_helper.c:    fst2 = float32_ ## name2 (fst0, fst2, &env->active_fpu.fp_status);          \
target-mips/op_helper.c:    fst0 = float32_ ## name1 (fst0, fst1, &env->active_fpu.fp_status);          \
target-mips/op_helper.c:    fsth0 = float32_ ## name1 (fsth0, fsth1, &env->active_fpu.fp_status);       \
target-mips/op_helper.c:    fst2 = float32_ ## name2 (fst0, fst2, &env->active_fpu.fp_status);          \
target-mips/op_helper.c:    fsth2 = float32_ ## name2 (fsth0, fsth2, &env->active_fpu.fp_status);       \
target-mips/op_helper.c:    set_float_exception_flags(0, &env->active_fpu.fp_status);
target-mips/op_helper.c:    fdt2 = float64_mul(fdt0, fdt2, &env->active_fpu.fp_status);
target-mips/op_helper.c:    fdt2 = float64_chs(float64_sub(fdt2, FLOAT_ONE64, &env->active_fpu.fp_status));
target-mips/op_helper.c:    set_float_exception_flags(0, &env->active_fpu.fp_status);
target-mips/op_helper.c:    fst2 = float32_mul(fst0, fst2, &env->active_fpu.fp_status);
target-mips/op_helper.c:    fst2 = float32_chs(float32_sub(fst2, FLOAT_ONE32, &env->active_fpu.fp_status));
target-mips/op_helper.c:    set_float_exception_flags(0, &env->active_fpu.fp_status);
target-mips/op_helper.c:    fst2 = float32_mul(fst0, fst2, &env->active_fpu.fp_status);
target-mips/op_helper.c:    fsth2 = float32_mul(fsth0, fsth2, &env->active_fpu.fp_status);
target-mips/op_helper.c:    fst2 = float32_chs(float32_sub(fst2, FLOAT_ONE32, &env->active_fpu.fp_status));
target-mips/op_helper.c:    fsth2 = float32_chs(float32_sub(fsth2, FLOAT_ONE32, &env->active_fpu.fp_status));
target-mips/op_helper.c:    set_float_exception_flags(0, &env->active_fpu.fp_status);
target-mips/op_helper.c:    fdt2 = float64_mul(fdt0, fdt2, &env->active_fpu.fp_status);
target-mips/op_helper.c:    fdt2 = float64_sub(fdt2, FLOAT_ONE64, &env->active_fpu.fp_status);
target-mips/op_helper.c:    fdt2 = float64_chs(float64_div(fdt2, FLOAT_TWO64, &env->active_fpu.fp_status));
target-mips/op_helper.c:    set_float_exception_flags(0, &env->active_fpu.fp_status);
target-mips/op_helper.c:    fst2 = float32_mul(fst0, fst2, &env->active_fpu.fp_status);
target-mips/op_helper.c:    fst2 = float32_sub(fst2, FLOAT_ONE32, &env->active_fpu.fp_status);
target-mips/op_helper.c:    fst2 = float32_chs(float32_div(fst2, FLOAT_TWO32, &env->active_fpu.fp_status));
target-mips/op_helper.c:    set_float_exception_flags(0, &env->active_fpu.fp_status);
target-mips/op_helper.c:    fst2 = float32_mul(fst0, fst2, &env->active_fpu.fp_status);
target-mips/op_helper.c:    fsth2 = float32_mul(fsth0, fsth2, &env->active_fpu.fp_status);
target-mips/op_helper.c:    fst2 = float32_sub(fst2, FLOAT_ONE32, &env->active_fpu.fp_status);
target-mips/op_helper.c:    fsth2 = float32_sub(fsth2, FLOAT_ONE32, &env->active_fpu.fp_status);
target-mips/op_helper.c:    fst2 = float32_chs(float32_div(fst2, FLOAT_TWO32, &env->active_fpu.fp_status));
target-mips/op_helper.c:    fsth2 = float32_chs(float32_div(fsth2, FLOAT_TWO32, &env->active_fpu.fp_status));
target-mips/op_helper.c:    set_float_exception_flags(0, &env->active_fpu.fp_status);
target-mips/op_helper.c:    fst2 = float32_add (fst0, fsth0, &env->active_fpu.fp_status);
target-mips/op_helper.c:    fsth2 = float32_add (fst1, fsth1, &env->active_fpu.fp_status);
target-mips/op_helper.c:    set_float_exception_flags(0, &env->active_fpu.fp_status);
target-mips/op_helper.c:    fst2 = float32_mul (fst0, fsth0, &env->active_fpu.fp_status);
target-mips/op_helper.c:    fsth2 = float32_mul (fst1, fsth1, &env->active_fpu.fp_status);
target-mips/op_helper.c:    set_float_exception_flags(0, &env->active_fpu.fp_status);  \
target-mips/op_helper.c:        SET_FP_COND(cc, env->active_fpu);                      \
target-mips/op_helper.c:        CLEAR_FP_COND(cc, env->active_fpu);                    \
target-mips/op_helper.c:    set_float_exception_flags(0, &env->active_fpu.fp_status);  \
target-mips/op_helper.c:        SET_FP_COND(cc, env->active_fpu);                      \
target-mips/op_helper.c:        CLEAR_FP_COND(cc, env->active_fpu);                    \
target-mips/op_helper.c:FOP_COND_D(f,   (float64_unordered_quiet(fdt1, fdt0, &env->active_fpu.fp_status), 0))
target-mips/op_helper.c:FOP_COND_D(un,  float64_unordered_quiet(fdt1, fdt0, &env->active_fpu.fp_status))
target-mips/op_helper.c:FOP_COND_D(eq,  float64_eq_quiet(fdt0, fdt1, &env->active_fpu.fp_status))
target-mips/op_helper.c:FOP_COND_D(ueq, float64_unordered_quiet(fdt1, fdt0, &env->active_fpu.fp_status)  || float64_eq_quiet(fdt0, fdt1, &env->active_fpu.fp_status))
target-mips/op_helper.c:FOP_COND_D(olt, float64_lt_quiet(fdt0, fdt1, &env->active_fpu.fp_status))
target-mips/op_helper.c:FOP_COND_D(ult, float64_unordered_quiet(fdt1, fdt0, &env->active_fpu.fp_status)  || float64_lt_quiet(fdt0, fdt1, &env->active_fpu.fp_status))
target-mips/op_helper.c:FOP_COND_D(ole, float64_le_quiet(fdt0, fdt1, &env->active_fpu.fp_status))
target-mips/op_helper.c:FOP_COND_D(ule, float64_unordered_quiet(fdt1, fdt0, &env->active_fpu.fp_status)  || float64_le_quiet(fdt0, fdt1, &env->active_fpu.fp_status))
target-mips/op_helper.c:FOP_COND_D(sf,  (float64_unordered(fdt1, fdt0, &env->active_fpu.fp_status), 0))
target-mips/op_helper.c:FOP_COND_D(ngle,float64_unordered(fdt1, fdt0, &env->active_fpu.fp_status))
target-mips/op_helper.c:FOP_COND_D(seq, float64_eq(fdt0, fdt1, &env->active_fpu.fp_status))
target-mips/op_helper.c:FOP_COND_D(ngl, float64_unordered(fdt1, fdt0, &env->active_fpu.fp_status)  || float64_eq(fdt0, fdt1, &env->active_fpu.fp_status))
target-mips/op_helper.c:FOP_COND_D(lt,  float64_lt(fdt0, fdt1, &env->active_fpu.fp_status))
target-mips/op_helper.c:FOP_COND_D(nge, float64_unordered(fdt1, fdt0, &env->active_fpu.fp_status)  || float64_lt(fdt0, fdt1, &env->active_fpu.fp_status))
target-mips/op_helper.c:FOP_COND_D(le,  float64_le(fdt0, fdt1, &env->active_fpu.fp_status))
target-mips/op_helper.c:FOP_COND_D(ngt, float64_unordered(fdt1, fdt0, &env->active_fpu.fp_status)  || float64_le(fdt0, fdt1, &env->active_fpu.fp_status))
target-mips/op_helper.c:    set_float_exception_flags(0, &env->active_fpu.fp_status);  \
target-mips/op_helper.c:        SET_FP_COND(cc, env->active_fpu);                      \
target-mips/op_helper.c:        CLEAR_FP_COND(cc, env->active_fpu);                    \
target-mips/op_helper.c:    set_float_exception_flags(0, &env->active_fpu.fp_status);  \
target-mips/op_helper.c:        SET_FP_COND(cc, env->active_fpu);                      \
target-mips/op_helper.c:        CLEAR_FP_COND(cc, env->active_fpu);                    \
target-mips/op_helper.c:FOP_COND_S(f,   (float32_unordered_quiet(fst1, fst0, &env->active_fpu.fp_status), 0))
target-mips/op_helper.c:FOP_COND_S(un,  float32_unordered_quiet(fst1, fst0, &env->active_fpu.fp_status))
target-mips/op_helper.c:FOP_COND_S(eq,  float32_eq_quiet(fst0, fst1, &env->active_fpu.fp_status))
target-mips/op_helper.c:FOP_COND_S(ueq, float32_unordered_quiet(fst1, fst0, &env->active_fpu.fp_status)  || float32_eq_quiet(fst0, fst1, &env->active_fpu.fp_status))
target-mips/op_helper.c:FOP_COND_S(olt, float32_lt_quiet(fst0, fst1, &env->active_fpu.fp_status))
target-mips/op_helper.c:FOP_COND_S(ult, float32_unordered_quiet(fst1, fst0, &env->active_fpu.fp_status)  || float32_lt_quiet(fst0, fst1, &env->active_fpu.fp_status))
target-mips/op_helper.c:FOP_COND_S(ole, float32_le_quiet(fst0, fst1, &env->active_fpu.fp_status))
target-mips/op_helper.c:FOP_COND_S(ule, float32_unordered_quiet(fst1, fst0, &env->active_fpu.fp_status)  || float32_le_quiet(fst0, fst1, &env->active_fpu.fp_status))
target-mips/op_helper.c:FOP_COND_S(sf,  (float32_unordered(fst1, fst0, &env->active_fpu.fp_status), 0))
target-mips/op_helper.c:FOP_COND_S(ngle,float32_unordered(fst1, fst0, &env->active_fpu.fp_status))
target-mips/op_helper.c:FOP_COND_S(seq, float32_eq(fst0, fst1, &env->active_fpu.fp_status))
target-mips/op_helper.c:FOP_COND_S(ngl, float32_unordered(fst1, fst0, &env->active_fpu.fp_status)  || float32_eq(fst0, fst1, &env->active_fpu.fp_status))
target-mips/op_helper.c:FOP_COND_S(lt,  float32_lt(fst0, fst1, &env->active_fpu.fp_status))
target-mips/op_helper.c:FOP_COND_S(nge, float32_unordered(fst1, fst0, &env->active_fpu.fp_status)  || float32_lt(fst0, fst1, &env->active_fpu.fp_status))
target-mips/op_helper.c:FOP_COND_S(le,  float32_le(fst0, fst1, &env->active_fpu.fp_status))
target-mips/op_helper.c:FOP_COND_S(ngt, float32_unordered(fst1, fst0, &env->active_fpu.fp_status)  || float32_le(fst0, fst1, &env->active_fpu.fp_status))
target-mips/op_helper.c:    set_float_exception_flags(0, &env->active_fpu.fp_status);   \
target-mips/op_helper.c:        SET_FP_COND(cc, env->active_fpu);                       \
target-mips/op_helper.c:        CLEAR_FP_COND(cc, env->active_fpu);                     \
target-mips/op_helper.c:        SET_FP_COND(cc + 1, env->active_fpu);                   \
target-mips/op_helper.c:        CLEAR_FP_COND(cc + 1, env->active_fpu);                 \
target-mips/op_helper.c:        SET_FP_COND(cc, env->active_fpu);                       \
target-mips/op_helper.c:        CLEAR_FP_COND(cc, env->active_fpu);                     \
target-mips/op_helper.c:        SET_FP_COND(cc + 1, env->active_fpu);                   \
target-mips/op_helper.c:        CLEAR_FP_COND(cc + 1, env->active_fpu);                 \
target-mips/op_helper.c:FOP_COND_PS(f,   (float32_unordered_quiet(fst1, fst0, &env->active_fpu.fp_status), 0),
target-mips/op_helper.c:                 (float32_unordered_quiet(fsth1, fsth0, &env->active_fpu.fp_status), 0))
target-mips/op_helper.c:FOP_COND_PS(un,  float32_unordered_quiet(fst1, fst0, &env->active_fpu.fp_status),
target-mips/op_helper.c:                 float32_unordered_quiet(fsth1, fsth0, &env->active_fpu.fp_status))
target-mips/op_helper.c:FOP_COND_PS(eq,  float32_eq_quiet(fst0, fst1, &env->active_fpu.fp_status),
target-mips/op_helper.c:                 float32_eq_quiet(fsth0, fsth1, &env->active_fpu.fp_status))
target-mips/op_helper.c:FOP_COND_PS(ueq, float32_unordered_quiet(fst1, fst0, &env->active_fpu.fp_status)    || float32_eq_quiet(fst0, fst1, &env->active_fpu.fp_status),
target-mips/op_helper.c:                 float32_unordered_quiet(fsth1, fsth0, &env->active_fpu.fp_status)  || float32_eq_quiet(fsth0, fsth1, &env->active_fpu.fp_status))
target-mips/op_helper.c:FOP_COND_PS(olt, float32_lt_quiet(fst0, fst1, &env->active_fpu.fp_status),
target-mips/op_helper.c:                 float32_lt_quiet(fsth0, fsth1, &env->active_fpu.fp_status))
target-mips/op_helper.c:FOP_COND_PS(ult, float32_unordered_quiet(fst1, fst0, &env->active_fpu.fp_status)    || float32_lt_quiet(fst0, fst1, &env->active_fpu.fp_status),
target-mips/op_helper.c:                 float32_unordered_quiet(fsth1, fsth0, &env->active_fpu.fp_status)  || float32_lt_quiet(fsth0, fsth1, &env->active_fpu.fp_status))
target-mips/op_helper.c:FOP_COND_PS(ole, float32_le_quiet(fst0, fst1, &env->active_fpu.fp_status),
target-mips/op_helper.c:                 float32_le_quiet(fsth0, fsth1, &env->active_fpu.fp_status))
target-mips/op_helper.c:FOP_COND_PS(ule, float32_unordered_quiet(fst1, fst0, &env->active_fpu.fp_status)    || float32_le_quiet(fst0, fst1, &env->active_fpu.fp_status),
target-mips/op_helper.c:                 float32_unordered_quiet(fsth1, fsth0, &env->active_fpu.fp_status)  || float32_le_quiet(fsth0, fsth1, &env->active_fpu.fp_status))
target-mips/op_helper.c:FOP_COND_PS(sf,  (float32_unordered(fst1, fst0, &env->active_fpu.fp_status), 0),
target-mips/op_helper.c:                 (float32_unordered(fsth1, fsth0, &env->active_fpu.fp_status), 0))
target-mips/op_helper.c:FOP_COND_PS(ngle,float32_unordered(fst1, fst0, &env->active_fpu.fp_status),
target-mips/op_helper.c:                 float32_unordered(fsth1, fsth0, &env->active_fpu.fp_status))
target-mips/op_helper.c:FOP_COND_PS(seq, float32_eq(fst0, fst1, &env->active_fpu.fp_status),
target-mips/op_helper.c:                 float32_eq(fsth0, fsth1, &env->active_fpu.fp_status))
target-mips/op_helper.c:FOP_COND_PS(ngl, float32_unordered(fst1, fst0, &env->active_fpu.fp_status)    || float32_eq(fst0, fst1, &env->active_fpu.fp_status),
target-mips/op_helper.c:                 float32_unordered(fsth1, fsth0, &env->active_fpu.fp_status)  || float32_eq(fsth0, fsth1, &env->active_fpu.fp_status))
target-mips/op_helper.c:FOP_COND_PS(lt,  float32_lt(fst0, fst1, &env->active_fpu.fp_status),
target-mips/op_helper.c:                 float32_lt(fsth0, fsth1, &env->active_fpu.fp_status))
target-mips/op_helper.c:FOP_COND_PS(nge, float32_unordered(fst1, fst0, &env->active_fpu.fp_status)    || float32_lt(fst0, fst1, &env->active_fpu.fp_status),
target-mips/op_helper.c:                 float32_unordered(fsth1, fsth0, &env->active_fpu.fp_status)  || float32_lt(fsth0, fsth1, &env->active_fpu.fp_status))
target-mips/op_helper.c:FOP_COND_PS(le,  float32_le(fst0, fst1, &env->active_fpu.fp_status),
target-mips/op_helper.c:                 float32_le(fsth0, fsth1, &env->active_fpu.fp_status))
target-mips/op_helper.c:FOP_COND_PS(ngt, float32_unordered(fst1, fst0, &env->active_fpu.fp_status)    || float32_le(fst0, fst1, &env->active_fpu.fp_status),
target-mips/op_helper.c:                 float32_unordered(fsth1, fsth0, &env->active_fpu.fp_status)  || float32_le(fsth0, fsth1, &env->active_fpu.fp_status))
target-mips/translate_init.c:    env->tlb->nb_tlb = 1;
target-mips/translate_init.c:    env->tlb->map_address = &no_mmu_map_address;
target-mips/translate_init.c:    env->tlb->nb_tlb = 1;
target-mips/translate_init.c:    env->tlb->map_address = &fixed_mmu_map_address;
target-mips/translate_init.c:    env->tlb->nb_tlb = 1 + ((def->CP0_Config1 >> CP0C1_MMU) & 63);
target-mips/translate_init.c:    env->tlb->map_address = &r4k_map_address;
target-mips/translate_init.c:    env->tlb->helper_tlbwi = r4k_helper_tlbwi;
target-mips/translate_init.c:    env->tlb->helper_tlbwr = r4k_helper_tlbwr;
target-mips/translate_init.c:    env->tlb->helper_tlbp = r4k_helper_tlbp;
target-mips/translate_init.c:    env->tlb->helper_tlbr = r4k_helper_tlbr;
target-mips/translate_init.c:    env->tlb = g_malloc0(sizeof(CPUMIPSTLBContext));
target-mips/translate_init.c:        env->fpus[i].fcr0 = def->CP1_fcr0;
target-mips/translate_init.c:    memcpy(&env->active_fpu, &env->fpus[0], sizeof(env->active_fpu));
target-mips/translate_init.c:    env->mvp = g_malloc0(sizeof(CPUMIPSMVPContext));
target-mips/translate_init.c:    env->mvp->CP0_MVPConf0 = (1 << CP0MVPC0_M) | (1 << CP0MVPC0_TLBS) |
target-mips/translate_init.c:    env->mvp->CP0_MVPConf0 |= (env->tlb->nb_tlb << CP0MVPC0_PTLBE);
target-mips/translate_init.c:    env->mvp->CP0_MVPConf1 = (1 << CP0MVPC1_CIM) | (1 << CP0MVPC1_CIF) |
target-mips/cpu.h:    return env->hflags & MIPS_HFLAG_KSU;
target-mips/cpu.h:        env->active_tc.gpr[29] = newsp;
target-mips/cpu.h:    env->active_tc.gpr[7] = 0;
target-mips/cpu.h:    env->active_tc.gpr[2] = 0;
target-mips/cpu.h:    if (!(env->CP0_Status & (1 << CP0St_IE)) ||
target-mips/cpu.h:        (env->CP0_Status & (1 << CP0St_EXL)) ||
target-mips/cpu.h:        (env->CP0_Status & (1 << CP0St_ERL)) ||
target-mips/cpu.h:        (env->active_tc.CP0_TCStatus & (1 << CP0TCSt_IXMT)) ||
target-mips/cpu.h:        (env->hflags & MIPS_HFLAG_DM)) {
target-mips/cpu.h:    pending = env->CP0_Cause & CP0Ca_IP_mask;
target-mips/cpu.h:    status = env->CP0_Status & CP0Ca_IP_mask;
target-mips/cpu.h:    if (env->CP0_Config3 & (1 << CP0C3_VEIC)) {
target-mips/cpu.h:    *pc = env->active_tc.PC;
target-mips/cpu.h:    *flags = env->hflags & (MIPS_HFLAG_TMASK | MIPS_HFLAG_BMASK);
target-mips/cpu.h:    env->tls_value = newtls;
target-mips/cpu.h:    if (!(env->mvp->CP0_MVPControl & (1 << CP0MVPCo_EVP))) {
target-mips/cpu.h:    if (!(env->CP0_VPEConf0 & (1 << CP0VPEC0_VPA))) {
target-mips/cpu.h:    if (!(env->active_tc.CP0_TCStatus & (1 << CP0TCSt_A))) {
target-mips/cpu.h:    if (env->active_tc.CP0_TCHalt & 1) {
target-mips/cpu.h:    if ((env->interrupt_request & CPU_INTERRUPT_HARD) &&
target-mips/cpu.h:    if (env->CP0_Config3 & (1 << CP0C3_MT)) {
target-mips/cpu.h:        if (env->interrupt_request & CPU_INTERRUPT_WAKE) {
target-mips/cpu.h:    env->active_tc.PC = tb->pc;
target-mips/cpu.h:    env->hflags &= ~MIPS_HFLAG_BMASK;
target-mips/cpu.h:    env->hflags |= tb->flags & MIPS_HFLAG_BMASK;
target-mips/helper.c:        if (!(env->CP0_Status & (1 << CP0St_ERL)))
target-mips/helper.c:    uint8_t ASID = env->CP0_EntryHi & 0xFF;
target-mips/helper.c:    for (i = 0; i < env->tlb->tlb_in_use; i++) {
target-mips/helper.c:        r4k_tlb_t *tlb = &env->tlb->mmu.r4k.tlb[i];
target-mips/helper.c:        tag &= env->SEGMask;
target-mips/helper.c:    int user_mode = (env->hflags & MIPS_HFLAG_MODE) == MIPS_HFLAG_UM;
target-mips/helper.c:    int supervisor_mode = (env->hflags & MIPS_HFLAG_MODE) == MIPS_HFLAG_SM;
target-mips/helper.c:    int UX = (env->CP0_Status & (1 << CP0St_UX)) != 0;
target-mips/helper.c:    int SX = (env->CP0_Status & (1 << CP0St_SX)) != 0;
target-mips/helper.c:    int KX = (env->CP0_Status & (1 << CP0St_KX)) != 0;
target-mips/helper.c:    qemu_log("user mode %d h %08x\n", user_mode, env->hflags);
target-mips/helper.c:        if (env->CP0_Status & (1 << CP0St_ERL)) {
target-mips/helper.c:            ret = env->tlb->map_address(env, physical, prot, address, rw, access_type);
target-mips/helper.c:        if (UX && address <= (0x3FFFFFFFFFFFFFFFULL & env->SEGMask)) {
target-mips/helper.c:            ret = env->tlb->map_address(env, physical, prot, address, rw, access_type);
target-mips/helper.c:            SX && address <= (0x7FFFFFFFFFFFFFFFULL & env->SEGMask)) {
target-mips/helper.c:            ret = env->tlb->map_address(env, physical, prot, address, rw, access_type);
target-mips/helper.c:            (address & 0x07FFFFFFFFFFFFFFULL) <= env->PAMask) {
target-mips/helper.c:            *physical = address & env->PAMask;
target-mips/helper.c:            address <= (0xFFFFFFFF7FFFFFFFULL & env->SEGMask)) {
target-mips/helper.c:            ret = env->tlb->map_address(env, physical, prot, address, rw, access_type);
target-mips/helper.c:            ret = env->tlb->map_address(env, physical, prot, address, rw, access_type);
target-mips/helper.c:            ret = env->tlb->map_address(env, physical, prot, address, rw, access_type);
target-mips/helper.c:    env->CP0_BadVAddr = address;
target-mips/helper.c:    env->CP0_Context = (env->CP0_Context & ~0x007fffff) |
target-mips/helper.c:    env->CP0_EntryHi =
target-mips/helper.c:        (env->CP0_EntryHi & 0xFF) | (address & (TARGET_PAGE_MASK << 1));
target-mips/helper.c:    env->CP0_EntryHi &= env->SEGMask;
target-mips/helper.c:    env->CP0_XContext = (env->CP0_XContext & ((~0ULL) << (env->SEGBITS - 7))) |
target-mips/helper.c:                        ((address & 0xC00000000000ULL) >> (55 - env->SEGBITS)) |
target-mips/helper.c:                        ((address & ((1ULL << env->SEGBITS) - 1) & 0xFFFFFFFFFFFFE000ULL) >> 9);
target-mips/helper.c:    env->exception_index = exception;
target-mips/helper.c:    env->error_code = error_code;
target-mips/helper.c:              __func__, env->active_tc.PC, address, rw, mmu_idx);
target-mips/helper.c:    isa_mode = !!(env->hflags & MIPS_HFLAG_M16);
target-mips/helper.c:    bad_pc = env->active_tc.PC | isa_mode;
target-mips/helper.c:    if (env->hflags & MIPS_HFLAG_BMASK) {
target-mips/helper.c:        bad_pc -= (env->hflags & MIPS_HFLAG_B16 ? 2 : 4);
target-mips/helper.c:    env->hflags &= ~(MIPS_HFLAG_M16);
target-mips/helper.c:    if (env->insn_flags & ASE_MICROMIPS) {
target-mips/helper.c:        env->hflags |= (!!(env->CP0_Config3
target-mips/helper.c:    if (qemu_log_enabled() && env->exception_index != EXCP_EXT_INTERRUPT) {
target-mips/helper.c:        if (env->exception_index < 0 || env->exception_index > EXCP_LAST)
target-mips/helper.c:            name = excp_names[env->exception_index];
target-mips/helper.c:                 __func__, env->active_tc.PC, env->CP0_EPC, name);
target-mips/helper.c:    if (env->exception_index == EXCP_EXT_INTERRUPT &&
target-mips/helper.c:        (env->hflags & MIPS_HFLAG_DM))
target-mips/helper.c:        env->exception_index = EXCP_DINT;
target-mips/helper.c:    switch (env->exception_index) {
target-mips/helper.c:        env->CP0_Debug |= 1 << CP0DB_DSS;
target-mips/helper.c:        env->CP0_DEPC = env->active_tc.PC | !!(env->hflags & MIPS_HFLAG_M16);
target-mips/helper.c:        env->CP0_Debug |= 1 << CP0DB_DINT;
target-mips/helper.c:        env->CP0_Debug |= 1 << CP0DB_DIB;
target-mips/helper.c:        env->CP0_Debug |= 1 << CP0DB_DBp;
target-mips/helper.c:        env->CP0_Debug |= 1 << CP0DB_DDBS;
target-mips/helper.c:        env->CP0_Debug |= 1 << CP0DB_DDBL;
target-mips/helper.c:        env->CP0_DEPC = exception_resume_pc(env);
target-mips/helper.c:        env->hflags &= ~MIPS_HFLAG_BMASK;
target-mips/helper.c:        env->hflags |= MIPS_HFLAG_DM | MIPS_HFLAG_64 | MIPS_HFLAG_CP0;
target-mips/helper.c:        env->hflags &= ~(MIPS_HFLAG_KSU);
target-mips/helper.c:        if (!(env->CP0_Status & (1 << CP0St_EXL)))
target-mips/helper.c:            env->CP0_Cause &= ~(1 << CP0Ca_BD);
target-mips/helper.c:        env->active_tc.PC = (int32_t)0xBFC00480;
target-mips/helper.c:        env->CP0_Status |= (1 << CP0St_SR);
target-mips/helper.c:        memset(env->CP0_WatchLo, 0, sizeof(*env->CP0_WatchLo));
target-mips/helper.c:        env->CP0_Status |= (1 << CP0St_NMI);
target-mips/helper.c:        env->CP0_ErrorEPC = exception_resume_pc(env);
target-mips/helper.c:        env->hflags &= ~MIPS_HFLAG_BMASK;
target-mips/helper.c:        env->CP0_Status |= (1 << CP0St_ERL) | (1 << CP0St_BEV);
target-mips/helper.c:        env->hflags |= MIPS_HFLAG_64 | MIPS_HFLAG_CP0;
target-mips/helper.c:        env->hflags &= ~(MIPS_HFLAG_KSU);
target-mips/helper.c:        if (!(env->CP0_Status & (1 << CP0St_EXL)))
target-mips/helper.c:            env->CP0_Cause &= ~(1 << CP0Ca_BD);
target-mips/helper.c:        env->active_tc.PC = (int32_t)0xBFC00000;
target-mips/helper.c:        if (env->CP0_Cause & (1 << CP0Ca_IV))
target-mips/helper.c:        if (env->CP0_Config3 & ((1 << CP0C3_VInt) | (1 << CP0C3_VEIC))) {
target-mips/helper.c:            unsigned int pending = (env->CP0_Cause & CP0Ca_IP_mask) >> 8;
target-mips/helper.c:            pending &= env->CP0_Status >> 8;
target-mips/helper.c:            spacing = (env->CP0_IntCtl >> CP0IntCtl_VS) & ((1 << 6) - 1);
target-mips/helper.c:            if (env->CP0_Config3 & (1 << CP0C3_VInt)) {
target-mips/helper.c:        if (env->error_code == 1 && !(env->CP0_Status & (1 << CP0St_EXL))) {
target-mips/helper.c:            int R = env->CP0_BadVAddr >> 62;
target-mips/helper.c:            int UX = (env->CP0_Status & (1 << CP0St_UX)) != 0;
target-mips/helper.c:            int SX = (env->CP0_Status & (1 << CP0St_SX)) != 0;
target-mips/helper.c:            int KX = (env->CP0_Status & (1 << CP0St_KX)) != 0;
target-mips/helper.c:                (!(env->insn_flags & (INSN_LOONGSON2E | INSN_LOONGSON2F))))
target-mips/helper.c:        if (env->error_code == 1 && !(env->CP0_Status & (1 << CP0St_EXL))) {
target-mips/helper.c:            int R = env->CP0_BadVAddr >> 62;
target-mips/helper.c:            int UX = (env->CP0_Status & (1 << CP0St_UX)) != 0;
target-mips/helper.c:            int SX = (env->CP0_Status & (1 << CP0St_SX)) != 0;
target-mips/helper.c:            int KX = (env->CP0_Status & (1 << CP0St_KX)) != 0;
target-mips/helper.c:                (!(env->insn_flags & (INSN_LOONGSON2E | INSN_LOONGSON2F))))
target-mips/helper.c:        env->CP0_Cause = (env->CP0_Cause & ~(0x3 << CP0Ca_CE)) |
target-mips/helper.c:                         (env->error_code << CP0Ca_CE);
target-mips/helper.c:        if (env->CP0_Status & (1 << CP0St_BEV)) {
target-mips/helper.c:        if (!(env->CP0_Status & (1 << CP0St_EXL))) {
target-mips/helper.c:            env->CP0_EPC = exception_resume_pc(env);
target-mips/helper.c:            if (env->hflags & MIPS_HFLAG_BMASK) {
target-mips/helper.c:                env->CP0_Cause |= (1 << CP0Ca_BD);
target-mips/helper.c:                env->CP0_Cause &= ~(1 << CP0Ca_BD);
target-mips/helper.c:            env->CP0_Status |= (1 << CP0St_EXL);
target-mips/helper.c:            env->hflags |= MIPS_HFLAG_64 | MIPS_HFLAG_CP0;
target-mips/helper.c:            env->hflags &= ~(MIPS_HFLAG_KSU);
target-mips/helper.c:        env->hflags &= ~MIPS_HFLAG_BMASK;
target-mips/helper.c:        if (env->CP0_Status & (1 << CP0St_BEV)) {
target-mips/helper.c:            env->active_tc.PC = (int32_t)0xBFC00200;
target-mips/helper.c:            env->active_tc.PC = (int32_t)(env->CP0_EBase & ~0x3ff);
target-mips/helper.c:        env->active_tc.PC += offset;
target-mips/helper.c:        env->CP0_Cause = (env->CP0_Cause & ~(0x1f << CP0Ca_EC)) | (cause << CP0Ca_EC);
target-mips/helper.c:        qemu_log("Invalid MIPS exception %d. Exiting\n", env->exception_index);
target-mips/helper.c:        printf("Invalid MIPS exception %d. Exiting\n", env->exception_index);
target-mips/helper.c:    if (qemu_log_enabled() && env->exception_index != EXCP_EXT_INTERRUPT) {
target-mips/helper.c:                __func__, env->active_tc.PC, env->CP0_EPC, cause,
target-mips/helper.c:                env->CP0_Status, env->CP0_Cause, env->CP0_BadVAddr,
target-mips/helper.c:                env->CP0_DEPC);
target-mips/helper.c:    env->exception_index = EXCP_NONE;
target-mips/helper.c:    uint8_t ASID = env->CP0_EntryHi & 0xFF;
target-mips/helper.c:    tlb = &env->tlb->mmu.r4k.tlb[idx];
target-mips/helper.c:    if (use_extra && env->tlb->tlb_in_use < MIPS_TLB_MAX) {
target-mips/helper.c:        env->tlb->mmu.r4k.tlb[env->tlb->tlb_in_use] = *tlb;
target-mips/helper.c:        env->tlb->tlb_in_use++;
target-mips/helper.c:        if (addr >= (0xFFFFFFFF80000000ULL & env->SEGMask)) {
target-mips/helper.c:        if (addr >= (0xFFFFFFFF80000000ULL & env->SEGMask)) {
target-mips/machine.c:    save_tc(f, &env->active_tc);
target-mips/machine.c:    save_fpu(f, &env->active_fpu);
target-mips/machine.c:    qemu_put_sbe32s(f, &env->mvp->CP0_MVPControl);
target-mips/machine.c:    qemu_put_sbe32s(f, &env->mvp->CP0_MVPConf0);
target-mips/machine.c:    qemu_put_sbe32s(f, &env->mvp->CP0_MVPConf1);
target-mips/machine.c:    qemu_put_be32s(f, &env->tlb->nb_tlb);
target-mips/machine.c:    qemu_put_be32s(f, &env->tlb->tlb_in_use);
target-mips/machine.c:        uint16_t flags = ((env->tlb->mmu.r4k.tlb[i].G << 10) |
target-mips/machine.c:                          (env->tlb->mmu.r4k.tlb[i].C0 << 7) |
target-mips/machine.c:                          (env->tlb->mmu.r4k.tlb[i].C1 << 4) |
target-mips/machine.c:                          (env->tlb->mmu.r4k.tlb[i].V0 << 3) |
target-mips/machine.c:                          (env->tlb->mmu.r4k.tlb[i].V1 << 2) |
target-mips/machine.c:                          (env->tlb->mmu.r4k.tlb[i].D0 << 1) |
target-mips/machine.c:                          (env->tlb->mmu.r4k.tlb[i].D1 << 0));
target-mips/machine.c:        qemu_put_betls(f, &env->tlb->mmu.r4k.tlb[i].VPN);
target-mips/machine.c:        qemu_put_be32s(f, &env->tlb->mmu.r4k.tlb[i].PageMask);
target-mips/machine.c:        asid = env->tlb->mmu.r4k.tlb[i].ASID;
target-mips/machine.c:        qemu_put_betls(f, &env->tlb->mmu.r4k.tlb[i].PFN[0]);
target-mips/machine.c:        qemu_put_betls(f, &env->tlb->mmu.r4k.tlb[i].PFN[1]);
target-mips/machine.c:    qemu_put_be32s(f, &env->current_tc);
target-mips/machine.c:    qemu_put_be32s(f, &env->current_fpu);
target-mips/machine.c:    qemu_put_sbe32s(f, &env->error_code);
target-mips/machine.c:    qemu_put_be32s(f, &env->hflags);
target-mips/machine.c:    qemu_put_betls(f, &env->btarget);
target-mips/machine.c:    i = env->bcond;
target-mips/machine.c:    qemu_put_sbe32s(f, &env->CP0_Index);
target-mips/machine.c:    qemu_put_sbe32s(f, &env->CP0_Random);
target-mips/machine.c:    qemu_put_sbe32s(f, &env->CP0_VPEControl);
target-mips/machine.c:    qemu_put_sbe32s(f, &env->CP0_VPEConf0);
target-mips/machine.c:    qemu_put_sbe32s(f, &env->CP0_VPEConf1);
target-mips/machine.c:    qemu_put_betls(f, &env->CP0_YQMask);
target-mips/machine.c:    qemu_put_betls(f, &env->CP0_VPESchedule);
target-mips/machine.c:    qemu_put_betls(f, &env->CP0_VPEScheFBack);
target-mips/machine.c:    qemu_put_sbe32s(f, &env->CP0_VPEOpt);
target-mips/machine.c:    qemu_put_betls(f, &env->CP0_EntryLo0);
target-mips/machine.c:    qemu_put_betls(f, &env->CP0_EntryLo1);
target-mips/machine.c:    qemu_put_betls(f, &env->CP0_Context);
target-mips/machine.c:    qemu_put_sbe32s(f, &env->CP0_PageMask);
target-mips/machine.c:    qemu_put_sbe32s(f, &env->CP0_PageGrain);
target-mips/machine.c:    qemu_put_sbe32s(f, &env->CP0_Wired);
target-mips/machine.c:    qemu_put_sbe32s(f, &env->CP0_SRSConf0);
target-mips/machine.c:    qemu_put_sbe32s(f, &env->CP0_SRSConf1);
target-mips/machine.c:    qemu_put_sbe32s(f, &env->CP0_SRSConf2);
target-mips/machine.c:    qemu_put_sbe32s(f, &env->CP0_SRSConf3);
target-mips/machine.c:    qemu_put_sbe32s(f, &env->CP0_SRSConf4);
target-mips/machine.c:    qemu_put_sbe32s(f, &env->CP0_HWREna);
target-mips/machine.c:    qemu_put_betls(f, &env->CP0_BadVAddr);
target-mips/machine.c:    qemu_put_sbe32s(f, &env->CP0_Count);
target-mips/machine.c:    qemu_put_betls(f, &env->CP0_EntryHi);
target-mips/machine.c:    qemu_put_sbe32s(f, &env->CP0_Compare);
target-mips/machine.c:    qemu_put_sbe32s(f, &env->CP0_Status);
target-mips/machine.c:    qemu_put_sbe32s(f, &env->CP0_IntCtl);
target-mips/machine.c:    qemu_put_sbe32s(f, &env->CP0_SRSCtl);
target-mips/machine.c:    qemu_put_sbe32s(f, &env->CP0_SRSMap);
target-mips/machine.c:    qemu_put_sbe32s(f, &env->CP0_Cause);
target-mips/machine.c:    qemu_put_betls(f, &env->CP0_EPC);
target-mips/machine.c:    qemu_put_sbe32s(f, &env->CP0_PRid);
target-mips/machine.c:    qemu_put_sbe32s(f, &env->CP0_EBase);
target-mips/machine.c:    qemu_put_sbe32s(f, &env->CP0_Config0);
target-mips/machine.c:    qemu_put_sbe32s(f, &env->CP0_Config1);
target-mips/machine.c:    qemu_put_sbe32s(f, &env->CP0_Config2);
target-mips/machine.c:    qemu_put_sbe32s(f, &env->CP0_Config3);
target-mips/machine.c:    qemu_put_sbe32s(f, &env->CP0_Config6);
target-mips/machine.c:    qemu_put_sbe32s(f, &env->CP0_Config7);
target-mips/machine.c:    qemu_put_betls(f, &env->lladdr);
target-mips/machine.c:        qemu_put_betls(f, &env->CP0_WatchLo[i]);
target-mips/machine.c:        qemu_put_sbe32s(f, &env->CP0_WatchHi[i]);
target-mips/machine.c:    qemu_put_betls(f, &env->CP0_XContext);
target-mips/machine.c:    qemu_put_sbe32s(f, &env->CP0_Framemask);
target-mips/machine.c:    qemu_put_sbe32s(f, &env->CP0_Debug);
target-mips/machine.c:    qemu_put_betls(f, &env->CP0_DEPC);
target-mips/machine.c:    qemu_put_sbe32s(f, &env->CP0_Performance0);
target-mips/machine.c:    qemu_put_sbe32s(f, &env->CP0_TagLo);
target-mips/machine.c:    qemu_put_sbe32s(f, &env->CP0_DataLo);
target-mips/machine.c:    qemu_put_sbe32s(f, &env->CP0_TagHi);
target-mips/machine.c:    qemu_put_sbe32s(f, &env->CP0_DataHi);
target-mips/machine.c:    qemu_put_betls(f, &env->CP0_ErrorEPC);
target-mips/machine.c:    qemu_put_sbe32s(f, &env->CP0_DESAVE);
target-mips/machine.c:        save_tc(f, &env->tcs[i]);
target-mips/machine.c:        save_fpu(f, &env->fpus[i]);
target-mips/machine.c:    load_tc(f, &env->active_tc);
target-mips/machine.c:    load_fpu(f, &env->active_fpu);
target-mips/machine.c:    qemu_get_sbe32s(f, &env->mvp->CP0_MVPControl);
target-mips/machine.c:    qemu_get_sbe32s(f, &env->mvp->CP0_MVPConf0);
target-mips/machine.c:    qemu_get_sbe32s(f, &env->mvp->CP0_MVPConf1);
target-mips/machine.c:    qemu_get_be32s(f, &env->tlb->nb_tlb);
target-mips/machine.c:    qemu_get_be32s(f, &env->tlb->tlb_in_use);
target-mips/machine.c:        qemu_get_betls(f, &env->tlb->mmu.r4k.tlb[i].VPN);
target-mips/machine.c:        qemu_get_be32s(f, &env->tlb->mmu.r4k.tlb[i].PageMask);
target-mips/machine.c:        env->tlb->mmu.r4k.tlb[i].ASID = asid;
target-mips/machine.c:        env->tlb->mmu.r4k.tlb[i].G = (flags >> 10) & 1;
target-mips/machine.c:        env->tlb->mmu.r4k.tlb[i].C0 = (flags >> 7) & 3;
target-mips/machine.c:        env->tlb->mmu.r4k.tlb[i].C1 = (flags >> 4) & 3;
target-mips/machine.c:        env->tlb->mmu.r4k.tlb[i].V0 = (flags >> 3) & 1;
target-mips/machine.c:        env->tlb->mmu.r4k.tlb[i].V1 = (flags >> 2) & 1;
target-mips/machine.c:        env->tlb->mmu.r4k.tlb[i].D0 = (flags >> 1) & 1;
target-mips/machine.c:        env->tlb->mmu.r4k.tlb[i].D1 = (flags >> 0) & 1;
target-mips/machine.c:        qemu_get_betls(f, &env->tlb->mmu.r4k.tlb[i].PFN[0]);
target-mips/machine.c:        qemu_get_betls(f, &env->tlb->mmu.r4k.tlb[i].PFN[1]);
target-mips/machine.c:    qemu_get_be32s(f, &env->current_tc);
target-mips/machine.c:    qemu_get_be32s(f, &env->current_fpu);
target-mips/machine.c:    qemu_get_sbe32s(f, &env->error_code);
target-mips/machine.c:    qemu_get_be32s(f, &env->hflags);
target-mips/machine.c:    qemu_get_betls(f, &env->btarget);
target-mips/machine.c:    env->bcond = i;
target-mips/machine.c:    qemu_get_sbe32s(f, &env->CP0_Index);
target-mips/machine.c:    qemu_get_sbe32s(f, &env->CP0_Random);
target-mips/machine.c:    qemu_get_sbe32s(f, &env->CP0_VPEControl);
target-mips/machine.c:    qemu_get_sbe32s(f, &env->CP0_VPEConf0);
target-mips/machine.c:    qemu_get_sbe32s(f, &env->CP0_VPEConf1);
target-mips/machine.c:    qemu_get_betls(f, &env->CP0_YQMask);
target-mips/machine.c:    qemu_get_betls(f, &env->CP0_VPESchedule);
target-mips/machine.c:    qemu_get_betls(f, &env->CP0_VPEScheFBack);
target-mips/machine.c:    qemu_get_sbe32s(f, &env->CP0_VPEOpt);
target-mips/machine.c:    qemu_get_betls(f, &env->CP0_EntryLo0);
target-mips/machine.c:    qemu_get_betls(f, &env->CP0_EntryLo1);
target-mips/machine.c:    qemu_get_betls(f, &env->CP0_Context);
target-mips/machine.c:    qemu_get_sbe32s(f, &env->CP0_PageMask);
target-mips/machine.c:    qemu_get_sbe32s(f, &env->CP0_PageGrain);
target-mips/machine.c:    qemu_get_sbe32s(f, &env->CP0_Wired);
target-mips/machine.c:    qemu_get_sbe32s(f, &env->CP0_SRSConf0);
target-mips/machine.c:    qemu_get_sbe32s(f, &env->CP0_SRSConf1);
target-mips/machine.c:    qemu_get_sbe32s(f, &env->CP0_SRSConf2);
target-mips/machine.c:    qemu_get_sbe32s(f, &env->CP0_SRSConf3);
target-mips/machine.c:    qemu_get_sbe32s(f, &env->CP0_SRSConf4);
target-mips/machine.c:    qemu_get_sbe32s(f, &env->CP0_HWREna);
target-mips/machine.c:    qemu_get_betls(f, &env->CP0_BadVAddr);
target-mips/machine.c:    qemu_get_sbe32s(f, &env->CP0_Count);
target-mips/machine.c:    qemu_get_betls(f, &env->CP0_EntryHi);
target-mips/machine.c:    qemu_get_sbe32s(f, &env->CP0_Compare);
target-mips/machine.c:    qemu_get_sbe32s(f, &env->CP0_Status);
target-mips/machine.c:    qemu_get_sbe32s(f, &env->CP0_IntCtl);
target-mips/machine.c:    qemu_get_sbe32s(f, &env->CP0_SRSCtl);
target-mips/machine.c:    qemu_get_sbe32s(f, &env->CP0_SRSMap);
target-mips/machine.c:    qemu_get_sbe32s(f, &env->CP0_Cause);
target-mips/machine.c:    qemu_get_betls(f, &env->CP0_EPC);
target-mips/machine.c:    qemu_get_sbe32s(f, &env->CP0_PRid);
target-mips/machine.c:    qemu_get_sbe32s(f, &env->CP0_EBase);
target-mips/machine.c:    qemu_get_sbe32s(f, &env->CP0_Config0);
target-mips/machine.c:    qemu_get_sbe32s(f, &env->CP0_Config1);
target-mips/machine.c:    qemu_get_sbe32s(f, &env->CP0_Config2);
target-mips/machine.c:    qemu_get_sbe32s(f, &env->CP0_Config3);
target-mips/machine.c:    qemu_get_sbe32s(f, &env->CP0_Config6);
target-mips/machine.c:    qemu_get_sbe32s(f, &env->CP0_Config7);
target-mips/machine.c:    qemu_get_betls(f, &env->lladdr);
target-mips/machine.c:        qemu_get_betls(f, &env->CP0_WatchLo[i]);
target-mips/machine.c:        qemu_get_sbe32s(f, &env->CP0_WatchHi[i]);
target-mips/machine.c:    qemu_get_betls(f, &env->CP0_XContext);
target-mips/machine.c:    qemu_get_sbe32s(f, &env->CP0_Framemask);
target-mips/machine.c:    qemu_get_sbe32s(f, &env->CP0_Debug);
target-mips/machine.c:    qemu_get_betls(f, &env->CP0_DEPC);
target-mips/machine.c:    qemu_get_sbe32s(f, &env->CP0_Performance0);
target-mips/machine.c:    qemu_get_sbe32s(f, &env->CP0_TagLo);
target-mips/machine.c:    qemu_get_sbe32s(f, &env->CP0_DataLo);
target-mips/machine.c:    qemu_get_sbe32s(f, &env->CP0_TagHi);
target-mips/machine.c:    qemu_get_sbe32s(f, &env->CP0_DataHi);
target-mips/machine.c:    qemu_get_betls(f, &env->CP0_ErrorEPC);
target-mips/machine.c:    qemu_get_sbe32s(f, &env->CP0_DESAVE);
target-mips/machine.c:        load_tc(f, &env->tcs[i]);
target-mips/machine.c:        load_fpu(f, &env->fpus[i]);
target-mips/translate.c:        ctx->btarget = env->btarget;
target-mips/translate.c:    if (unlikely(!(env->insn_flags & flags)))
target-mips/translate.c:    if (rt == 0 && env->insn_flags & (INSN_LOONGSON2E | INSN_LOONGSON2F)) {
target-mips/translate.c:    if (env->CP0_Config1 & (1 << CP0C1_FP)) {
target-mips/translate.c:    int other_tc = env->CP0_VPEControl & (0xff << CP0VPECo_TargTC);
target-mips/translate.c:    if ((env->CP0_VPEConf0 & (1 << CP0VPEC0_MVP)) == 0 &&
target-mips/translate.c:        ((env->tcs[other_tc].CP0_TCBind & (0xf << CP0TCBd_CurVPE)) !=
target-mips/translate.c:         (env->active_tc.CP0_TCBind & (0xf << CP0TCBd_CurVPE))))
target-mips/translate.c:    else if ((env->CP0_VPEControl & (0xff << CP0VPECo_TargTC)) >
target-mips/translate.c:             (env->mvp->CP0_MVPConf0 & (0xff << CP0MVPC0_PTC)))
target-mips/translate.c:    int other_tc = env->CP0_VPEControl & (0xff << CP0VPECo_TargTC);
target-mips/translate.c:    if ((env->CP0_VPEConf0 & (1 << CP0VPEC0_MVP)) == 0 &&
target-mips/translate.c:        ((env->tcs[other_tc].CP0_TCBind & (0xf << CP0TCBd_CurVPE)) !=
target-mips/translate.c:         (env->active_tc.CP0_TCBind & (0xf << CP0TCBd_CurVPE))))
target-mips/translate.c:    else if ((env->CP0_VPEControl & (0xff << CP0VPECo_TargTC)) >
target-mips/translate.c:             (env->mvp->CP0_MVPConf0 & (0xff << CP0MVPC0_PTC)))
target-mips/translate.c:        if (!env->tlb->helper_tlbwi)
target-mips/translate.c:        if (!env->tlb->helper_tlbwr)
target-mips/translate.c:        if (!env->tlb->helper_tlbp)
target-mips/translate.c:        if (!env->tlb->helper_tlbr)
target-mips/translate.c:            if (env->insn_flags & (ASE_MIPS16 | ASE_MICROMIPS)) {
target-mips/translate.c:        if (env->CP0_Config1 & (1 << CP0C1_FP)) {
target-mips/translate.c:        env->CP0_BadVAddr = ctx->pc;
target-mips/translate.c:        env->CP0_BadVAddr = ctx->pc;
target-mips/translate.c:                if (env->insn_flags & ISA_MIPS32R2) {
target-mips/translate.c:                if (env->insn_flags & ISA_MIPS32R2) {
target-mips/translate.c:            if (env->CP0_Config1 & (1 << CP0C1_FP)) {
target-mips/translate.c:                if (env->insn_flags & ISA_MIPS32R2) {
target-mips/translate.c:                if (env->insn_flags & ISA_MIPS32R2) {
target-mips/translate.c:                if (env->insn_flags & ISA_MIPS32R2) {
target-mips/translate.c:        if (env->CP0_Config1 & (1 << CP0C1_FP)) {
target-mips/translate.c:        if (env->CP0_Config1 & (1 << CP0C1_FP)) {
target-mips/translate.c:    ctx.singlestep_enabled = env->singlestep_enabled;
target-mips/translate.c:        if (unlikely(!QTAILQ_EMPTY(&env->breakpoints))) {
target-mips/translate.c:            QTAILQ_FOREACH(bp, &env->breakpoints, entry) {
target-mips/translate.c:        } else if (env->insn_flags & ASE_MICROMIPS) {
target-mips/translate.c:        } else if (env->insn_flags & ASE_MIPS16) {
target-mips/translate.c:        if (env->singlestep_enabled && (ctx.hflags & MIPS_HFLAG_BMASK) == 0)
target-mips/translate.c:    if (env->singlestep_enabled && ctx.bstate != BS_BRANCH) {
target-mips/translate.c:    int is_fpu64 = !!(env->hflags & MIPS_HFLAG_F64);
target-mips/translate.c:                env->active_fpu.fcr0, env->active_fpu.fcr31, is_fpu64,
target-mips/translate.c:                get_float_exception_flags(&env->active_fpu.fp_status));
target-mips/translate.c:        printfpr(&env->active_fpu.fpr[i]);
target-mips/translate.c:    if (!SIGN_EXT_P(env->active_tc.PC))
target-mips/translate.c:        cpu_fprintf(f, "BROKEN: pc=0x" TARGET_FMT_lx "\n", env->active_tc.PC);
target-mips/translate.c:    if (!SIGN_EXT_P(env->active_tc.HI[0]))
target-mips/translate.c:        cpu_fprintf(f, "BROKEN: HI=0x" TARGET_FMT_lx "\n", env->active_tc.HI[0]);
target-mips/translate.c:    if (!SIGN_EXT_P(env->active_tc.LO[0]))
target-mips/translate.c:        cpu_fprintf(f, "BROKEN: LO=0x" TARGET_FMT_lx "\n", env->active_tc.LO[0]);
target-mips/translate.c:    if (!SIGN_EXT_P(env->btarget))
target-mips/translate.c:        cpu_fprintf(f, "BROKEN: btarget=0x" TARGET_FMT_lx "\n", env->btarget);
target-mips/translate.c:        if (!SIGN_EXT_P(env->active_tc.gpr[i]))
target-mips/translate.c:            cpu_fprintf(f, "BROKEN: %s=0x" TARGET_FMT_lx "\n", regnames[i], env->active_tc.gpr[i]);
target-mips/translate.c:    if (!SIGN_EXT_P(env->CP0_EPC))
target-mips/translate.c:        cpu_fprintf(f, "BROKEN: EPC=0x" TARGET_FMT_lx "\n", env->CP0_EPC);
target-mips/translate.c:    if (!SIGN_EXT_P(env->lladdr))
target-mips/translate.c:        cpu_fprintf(f, "BROKEN: LLAddr=0x" TARGET_FMT_lx "\n", env->lladdr);
target-mips/translate.c:                env->active_tc.PC, env->active_tc.HI[0], env->active_tc.LO[0],
target-mips/translate.c:                env->hflags, env->btarget, env->bcond);
target-mips/translate.c:        cpu_fprintf(f, " %s " TARGET_FMT_lx, regnames[i], env->active_tc.gpr[i]);
target-mips/translate.c:                env->CP0_Status, env->CP0_Cause, env->CP0_EPC);
target-mips/translate.c:                env->CP0_Config0, env->CP0_Config1, env->lladdr);
target-mips/translate.c:    if (env->hflags & MIPS_HFLAG_FPU)
target-mips/translate.c:    env->cpu_model = def;
target-mips/translate.c:    env->cpu_model_str = cpu_model;
target-mips/translate.c:        qemu_log("CPU Reset (CPU %d)\n", env->cpu_index);
target-mips/translate.c:    env->CP0_PRid = env->cpu_model->CP0_PRid;
target-mips/translate.c:    env->CP0_Config0 = env->cpu_model->CP0_Config0;
target-mips/translate.c:    env->CP0_Config0 |= (1 << CP0C0_BE);
target-mips/translate.c:    env->CP0_Config1 = env->cpu_model->CP0_Config1;
target-mips/translate.c:    env->CP0_Config2 = env->cpu_model->CP0_Config2;
target-mips/translate.c:    env->CP0_Config3 = env->cpu_model->CP0_Config3;
target-mips/translate.c:    env->CP0_Config6 = env->cpu_model->CP0_Config6;
target-mips/translate.c:    env->CP0_Config7 = env->cpu_model->CP0_Config7;
target-mips/translate.c:    env->CP0_LLAddr_rw_bitmask = env->cpu_model->CP0_LLAddr_rw_bitmask
target-mips/translate.c:                                 << env->cpu_model->CP0_LLAddr_shift;
target-mips/translate.c:    env->CP0_LLAddr_shift = env->cpu_model->CP0_LLAddr_shift;
target-mips/translate.c:    env->SYNCI_Step = env->cpu_model->SYNCI_Step;
target-mips/translate.c:    env->CCRes = env->cpu_model->CCRes;
target-mips/translate.c:    env->CP0_Status_rw_bitmask = env->cpu_model->CP0_Status_rw_bitmask;
target-mips/translate.c:    env->CP0_TCStatus_rw_bitmask = env->cpu_model->CP0_TCStatus_rw_bitmask;
target-mips/translate.c:    env->CP0_SRSCtl = env->cpu_model->CP0_SRSCtl;
target-mips/translate.c:    env->current_tc = 0;
target-mips/translate.c:    env->SEGBITS = env->cpu_model->SEGBITS;
target-mips/translate.c:    env->SEGMask = (target_ulong)((1ULL << env->cpu_model->SEGBITS) - 1);
target-mips/translate.c:    if (env->cpu_model->insn_flags & ISA_MIPS3) {
target-mips/translate.c:        env->SEGMask |= 3ULL << 62;
target-mips/translate.c:    env->PABITS = env->cpu_model->PABITS;
target-mips/translate.c:    env->PAMask = (target_ulong)((1ULL << env->cpu_model->PABITS) - 1);
target-mips/translate.c:    env->CP0_SRSConf0_rw_bitmask = env->cpu_model->CP0_SRSConf0_rw_bitmask;
target-mips/translate.c:    env->CP0_SRSConf0 = env->cpu_model->CP0_SRSConf0;
target-mips/translate.c:    env->CP0_SRSConf1_rw_bitmask = env->cpu_model->CP0_SRSConf1_rw_bitmask;
target-mips/translate.c:    env->CP0_SRSConf1 = env->cpu_model->CP0_SRSConf1;
target-mips/translate.c:    env->CP0_SRSConf2_rw_bitmask = env->cpu_model->CP0_SRSConf2_rw_bitmask;
target-mips/translate.c:    env->CP0_SRSConf2 = env->cpu_model->CP0_SRSConf2;
target-mips/translate.c:    env->CP0_SRSConf3_rw_bitmask = env->cpu_model->CP0_SRSConf3_rw_bitmask;
target-mips/translate.c:    env->CP0_SRSConf3 = env->cpu_model->CP0_SRSConf3;
target-mips/translate.c:    env->CP0_SRSConf4_rw_bitmask = env->cpu_model->CP0_SRSConf4_rw_bitmask;
target-mips/translate.c:    env->CP0_SRSConf4 = env->cpu_model->CP0_SRSConf4;
target-mips/translate.c:    env->insn_flags = env->cpu_model->insn_flags;
target-mips/translate.c:    env->hflags = MIPS_HFLAG_UM;
target-mips/translate.c:    env->CP0_HWREna |= (1 << 1);
target-mips/translate.c:    if (env->CP0_Config1 & (1 << CP0C1_FP)) {
target-mips/translate.c:        env->hflags |= MIPS_HFLAG_FPU;
target-mips/translate.c:    if (env->active_fpu.fcr0 & (1 << FCR0_F64)) {
target-mips/translate.c:        env->hflags |= MIPS_HFLAG_F64;
target-mips/translate.c:    if (env->hflags & MIPS_HFLAG_BMASK) {
target-mips/translate.c:        env->CP0_ErrorEPC = env->active_tc.PC - 4;
target-mips/translate.c:        env->CP0_ErrorEPC = env->active_tc.PC;
target-mips/translate.c:    env->active_tc.PC = (int32_t)0xBFC00000;
target-mips/translate.c:    env->CP0_Random = env->tlb->nb_tlb - 1;
target-mips/translate.c:    env->tlb->tlb_in_use = env->tlb->nb_tlb;
target-mips/translate.c:    env->CP0_Wired = 0;
target-mips/translate.c:    env->CP0_EBase = 0x80000000 | (env->cpu_index & 0x3FF);
target-mips/translate.c:    env->CP0_Status = (1 << CP0St_BEV) | (1 << CP0St_ERL);
target-mips/translate.c:    env->CP0_IntCtl = 0xe0000000;
target-mips/translate.c:            env->CP0_WatchLo[i] = 0;
target-mips/translate.c:            env->CP0_WatchHi[i] = 0x80000000;
target-mips/translate.c:        env->CP0_WatchLo[7] = 0;
target-mips/translate.c:        env->CP0_WatchHi[7] = 0;
target-mips/translate.c:    env->CP0_Debug = (1 << CP0DB_CNT) | (0x1 << CP0DB_VER);
target-mips/translate.c:    env->hflags = MIPS_HFLAG_CP0;
target-mips/translate.c:    if (env->CP0_Config3 & (1 << CP0C3_MT)) {
target-mips/translate.c:        for (i = 0; i < ARRAY_SIZE(env->tcs); i++) {
target-mips/translate.c:            env->tcs[i].CP0_TCBind = env->cpu_index << CP0TCBd_CurVPE;
target-mips/translate.c:            env->tcs[i].CP0_TCHalt = 1;
target-mips/translate.c:        env->active_tc.CP0_TCHalt = 1;
target-mips/translate.c:        env->halted = 1;
target-mips/translate.c:        if (!env->cpu_index) {
target-mips/translate.c:            env->mvp->CP0_MVPControl |= (1 << CP0MVPCo_EVP);
target-mips/translate.c:            env->CP0_VPEConf0 |= (1 << CP0VPEC0_MVP) | (1 << CP0VPEC0_VPA);
target-mips/translate.c:            env->halted = 0;
target-mips/translate.c:            env->active_tc.CP0_TCHalt = 0;
target-mips/translate.c:            env->tcs[0].CP0_TCHalt = 0;
target-mips/translate.c:            env->active_tc.CP0_TCStatus = (1 << CP0TCSt_A);
target-mips/translate.c:            env->tcs[0].CP0_TCStatus = (1 << CP0TCSt_A);
target-mips/translate.c:    if (env->cpu_model->insn_flags & ISA_MIPS3) {
target-mips/translate.c:        env->hflags |= MIPS_HFLAG_64;
target-mips/translate.c:    env->exception_index = EXCP_NONE;
target-mips/translate.c:    env->active_tc.PC = gen_opc_pc[pc_pos];
target-mips/translate.c:    env->hflags &= ~MIPS_HFLAG_BMASK;
target-mips/translate.c:    env->hflags |= gen_opc_hflags[pc_pos];
target-ppc/op_helper.c:    env->exception_index = exception;
target-ppc/op_helper.c:    env->error_code = error_code;
target-ppc/op_helper.c:             env->spr[sprn]);
target-ppc/op_helper.c:             env->spr[sprn]);
target-ppc/op_helper.c:    hid0 = env->spr[SPR_HID0];
target-ppc/op_helper.c:        env->hflags &= ~(1 << MSR_LE);
target-ppc/op_helper.c:        env->hflags_nmsr &= ~(1 << MSR_LE);
target-ppc/op_helper.c:        env->hflags_nmsr |= (1 << MSR_LE) & (((val >> 3) & 1) << MSR_LE);
target-ppc/op_helper.c:        env->hflags |= env->hflags_nmsr;
target-ppc/op_helper.c:                 val & 0x8 ? 'l' : 'b', env->hflags);
target-ppc/op_helper.c:    env->spr[SPR_HID0] = (uint32_t)val;
target-ppc/op_helper.c:    if (likely(env->pb[num] != value)) {
target-ppc/op_helper.c:        env->pb[num] = value;
target-ppc/op_helper.c:            env->gpr[reg] = bswap32(ldl(addr));
target-ppc/op_helper.c:            env->gpr[reg] = ldl(addr);
target-ppc/op_helper.c:            stl(addr, bswap32((uint32_t)env->gpr[reg]));
target-ppc/op_helper.c:            stl(addr, (uint32_t)env->gpr[reg]);
target-ppc/op_helper.c:        env->gpr[reg] = ldl(addr);
target-ppc/op_helper.c:        env->gpr[reg] = 0;
target-ppc/op_helper.c:            env->gpr[reg] |= ldub(addr) << sh;
target-ppc/op_helper.c:        stl(addr, env->gpr[reg]);
target-ppc/op_helper.c:            stb(addr, (env->gpr[reg] >> sh) & 0xFF);
target-ppc/op_helper.c:    if (env->reserve_addr == addr)
target-ppc/op_helper.c:        env->reserve_addr = (target_ulong)-1ULL;
target-ppc/op_helper.c:    do_dcbz(addr, env->dcache_line_size);
target-ppc/op_helper.c:    if (((env->spr[SPR_970_HID5] >> 7) & 0x3) == 1)
target-ppc/op_helper.c:        do_dcbz(addr, env->dcache_line_size);
target-ppc/op_helper.c:    addr &= ~(env->dcache_line_size - 1);
target-ppc/op_helper.c:            env->gpr[reg] = (env->gpr[reg] & ~(0xFF << d)) | (c << d);
target-ppc/op_helper.c:        env->xer &= ~(1 << XER_OV);
target-ppc/op_helper.c:        env->xer |= (1 << XER_OV) | (1 << XER_SO);
target-ppc/op_helper.c:                env->xer &= ~(1 << XER_CA);
target-ppc/op_helper.c:                env->xer |= (1 << XER_CA);
target-ppc/op_helper.c:            env->xer &= ~(1 << XER_CA);
target-ppc/op_helper.c:            env->xer |= (1 << XER_CA);
target-ppc/op_helper.c:            env->xer &= ~(1 << XER_CA);
target-ppc/op_helper.c:                env->xer &= ~(1 << XER_CA);
target-ppc/op_helper.c:                env->xer |= (1 << XER_CA);
target-ppc/op_helper.c:            env->xer &= ~(1 << XER_CA);
target-ppc/op_helper.c:            env->xer |= (1 << XER_CA);
target-ppc/op_helper.c:            env->xer &= ~(1 << XER_CA);
target-ppc/op_helper.c:    d.d = float32_to_float64(f.f, &env->fp_status);
target-ppc/op_helper.c:    f.f = float64_to_float32(d.d, &env->fp_status);
target-ppc/op_helper.c:        env->fpscr &= ~(0x1F << FPSCR_FPRF);
target-ppc/op_helper.c:        env->fpscr |= ret << FPSCR_FPRF;
target-ppc/op_helper.c:        env->fpscr |= 1 << FPSCR_VXSNAN;
target-ppc/op_helper.c:        env->fpscr |= 1 << FPSCR_VXSOFT;
target-ppc/op_helper.c:        env->fpscr |= 1 << FPSCR_VXISI;
target-ppc/op_helper.c:        env->fpscr |= 1 << FPSCR_VXIDI;
target-ppc/op_helper.c:        env->fpscr |= 1 << FPSCR_VXZDZ;
target-ppc/op_helper.c:        env->fpscr |= 1 << FPSCR_VXIMZ;
target-ppc/op_helper.c:        env->fpscr |= 1 << FPSCR_VXVC;
target-ppc/op_helper.c:        env->fpscr &= ~(0xF << FPSCR_FPCC);
target-ppc/op_helper.c:        env->fpscr |= 0x11 << FPSCR_FPCC;
target-ppc/op_helper.c:            env->exception_index = POWERPC_EXCP_PROGRAM;
target-ppc/op_helper.c:            env->error_code = POWERPC_EXCP_FP | POWERPC_EXCP_FP_VXVC;
target-ppc/op_helper.c:            env->fpscr |= 1 << FPSCR_FEX;
target-ppc/op_helper.c:        env->fpscr |= 1 << FPSCR_VXSQRT;
target-ppc/op_helper.c:        env->fpscr &= ~((1 << FPSCR_FR) | (1 << FPSCR_FI));
target-ppc/op_helper.c:            env->fpscr &= ~(0xF << FPSCR_FPCC);
target-ppc/op_helper.c:            env->fpscr |= 0x11 << FPSCR_FPCC;
target-ppc/op_helper.c:        env->fpscr |= 1 << FPSCR_VXCVI;
target-ppc/op_helper.c:        env->fpscr &= ~((1 << FPSCR_FR) | (1 << FPSCR_FI));
target-ppc/op_helper.c:            env->fpscr &= ~(0xF << FPSCR_FPCC);
target-ppc/op_helper.c:            env->fpscr |= 0x11 << FPSCR_FPCC;
target-ppc/op_helper.c:    env->fpscr |= 1 << FPSCR_VX;
target-ppc/op_helper.c:    env->fpscr |= 1 << FPSCR_FX;
target-ppc/op_helper.c:        env->fpscr |= 1 << FPSCR_FEX;
target-ppc/op_helper.c:    env->fpscr |= 1 << FPSCR_ZX;
target-ppc/op_helper.c:    env->fpscr &= ~((1 << FPSCR_FR) | (1 << FPSCR_FI));
target-ppc/op_helper.c:    env->fpscr |= 1 << FPSCR_FX;
target-ppc/op_helper.c:        env->fpscr |= 1 << FPSCR_FEX;
target-ppc/op_helper.c:    env->fpscr |= 1 << FPSCR_OX;
target-ppc/op_helper.c:    env->fpscr |= 1 << FPSCR_FX;
target-ppc/op_helper.c:        env->fpscr |= 1 << FPSCR_FEX;
target-ppc/op_helper.c:        env->exception_index = POWERPC_EXCP_PROGRAM;
target-ppc/op_helper.c:        env->error_code = POWERPC_EXCP_FP | POWERPC_EXCP_FP_OX;
target-ppc/op_helper.c:        env->fpscr |= 1 << FPSCR_XX;
target-ppc/op_helper.c:        env->fpscr |= 1 << FPSCR_FI;
target-ppc/op_helper.c:    env->fpscr |= 1 << FPSCR_UX;
target-ppc/op_helper.c:    env->fpscr |= 1 << FPSCR_FX;
target-ppc/op_helper.c:        env->fpscr |= 1 << FPSCR_FEX;
target-ppc/op_helper.c:        env->exception_index = POWERPC_EXCP_PROGRAM;
target-ppc/op_helper.c:        env->error_code = POWERPC_EXCP_FP | POWERPC_EXCP_FP_UX;
target-ppc/op_helper.c:    env->fpscr |= 1 << FPSCR_XX;
target-ppc/op_helper.c:    env->fpscr |= 1 << FPSCR_FX;
target-ppc/op_helper.c:        env->fpscr |= 1 << FPSCR_FEX;
target-ppc/op_helper.c:        env->exception_index = POWERPC_EXCP_PROGRAM;
target-ppc/op_helper.c:        env->error_code = POWERPC_EXCP_FP | POWERPC_EXCP_FP_XX;
target-ppc/op_helper.c:    set_float_rounding_mode(rnd_type, &env->fp_status);
target-ppc/op_helper.c:    prev = (env->fpscr >> bit) & 1;
target-ppc/op_helper.c:    env->fpscr &= ~(1 << bit);
target-ppc/op_helper.c:    prev = (env->fpscr >> bit) & 1;
target-ppc/op_helper.c:    env->fpscr |= 1 << bit;
target-ppc/op_helper.c:            env->fpscr |= 1 << FPSCR_FX;
target-ppc/op_helper.c:            env->fpscr |= 1 << FPSCR_FX;
target-ppc/op_helper.c:            env->fpscr |= 1 << FPSCR_FX;
target-ppc/op_helper.c:            env->fpscr |= 1 << FPSCR_FX;
target-ppc/op_helper.c:            env->fpscr |= 1 << FPSCR_FX;
target-ppc/op_helper.c:            env->fpscr |= 1 << FPSCR_VX;
target-ppc/op_helper.c:            env->fpscr |= 1 << FPSCR_FX;
target-ppc/op_helper.c:                env->error_code = POWERPC_EXCP_FP;
target-ppc/op_helper.c:                    env->error_code |= POWERPC_EXCP_FP_VXSNAN;
target-ppc/op_helper.c:                    env->error_code |= POWERPC_EXCP_FP_VXISI;
target-ppc/op_helper.c:                    env->error_code |= POWERPC_EXCP_FP_VXIDI;
target-ppc/op_helper.c:                    env->error_code |= POWERPC_EXCP_FP_VXZDZ;
target-ppc/op_helper.c:                    env->error_code |= POWERPC_EXCP_FP_VXIMZ;
target-ppc/op_helper.c:                    env->error_code |= POWERPC_EXCP_FP_VXVC;
target-ppc/op_helper.c:                    env->error_code |= POWERPC_EXCP_FP_VXSOFT;
target-ppc/op_helper.c:                    env->error_code |= POWERPC_EXCP_FP_VXSQRT;
target-ppc/op_helper.c:                    env->error_code |= POWERPC_EXCP_FP_VXCVI;
target-ppc/op_helper.c:                env->error_code = POWERPC_EXCP_FP | POWERPC_EXCP_FP_OX;
target-ppc/op_helper.c:                env->error_code = POWERPC_EXCP_FP | POWERPC_EXCP_FP_UX;
target-ppc/op_helper.c:                env->error_code = POWERPC_EXCP_FP | POWERPC_EXCP_FP_ZX;
target-ppc/op_helper.c:                env->error_code = POWERPC_EXCP_FP | POWERPC_EXCP_FP_XX;
target-ppc/op_helper.c:            env->fpscr |= 1 << FPSCR_FEX;
target-ppc/op_helper.c:            env->exception_index = POWERPC_EXCP_PROGRAM;
target-ppc/op_helper.c:    prev = env->fpscr;
target-ppc/op_helper.c:            env->fpscr &= ~(0xF << (4 * i));
target-ppc/op_helper.c:            env->fpscr |= new & (0xF << (4 * i));
target-ppc/op_helper.c:        env->fpscr |= 1 << FPSCR_VX;
target-ppc/op_helper.c:        env->fpscr &= ~(1 << FPSCR_VX);
target-ppc/op_helper.c:        env->fpscr |= 1 << FPSCR_FEX;
target-ppc/op_helper.c:        env->exception_index = POWERPC_EXCP_PROGRAM;
target-ppc/op_helper.c:        env->error_code = POWERPC_EXCP_FP;
target-ppc/op_helper.c:        env->fpscr &= ~(1 << FPSCR_FEX);
target-ppc/op_helper.c:    if (env->exception_index == POWERPC_EXCP_PROGRAM &&
target-ppc/op_helper.c:        (env->error_code & POWERPC_EXCP_FP)) {
target-ppc/op_helper.c:            helper_raise_exception_err(env->exception_index, env->error_code);
target-ppc/op_helper.c:        int status = get_float_exception_flags(&env->fp_status);
target-ppc/op_helper.c:    set_float_exception_flags(0, &env->fp_status);
target-ppc/op_helper.c:        farg1.d = float64_add(farg1.d, farg2.d, &env->fp_status);
target-ppc/op_helper.c:        farg1.d = float64_sub(farg1.d, farg2.d, &env->fp_status);
target-ppc/op_helper.c:        farg1.d = float64_mul(farg1.d, farg2.d, &env->fp_status);
target-ppc/op_helper.c:        farg1.d = float64_div(farg1.d, farg2.d, &env->fp_status);
target-ppc/op_helper.c:        farg.ll = float64_to_int32(farg.d, &env->fp_status);
target-ppc/op_helper.c:        farg.ll = float64_to_int32_round_to_zero(farg.d, &env->fp_status);
target-ppc/op_helper.c:    farg.d = int64_to_float64(arg, &env->fp_status);
target-ppc/op_helper.c:        farg.ll = float64_to_int64(farg.d, &env->fp_status);
target-ppc/op_helper.c:        farg.ll = float64_to_int64_round_to_zero(farg.d, &env->fp_status);
target-ppc/op_helper.c:        set_float_rounding_mode(rounding_mode, &env->fp_status);
target-ppc/op_helper.c:        farg.ll = float64_round_to_int(farg.d, &env->fp_status);
target-ppc/op_helper.c:        ft0_128 = float64_to_float128(farg1.d, &env->fp_status);
target-ppc/op_helper.c:        ft1_128 = float64_to_float128(farg2.d, &env->fp_status);
target-ppc/op_helper.c:        ft0_128 = float128_mul(ft0_128, ft1_128, &env->fp_status);
target-ppc/op_helper.c:            ft1_128 = float64_to_float128(farg3.d, &env->fp_status);
target-ppc/op_helper.c:            ft0_128 = float128_add(ft0_128, ft1_128, &env->fp_status);
target-ppc/op_helper.c:            farg1.d = float128_to_float64(ft0_128, &env->fp_status);
target-ppc/op_helper.c:        ft0_128 = float64_to_float128(farg1.d, &env->fp_status);
target-ppc/op_helper.c:        ft1_128 = float64_to_float128(farg2.d, &env->fp_status);
target-ppc/op_helper.c:        ft0_128 = float128_mul(ft0_128, ft1_128, &env->fp_status);
target-ppc/op_helper.c:            ft1_128 = float64_to_float128(farg3.d, &env->fp_status);
target-ppc/op_helper.c:            ft0_128 = float128_sub(ft0_128, ft1_128, &env->fp_status);
target-ppc/op_helper.c:            farg1.d = float128_to_float64(ft0_128, &env->fp_status);
target-ppc/op_helper.c:        ft0_128 = float64_to_float128(farg1.d, &env->fp_status);
target-ppc/op_helper.c:        ft1_128 = float64_to_float128(farg2.d, &env->fp_status);
target-ppc/op_helper.c:        ft0_128 = float128_mul(ft0_128, ft1_128, &env->fp_status);
target-ppc/op_helper.c:            ft1_128 = float64_to_float128(farg3.d, &env->fp_status);
target-ppc/op_helper.c:            ft0_128 = float128_add(ft0_128, ft1_128, &env->fp_status);
target-ppc/op_helper.c:            farg1.d = float128_to_float64(ft0_128, &env->fp_status);
target-ppc/op_helper.c:        ft0_128 = float64_to_float128(farg1.d, &env->fp_status);
target-ppc/op_helper.c:        ft1_128 = float64_to_float128(farg2.d, &env->fp_status);
target-ppc/op_helper.c:        ft0_128 = float128_mul(ft0_128, ft1_128, &env->fp_status);
target-ppc/op_helper.c:            ft1_128 = float64_to_float128(farg3.d, &env->fp_status);
target-ppc/op_helper.c:            ft0_128 = float128_sub(ft0_128, ft1_128, &env->fp_status);
target-ppc/op_helper.c:            farg1.d = float128_to_float64(ft0_128, &env->fp_status);
target-ppc/op_helper.c:    f32 = float64_to_float32(farg.d, &env->fp_status);
target-ppc/op_helper.c:    farg.d = float32_to_float64(f32, &env->fp_status);
target-ppc/op_helper.c:        farg.d = float64_sqrt(farg.d, &env->fp_status);
target-ppc/op_helper.c:    farg.d = float64_div(float64_one, farg.d, &env->fp_status);
target-ppc/op_helper.c:    farg.d = float64_div(float64_one, farg.d, &env->fp_status);
target-ppc/op_helper.c:    f32 = float64_to_float32(farg.d, &env->fp_status);
target-ppc/op_helper.c:    farg.d = float32_to_float64(f32, &env->fp_status);
target-ppc/op_helper.c:        farg.d = float64_sqrt(farg.d, &env->fp_status);
target-ppc/op_helper.c:        farg.d = float64_div(float64_one, farg.d, &env->fp_status);
target-ppc/op_helper.c:        f32 = float64_to_float32(farg.d, &env->fp_status);
target-ppc/op_helper.c:        farg.d = float32_to_float64(f32, &env->fp_status);
target-ppc/op_helper.c:    } else if (float64_lt(farg1.d, farg2.d, &env->fp_status)) {
target-ppc/op_helper.c:    } else if (!float64_le(farg1.d, farg2.d, &env->fp_status)) {
target-ppc/op_helper.c:    env->fpscr &= ~(0x0F << FPSCR_FPRF);
target-ppc/op_helper.c:    env->fpscr |= ret << FPSCR_FPRF;
target-ppc/op_helper.c:    env->crf[crfD] = ret;
target-ppc/op_helper.c:    } else if (float64_lt(farg1.d, farg2.d, &env->fp_status)) {
target-ppc/op_helper.c:    } else if (!float64_le(farg1.d, farg2.d, &env->fp_status)) {
target-ppc/op_helper.c:    env->fpscr &= ~(0x0F << FPSCR_FPRF);
target-ppc/op_helper.c:    env->fpscr |= ret << FPSCR_FPRF;
target-ppc/op_helper.c:    env->crf[crfD] = ret;
target-ppc/op_helper.c:        env->interrupt_request |= CPU_INTERRUPT_EXITTB;
target-ppc/op_helper.c:            msr |= env->msr & ~((uint64_t)0xFFFFFFFF);
target-ppc/op_helper.c:    env->nip = nip & ~((target_ulong)0x00000003);
target-ppc/op_helper.c:    cpu_dump_rfi(env->nip, env->msr);
target-ppc/op_helper.c:    env->interrupt_request |= CPU_INTERRUPT_EXITTB;
target-ppc/op_helper.c:    do_rfi(env->spr[SPR_SRR0], env->spr[SPR_SRR1],
target-ppc/op_helper.c:    do_rfi(env->spr[SPR_SRR0], env->spr[SPR_SRR1],
target-ppc/op_helper.c:    do_rfi(env->spr[SPR_HSRR0], env->spr[SPR_HSRR1],
target-ppc/op_helper.c:        return env->icache_line_size;
target-ppc/op_helper.c:        return env->dcache_line_size;
target-ppc/op_helper.c:        return (env->icache_line_size < env->dcache_line_size) ?
target-ppc/op_helper.c:                env->icache_line_size : env->dcache_line_size;
target-ppc/op_helper.c:        return (env->icache_line_size > env->dcache_line_size) ?
target-ppc/op_helper.c:                env->icache_line_size : env->dcache_line_size;
target-ppc/op_helper.c:    uint64_t tmp = (uint64_t)arg1 << 32 | env->spr[SPR_MQ];
target-ppc/op_helper.c:        env->spr[SPR_MQ] = 0;
target-ppc/op_helper.c:        env->spr[SPR_MQ] = tmp % arg2;
target-ppc/op_helper.c:    uint64_t tmp = (uint64_t)arg1 << 32 | env->spr[SPR_MQ];
target-ppc/op_helper.c:        env->xer |= (1 << XER_OV) | (1 << XER_SO);
target-ppc/op_helper.c:        env->spr[SPR_MQ] = 0;
target-ppc/op_helper.c:        env->spr[SPR_MQ] = tmp % arg2;
target-ppc/op_helper.c:            env->xer |= (1 << XER_OV) | (1 << XER_SO);
target-ppc/op_helper.c:            env->xer &= ~(1 << XER_OV);
target-ppc/op_helper.c:        env->spr[SPR_MQ] = 0;
target-ppc/op_helper.c:        env->spr[SPR_MQ] = (int32_t)arg1 % (int32_t)arg2;
target-ppc/op_helper.c:        env->xer |= (1 << XER_OV) | (1 << XER_SO);
target-ppc/op_helper.c:        env->spr[SPR_MQ] = 0;
target-ppc/op_helper.c:        env->xer &= ~(1 << XER_OV);
target-ppc/op_helper.c:        env->spr[SPR_MQ] = (int32_t)arg1 % (int32_t)arg2;
target-ppc/op_helper.c:    nb_BATs = env->nb_BATs;
target-ppc/op_helper.c:    env->nb_BATs = 0;
target-ppc/op_helper.c:    env->nb_BATs = nb_BATs;
target-ppc/op_helper.c:    do_rfi(env->lr, env->ctr, 0x0000FFFF, 0);
target-ppc/op_helper.c:    if (unlikely(env->dcr_env == NULL)) {
target-ppc/op_helper.c:    } else if (unlikely(ppc_dcr_read(env->dcr_env, (uint32_t)dcrn, &val) != 0)) {
target-ppc/op_helper.c:    if (unlikely(env->dcr_env == NULL)) {
target-ppc/op_helper.c:    } else if (unlikely(ppc_dcr_write(env->dcr_env, (uint32_t)dcrn, (uint32_t)val) != 0)) {
target-ppc/op_helper.c:    do_rfi(env->spr[SPR_40x_SRR2], env->spr[SPR_40x_SRR3],
target-ppc/op_helper.c:    do_rfi(env->spr[SPR_BOOKE_CSRR0], SPR_BOOKE_CSRR1,
target-ppc/op_helper.c:    do_rfi(env->spr[SPR_BOOKE_DSRR0], SPR_BOOKE_DSRR1,
target-ppc/op_helper.c:    do_rfi(env->spr[SPR_BOOKE_MCSRR0], SPR_BOOKE_MCSRR1,
target-ppc/op_helper.c:                env->crf[0] = 0x4;
target-ppc/op_helper.c:                env->crf[0] = 0x8;
target-ppc/op_helper.c:        env->crf[0] = 0x2;
target-ppc/op_helper.c:    env->xer = (env->xer & ~0x7F) | i;
target-ppc/op_helper.c:        env->crf[0] |= xer_so;
target-ppc/op_helper.c:    env->vscr = r->u32[3];
target-ppc/op_helper.c:    env->vscr = r->u32[0];
target-ppc/op_helper.c:    set_flush_to_zero(vscr_nj, &env->vec_status);
target-ppc/op_helper.c:                r->f[i] = func(a->f[i], b->f[i], &env->vec_status);     \
target-ppc/op_helper.c:            env->vscr |= (1 << VSCR_SAT);                               \
target-ppc/op_helper.c:            float32 t = cvt(b->element[i], &env->vec_status);           \
target-ppc/op_helper.c:            r->f[i] = float32_scalbn (t, -uim, &env->vec_status);       \
target-ppc/op_helper.c:            env->crf[6] = ((all != 0) << 3) | ((none == 0) << 1);       \
target-ppc/op_helper.c:            int rel = float32_compare_quiet(a->f[i], b->f[i], &env->vec_status); \
target-ppc/op_helper.c:            env->crf[6] = ((all != 0) << 3) | ((none == 0) << 1);       \
target-ppc/op_helper.c:        int le_rel = float32_compare_quiet(a->f[i], b->f[i], &env->vec_status);
target-ppc/op_helper.c:            int ge_rel = float32_compare_quiet(a->f[i], bneg, &env->vec_status);
target-ppc/op_helper.c:        env->crf[6] = (all_in == 0) << 1;
target-ppc/op_helper.c:        float_status s = env->vec_status;                               \
target-ppc/op_helper.c:            env->vscr |= (1 << VSCR_SAT);                               \
target-ppc/op_helper.c:            af = float32_to_float64(a->f[i], &env->vec_status);
target-ppc/op_helper.c:            bf = float32_to_float64(b->f[i], &env->vec_status);
target-ppc/op_helper.c:            cf = float32_to_float64(c->f[i], &env->vec_status);
target-ppc/op_helper.c:            t = float64_mul(af, cf, &env->vec_status);
target-ppc/op_helper.c:            t = float64_add(t, bf, &env->vec_status);
target-ppc/op_helper.c:            r->f[i] = float64_to_float32(t, &env->vec_status);
target-ppc/op_helper.c:        env->vscr |= (1 << VSCR_SAT);
target-ppc/op_helper.c:        env->vscr |= (1 << VSCR_SAT);
target-ppc/op_helper.c:                if (float32_lt_quiet(a->f[i], b->f[i], &env->vec_status)) { \
target-ppc/op_helper.c:        env->vscr |= (1 << VSCR_SAT);
target-ppc/op_helper.c:        env->vscr |= (1 << VSCR_SAT);
target-ppc/op_helper.c:            af = float32_to_float64(a->f[i], &env->vec_status);
target-ppc/op_helper.c:            bf = float32_to_float64(b->f[i], &env->vec_status);
target-ppc/op_helper.c:            cf = float32_to_float64(c->f[i], &env->vec_status);
target-ppc/op_helper.c:            t = float64_mul(af, cf, &env->vec_status);
target-ppc/op_helper.c:            t = float64_sub(t, bf, &env->vec_status);
target-ppc/op_helper.c:            r->f[i] = float64_to_float32(t, &env->vec_status);
target-ppc/op_helper.c:            env->vscr |= (1 << VSCR_SAT);                               \
target-ppc/op_helper.c:            r->f[i] = float32_div(float32_one, b->f[i], &env->vec_status);
target-ppc/op_helper.c:        float_status s = env->vec_status;                               \
target-ppc/op_helper.c:            float32 t = float32_sqrt(b->f[i], &env->vec_status);
target-ppc/op_helper.c:            r->f[i] = float32_div(float32_one, t, &env->vec_status);
target-ppc/op_helper.c:            r->f[i] = float32_exp2(b->f[i], &env->vec_status);
target-ppc/op_helper.c:            r->f[i] = float32_log2(b->f[i], &env->vec_status);
target-ppc/op_helper.c:        env->vscr |= (1 << VSCR_SAT);
target-ppc/op_helper.c:        env->vscr |= (1 << VSCR_SAT);
target-ppc/op_helper.c:        env->vscr |= (1 << VSCR_SAT);
target-ppc/op_helper.c:        env->vscr |= (1 << VSCR_SAT);
target-ppc/op_helper.c:        env->vscr |= (1 << VSCR_SAT);
target-ppc/op_helper.c:    u.f = int32_to_float32(val, &env->vec_status);
target-ppc/op_helper.c:    u.f = uint32_to_float32(val, &env->vec_status);
target-ppc/op_helper.c:    return float32_to_int32(u.f, &env->vec_status);
target-ppc/op_helper.c:    return float32_to_uint32(u.f, &env->vec_status);
target-ppc/op_helper.c:    return float32_to_int32_round_to_zero(u.f, &env->vec_status);
target-ppc/op_helper.c:    return float32_to_uint32_round_to_zero(u.f, &env->vec_status);
target-ppc/op_helper.c:    u.f = int32_to_float32(val, &env->vec_status);
target-ppc/op_helper.c:    tmp = int64_to_float32(1ULL << 32, &env->vec_status);
target-ppc/op_helper.c:    u.f = float32_div(u.f, tmp, &env->vec_status);
target-ppc/op_helper.c:    u.f = uint32_to_float32(val, &env->vec_status);
target-ppc/op_helper.c:    tmp = uint64_to_float32(1ULL << 32, &env->vec_status);
target-ppc/op_helper.c:    u.f = float32_div(u.f, tmp, &env->vec_status);
target-ppc/op_helper.c:    tmp = uint64_to_float32(1ULL << 32, &env->vec_status);
target-ppc/op_helper.c:    u.f = float32_mul(u.f, tmp, &env->vec_status);
target-ppc/op_helper.c:    return float32_to_int32(u.f, &env->vec_status);
target-ppc/op_helper.c:    tmp = uint64_to_float32(1ULL << 32, &env->vec_status);
target-ppc/op_helper.c:    u.f = float32_mul(u.f, tmp, &env->vec_status);
target-ppc/op_helper.c:    return float32_to_uint32(u.f, &env->vec_status);
target-ppc/op_helper.c:    u1.f = float32_add(u1.f, u2.f, &env->vec_status);
target-ppc/op_helper.c:    u1.f = float32_sub(u1.f, u2.f, &env->vec_status);
target-ppc/op_helper.c:    u1.f = float32_mul(u1.f, u2.f, &env->vec_status);
target-ppc/op_helper.c:    u1.f = float32_div(u1.f, u2.f, &env->vec_status);
target-ppc/op_helper.c:    return float32_lt(u1.f, u2.f, &env->vec_status) ? 4 : 0;
target-ppc/op_helper.c:    return float32_le(u1.f, u2.f, &env->vec_status) ? 0 : 4;
target-ppc/op_helper.c:    return float32_eq(u1.f, u2.f, &env->vec_status) ? 4 : 0;
target-ppc/op_helper.c:    u.d = int32_to_float64(val, &env->vec_status);
target-ppc/op_helper.c:    u.d = int64_to_float64(val, &env->vec_status);
target-ppc/op_helper.c:    u.d = uint32_to_float64(val, &env->vec_status);
target-ppc/op_helper.c:    u.d = uint64_to_float64(val, &env->vec_status);
target-ppc/op_helper.c:    return float64_to_int32(u.d, &env->vec_status);
target-ppc/op_helper.c:    return float64_to_uint32(u.d, &env->vec_status);
target-ppc/op_helper.c:    return float64_to_int32_round_to_zero(u.d, &env->vec_status);
target-ppc/op_helper.c:    return float64_to_int64_round_to_zero(u.d, &env->vec_status);
target-ppc/op_helper.c:    return float64_to_uint32_round_to_zero(u.d, &env->vec_status);
target-ppc/op_helper.c:    return float64_to_uint64_round_to_zero(u.d, &env->vec_status);
target-ppc/op_helper.c:    u.d = int32_to_float64(val, &env->vec_status);
target-ppc/op_helper.c:    tmp = int64_to_float64(1ULL << 32, &env->vec_status);
target-ppc/op_helper.c:    u.d = float64_div(u.d, tmp, &env->vec_status);
target-ppc/op_helper.c:    u.d = uint32_to_float64(val, &env->vec_status);
target-ppc/op_helper.c:    tmp = int64_to_float64(1ULL << 32, &env->vec_status);
target-ppc/op_helper.c:    u.d = float64_div(u.d, tmp, &env->vec_status);
target-ppc/op_helper.c:    tmp = uint64_to_float64(1ULL << 32, &env->vec_status);
target-ppc/op_helper.c:    u.d = float64_mul(u.d, tmp, &env->vec_status);
target-ppc/op_helper.c:    return float64_to_int32(u.d, &env->vec_status);
target-ppc/op_helper.c:    tmp = uint64_to_float64(1ULL << 32, &env->vec_status);
target-ppc/op_helper.c:    u.d = float64_mul(u.d, tmp, &env->vec_status);
target-ppc/op_helper.c:    return float64_to_uint32(u.d, &env->vec_status);
target-ppc/op_helper.c:    u2.f = float64_to_float32(u1.d, &env->vec_status);
target-ppc/op_helper.c:    u2.d = float32_to_float64(u1.f, &env->vec_status);
target-ppc/op_helper.c:    u1.d = float64_add(u1.d, u2.d, &env->vec_status);
target-ppc/op_helper.c:    u1.d = float64_sub(u1.d, u2.d, &env->vec_status);
target-ppc/op_helper.c:    u1.d = float64_mul(u1.d, u2.d, &env->vec_status);
target-ppc/op_helper.c:    u1.d = float64_div(u1.d, u2.d, &env->vec_status);
target-ppc/op_helper.c:    return float64_lt(u1.d, u2.d, &env->vec_status) ? 4 : 0;
target-ppc/op_helper.c:    return float64_le(u1.d, u2.d, &env->vec_status) ? 0 : 4;
target-ppc/op_helper.c:    return float64_eq_quiet(u1.d, u2.d, &env->vec_status) ? 4 : 0;
target-ppc/op_helper.c:        helper_raise_exception_err(env->exception_index, env->error_code);
target-ppc/op_helper.c:    if (env->mmu_model & POWERPC_MMU_64)
target-ppc/op_helper.c:    return env->sr[sr_num];
target-ppc/op_helper.c:    RPN = env->spr[SPR_RPA];
target-ppc/op_helper.c:        CMP = env->spr[SPR_ICMP];
target-ppc/op_helper.c:        EPN = env->spr[SPR_IMISS];
target-ppc/op_helper.c:        CMP = env->spr[SPR_DCMP];
target-ppc/op_helper.c:        EPN = env->spr[SPR_DMISS];
target-ppc/op_helper.c:    way = (env->spr[SPR_SRR1] >> 17) & 1;
target-ppc/op_helper.c:    RPN = env->spr[SPR_PTELO];
target-ppc/op_helper.c:    CMP = env->spr[SPR_PTEHI];
target-ppc/op_helper.c:    EPN = env->spr[SPR_TLBMISS] & ~0x3;
target-ppc/op_helper.c:    way = env->spr[SPR_TLBMISS] & 0x3;
target-ppc/op_helper.c:    tlb = &env->tlb.tlbe[entry];
target-ppc/op_helper.c:    env->spr[SPR_40x_PID] = tlb->PID;
target-ppc/op_helper.c:    tlb = &env->tlb.tlbe[entry];
target-ppc/op_helper.c:    tlb = &env->tlb.tlbe[entry];
target-ppc/op_helper.c:    tlb->PID = env->spr[SPR_40x_PID]; /* PID */
target-ppc/op_helper.c:    tlb = &env->tlb.tlbe[entry];
target-ppc/op_helper.c:    return ppcemb_tlb_search(env, address, env->spr[SPR_40x_PID]);
target-ppc/op_helper.c:    tlb = &env->tlb.tlbe[entry];
target-ppc/op_helper.c:        tlb->PID = env->spr[SPR_440_MMUCR] & 0x000000FF;
target-ppc/op_helper.c:    tlb = &env->tlb.tlbe[entry];
target-ppc/op_helper.c:        env->spr[SPR_440_MMUCR] &= ~0x000000FF;
target-ppc/op_helper.c:        env->spr[SPR_440_MMUCR] |= tlb->PID;
target-ppc/op_helper.c:    return ppcemb_tlb_search(env, address, env->spr[SPR_440_MMUCR] & 0xFF);
target-ppc/op_helper.c:    int esel = (env->spr[SPR_BOOKE_MAS0] & MAS0_ESEL_MASK) >> MAS0_ESEL_SHIFT;
target-ppc/op_helper.c:    int ea = (env->spr[SPR_BOOKE_MAS2] & MAS2_EPN_MASK);
target-ppc/op_helper.c:    tlb = (env->spr[SPR_BOOKE_MAS0] & MAS0_TLBSEL_MASK) >> MAS0_TLBSEL_SHIFT;
target-ppc/op_helper.c:    tlbncfg = env->spr[SPR_BOOKE_TLB0CFG + tlb];
target-ppc/op_helper.c:    if ((tlbncfg & TLBnCFG_HES) && (env->spr[SPR_BOOKE_MAS0] & MAS0_HES)) {
target-ppc/op_helper.c:    env->spr[pidn] = pid;
target-ppc/op_helper.c:    switch (env->spr[SPR_BOOKE_MAS0] & MAS0_WQ_MASK) {
target-ppc/op_helper.c:    if (((env->spr[SPR_BOOKE_MAS0] & MAS0_ATSEL) == MAS0_ATSEL_LRAT) &&
target-ppc/op_helper.c:    tlbn = (env->spr[SPR_BOOKE_MAS0] & MAS0_TLBSEL_MASK) >> MAS0_TLBSEL_SHIFT;
target-ppc/op_helper.c:    tlbncfg = env->spr[SPR_BOOKE_TLB0CFG + tlbn];
target-ppc/op_helper.c:    size_tlb = (env->spr[SPR_BOOKE_MAS1] & MAS1_TSIZE_MASK) >> MAS1_TSIZE_SHIFT;
target-ppc/op_helper.c:    if ((env->spr[SPR_BOOKE_MAS1] & MAS1_VALID) && (tlbncfg & TLBnCFG_AVAIL) &&
target-ppc/op_helper.c:    tlb->mas7_3 = ((uint64_t)env->spr[SPR_BOOKE_MAS7] << 32) |
target-ppc/op_helper.c:                  env->spr[SPR_BOOKE_MAS3];
target-ppc/op_helper.c:    tlb->mas1 = env->spr[SPR_BOOKE_MAS1];
target-ppc/op_helper.c:    tlb->mas2 = env->spr[SPR_BOOKE_MAS2] & 0xffffffff;
target-ppc/op_helper.c:    env->spr[SPR_BOOKE_MAS0] = tlbn << MAS0_TLBSEL_SHIFT;
target-ppc/op_helper.c:    env->spr[SPR_BOOKE_MAS0] |= way << MAS0_ESEL_SHIFT;
target-ppc/op_helper.c:    env->spr[SPR_BOOKE_MAS0] |= env->last_way << MAS0_NV_SHIFT;
target-ppc/op_helper.c:    env->spr[SPR_BOOKE_MAS1] = tlb->mas1;
target-ppc/op_helper.c:    env->spr[SPR_BOOKE_MAS2] = tlb->mas2;
target-ppc/op_helper.c:    env->spr[SPR_BOOKE_MAS3] = tlb->mas7_3;
target-ppc/op_helper.c:    env->spr[SPR_BOOKE_MAS7] = tlb->mas7_3 >> 32;
target-ppc/op_helper.c:        env->spr[SPR_BOOKE_MAS1] = 0;
target-ppc/op_helper.c:    spid = (env->spr[SPR_BOOKE_MAS6] & MAS6_SPID_MASK) >> MAS6_SPID_SHIFT;
target-ppc/op_helper.c:    sas = env->spr[SPR_BOOKE_MAS6] & MAS6_SAS;
target-ppc/op_helper.c:    env->spr[SPR_BOOKE_MAS0] = env->spr[SPR_BOOKE_MAS4] & MAS4_TLBSELD_MASK;
target-ppc/op_helper.c:    env->spr[SPR_BOOKE_MAS1] = env->spr[SPR_BOOKE_MAS4] & MAS4_TSIZED_MASK;
target-ppc/op_helper.c:    env->spr[SPR_BOOKE_MAS2] = env->spr[SPR_BOOKE_MAS4] & MAS4_WIMGED_MASK;
target-ppc/op_helper.c:    env->spr[SPR_BOOKE_MAS3] = 0;
target-ppc/op_helper.c:    env->spr[SPR_BOOKE_MAS7] = 0;
target-ppc/op_helper.c:    if (env->spr[SPR_BOOKE_MAS6] & MAS6_SAS) {
target-ppc/op_helper.c:        env->spr[SPR_BOOKE_MAS1] |= MAS1_TS;
target-ppc/op_helper.c:    env->spr[SPR_BOOKE_MAS1] |= (env->spr[SPR_BOOKE_MAS6] >> 16)
target-ppc/op_helper.c:    env->spr[SPR_BOOKE_MAS0] |= env->last_way << MAS0_ESEL_SHIFT;
target-ppc/op_helper.c:    env->last_way++;
target-ppc/op_helper.c:    env->last_way &= booke206_tlb_ways(env, 0) - 1;
target-ppc/op_helper.c:    env->spr[SPR_BOOKE_MAS0] |= env->last_way << MAS0_NV_SHIFT;
target-ppc/op_helper.c:    int tid = (env->spr[SPR_BOOKE_MAS6] & MAS6_SPID);
target-ppc/op_helper.c:    ppcmas_tlb_t *tlb = env->tlb.tlbm;
target-ppc/op_helper.c:    int tid = (env->spr[SPR_BOOKE_MAS6] & MAS6_SPID);
target-ppc/op_helper.c:    int sgs = env->spr[SPR_BOOKE_MAS5] & MAS5_SGS;
target-ppc/op_helper.c:    int ind = (env->spr[SPR_BOOKE_MAS6] & MAS6_SIND) ? MAS1_IND : 0;
target-ppc/op_helper.c:    int size = env->spr[SPR_BOOKE_MAS6] & MAS6_ISIZE_MASK;
target-ppc/op_helper.c:    env->pending_interrupts &= ~(1 << irq);
target-ppc/op_helper.c:    for (cenv = first_cpu; cenv != NULL; cenv = cenv->next_cpu) {
target-ppc/op_helper.c:        if ((rb & DBELL_BRDCAST) || (cenv->spr[SPR_BOOKE_PIR] == pir)) {
target-ppc/op_helper.c:            cenv->pending_interrupts |= 1 << irq;
target-ppc/translate_init.c:    env->vscr = val;
target-ppc/translate_init.c:    set_float_rounding_mode(float_round_nearest_even, &env->vec_status);
target-ppc/translate_init.c:    set_flush_to_zero(vscr_nj, &env->vec_status);
target-ppc/translate_init.c:    spr = &env->spr_cb[num];
target-ppc/translate_init.c:    if (spr->name != NULL ||env-> spr[num] != 0x00000000 ||
target-ppc/translate_init.c:    env->spr[num] = initial_value;
target-ppc/translate_init.c:    env->nb_BATs += 4;
target-ppc/translate_init.c:    env->nb_BATs += 4;
target-ppc/translate_init.c:    env->nb_tlb = nb_tlbs;
target-ppc/translate_init.c:    env->nb_ways = nb_ways;
target-ppc/translate_init.c:    env->id_tlbs = 1;
target-ppc/translate_init.c:    env->tlb_type = TLB_6XX;
target-ppc/translate_init.c:    env->nb_BATs = 4;
target-ppc/translate_init.c:    env->nb_tlb = nb_tlbs;
target-ppc/translate_init.c:    env->nb_ways = nb_ways;
target-ppc/translate_init.c:    env->id_tlbs = 1;
target-ppc/translate_init.c:    env->tlb_type = TLB_6XX;
target-ppc/translate_init.c:    if (env->nb_pids > 1) {
target-ppc/translate_init.c:    if (env->nb_pids > 2) {
target-ppc/translate_init.c:    switch (env->nb_ways) {
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_CRITICAL] = 0x00000100;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_MCHECK]   = 0x00000200;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_EXTERNAL] = 0x00000500;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_ALIGN]    = 0x00000600;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_PROGRAM]  = 0x00000700;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_SYSCALL]  = 0x00000C00;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_PIT]      = 0x00001000;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_FIT]      = 0x00001010;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_WDT]      = 0x00001020;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_DEBUG]    = 0x00002000;
target-ppc/translate_init.c:    env->hreset_excp_prefix = 0x00000000UL;
target-ppc/translate_init.c:    env->ivor_mask = 0x0000FFF0UL;
target-ppc/translate_init.c:    env->ivpr_mask = 0xFFFF0000UL;
target-ppc/translate_init.c:    env->hreset_vector = 0xFFFFFFFCUL;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_CRITICAL] = 0x00000100;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_MCHECK]   = 0x00000200;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_DSI]      = 0x00000300;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_ISI]      = 0x00000400;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_EXTERNAL] = 0x00000500;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_ALIGN]    = 0x00000600;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_PROGRAM]  = 0x00000700;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_SYSCALL]  = 0x00000C00;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_PIT]      = 0x00001000;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_FIT]      = 0x00001010;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_WDT]      = 0x00001020;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_DTLB]     = 0x00001100;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_ITLB]     = 0x00001200;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_DEBUG]    = 0x00002000;
target-ppc/translate_init.c:    env->hreset_excp_prefix = 0x00000000UL;
target-ppc/translate_init.c:    env->ivor_mask = 0x0000FFF0UL;
target-ppc/translate_init.c:    env->ivpr_mask = 0xFFFF0000UL;
target-ppc/translate_init.c:    env->hreset_vector = 0xFFFFFFFCUL;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_RESET]    = 0x00000100;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_MCHECK]   = 0x00000200;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_EXTERNAL] = 0x00000500;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_ALIGN]    = 0x00000600;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_PROGRAM]  = 0x00000700;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_FPU]      = 0x00000900;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_DECR]     = 0x00000900;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_SYSCALL]  = 0x00000C00;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_TRACE]    = 0x00000D00;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_FPA]      = 0x00000E00;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_EMUL]     = 0x00001000;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_DABR]     = 0x00001C00;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_IABR]     = 0x00001C00;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_MEXTBR]   = 0x00001E00;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_NMEXTBR]  = 0x00001F00;
target-ppc/translate_init.c:    env->hreset_excp_prefix = 0x00000000UL;
target-ppc/translate_init.c:    env->ivor_mask = 0x0000FFF0UL;
target-ppc/translate_init.c:    env->ivpr_mask = 0xFFFF0000UL;
target-ppc/translate_init.c:    env->hreset_vector = 0xFFFFFFFCUL;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_RESET]    = 0x00000100;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_MCHECK]   = 0x00000200;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_DSI]      = 0x00000300;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_ISI]      = 0x00000400;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_EXTERNAL] = 0x00000500;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_ALIGN]    = 0x00000600;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_PROGRAM]  = 0x00000700;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_FPU]      = 0x00000900;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_DECR]     = 0x00000900;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_SYSCALL]  = 0x00000C00;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_TRACE]    = 0x00000D00;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_FPA]      = 0x00000E00;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_EMUL]     = 0x00001000;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_ITLB]     = 0x00001100;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_DTLB]     = 0x00001200;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_ITLBE]    = 0x00001300;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_DTLBE]    = 0x00001400;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_DABR]     = 0x00001C00;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_IABR]     = 0x00001C00;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_MEXTBR]   = 0x00001E00;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_NMEXTBR]  = 0x00001F00;
target-ppc/translate_init.c:    env->hreset_excp_prefix = 0x00000000UL;
target-ppc/translate_init.c:    env->ivor_mask = 0x0000FFF0UL;
target-ppc/translate_init.c:    env->ivpr_mask = 0xFFFF0000UL;
target-ppc/translate_init.c:    env->hreset_vector = 0xFFFFFFFCUL;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_RESET]    = 0x00000100;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_MCHECK]   = 0x00000200;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_DSI]      = 0x00000300;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_ISI]      = 0x00000400;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_EXTERNAL] = 0x00000500;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_ALIGN]    = 0x00000600;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_PROGRAM]  = 0x00000700;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_FPU]      = 0x00000800;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_DECR]     = 0x00000900;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_CRITICAL] = 0x00000A00;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_SYSCALL]  = 0x00000C00;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_TRACE]    = 0x00000D00;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_IFTLB]    = 0x00001000;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_DLTLB]    = 0x00001100;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_DSTLB]    = 0x00001200;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_IABR]     = 0x00001300;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_SMI]      = 0x00001400;
target-ppc/translate_init.c:    env->hreset_excp_prefix = 0x00000000UL;
target-ppc/translate_init.c:    env->hreset_vector = 0xFFFFFFFCUL;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_RESET]    = 0x00000FFC;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_CRITICAL] = 0x00000000;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_MCHECK]   = 0x00000000;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_DSI]      = 0x00000000;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_ISI]      = 0x00000000;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_EXTERNAL] = 0x00000000;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_ALIGN]    = 0x00000000;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_PROGRAM]  = 0x00000000;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_FPU]      = 0x00000000;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_SYSCALL]  = 0x00000000;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_APU]      = 0x00000000;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_DECR]     = 0x00000000;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_FIT]      = 0x00000000;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_WDT]      = 0x00000000;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_DTLB]     = 0x00000000;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_ITLB]     = 0x00000000;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_DEBUG]    = 0x00000000;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_SPEU]     = 0x00000000;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_EFPDI]    = 0x00000000;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_EFPRI]    = 0x00000000;
target-ppc/translate_init.c:    env->hreset_excp_prefix = 0x00000000UL;
target-ppc/translate_init.c:    env->ivor_mask = 0x0000FFF7UL;
target-ppc/translate_init.c:    env->ivpr_mask = 0xFFFF0000UL;
target-ppc/translate_init.c:    env->hreset_vector = 0xFFFFFFFCUL;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_CRITICAL] = 0x00000000;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_MCHECK]   = 0x00000000;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_DSI]      = 0x00000000;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_ISI]      = 0x00000000;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_EXTERNAL] = 0x00000000;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_ALIGN]    = 0x00000000;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_PROGRAM]  = 0x00000000;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_FPU]      = 0x00000000;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_SYSCALL]  = 0x00000000;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_APU]      = 0x00000000;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_DECR]     = 0x00000000;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_FIT]      = 0x00000000;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_WDT]      = 0x00000000;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_DTLB]     = 0x00000000;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_ITLB]     = 0x00000000;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_DEBUG]    = 0x00000000;
target-ppc/translate_init.c:    env->hreset_excp_prefix = 0x00000000UL;
target-ppc/translate_init.c:    env->ivor_mask = 0x0000FFE0UL;
target-ppc/translate_init.c:    env->ivpr_mask = 0xFFFF0000UL;
target-ppc/translate_init.c:    env->hreset_vector = 0xFFFFFFFCUL;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_RESET]    = 0x00000100;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_MCHECK]   = 0x00000200;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_DSI]      = 0x00000300;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_ISI]      = 0x00000400;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_EXTERNAL] = 0x00000500;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_ALIGN]    = 0x00000600;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_PROGRAM]  = 0x00000700;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_FPU]      = 0x00000800;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_DECR]     = 0x00000900;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_IO]       = 0x00000A00;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_SYSCALL]  = 0x00000C00;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_RUNM]     = 0x00002000;
target-ppc/translate_init.c:    env->hreset_excp_prefix = 0xFFF00000UL;
target-ppc/translate_init.c:    env->hreset_vector = 0x00000100UL;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_RESET]    = 0x00000100;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_MCHECK]   = 0x00000200;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_DSI]      = 0x00000300;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_ISI]      = 0x00000400;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_EXTERNAL] = 0x00000500;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_ALIGN]    = 0x00000600;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_PROGRAM]  = 0x00000700;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_FPU]      = 0x00000800;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_DECR]     = 0x00000900;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_SYSCALL]  = 0x00000C00;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_TRACE]    = 0x00000D00;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_IFTLB]    = 0x00001000;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_DLTLB]    = 0x00001100;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_DSTLB]    = 0x00001200;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_IABR]     = 0x00001300;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_SMI]      = 0x00001400;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_WDT]      = 0x00001500;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_EMUL]     = 0x00001600;
target-ppc/translate_init.c:    env->hreset_excp_prefix = 0xFFF00000UL;
target-ppc/translate_init.c:    env->hreset_vector = 0xFFFFFFFCUL;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_RESET]    = 0x00000100;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_MCHECK]   = 0x00000200;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_DSI]      = 0x00000300;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_ISI]      = 0x00000400;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_EXTERNAL] = 0x00000500;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_ALIGN]    = 0x00000600;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_PROGRAM]  = 0x00000700;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_FPU]      = 0x00000800;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_DECR]     = 0x00000900;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_SYSCALL]  = 0x00000C00;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_TRACE]    = 0x00000D00;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_IFTLB]    = 0x00001000;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_DLTLB]    = 0x00001100;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_DSTLB]    = 0x00001200;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_IABR]     = 0x00001300;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_SMI]      = 0x00001400;
target-ppc/translate_init.c:    env->hreset_excp_prefix = 0x00000000UL;
target-ppc/translate_init.c:    env->hreset_vector = 0xFFFFFFFCUL;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_RESET]    = 0x00000100;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_MCHECK]   = 0x00000200;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_DSI]      = 0x00000300;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_ISI]      = 0x00000400;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_EXTERNAL] = 0x00000500;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_ALIGN]    = 0x00000600;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_PROGRAM]  = 0x00000700;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_FPU]      = 0x00000800;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_DECR]     = 0x00000900;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_SYSCALL]  = 0x00000C00;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_TRACE]    = 0x00000D00;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_PERFM]    = 0x00000F00;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_IABR]     = 0x00001300;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_SMI]      = 0x00001400;
target-ppc/translate_init.c:    env->hreset_excp_prefix = 0xFFF00000UL;
target-ppc/translate_init.c:    env->hreset_vector = 0x00000100UL;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_RESET]    = 0x00000100;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_MCHECK]   = 0x00000200;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_DSI]      = 0x00000300;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_ISI]      = 0x00000400;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_EXTERNAL] = 0x00000500;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_ALIGN]    = 0x00000600;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_PROGRAM]  = 0x00000700;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_FPU]      = 0x00000800;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_DECR]     = 0x00000900;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_SYSCALL]  = 0x00000C00;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_TRACE]    = 0x00000D00;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_PERFM]    = 0x00000F00;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_IABR]     = 0x00001300;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_SMI]      = 0x00001400;
target-ppc/translate_init.c:    env->hreset_excp_prefix = 0xFFF00000UL;
target-ppc/translate_init.c:    env->hreset_vector = 0x0000000000000100ULL;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_RESET]    = 0x00000100;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_MCHECK]   = 0x00000200;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_DSI]      = 0x00000300;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_ISI]      = 0x00000400;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_EXTERNAL] = 0x00000500;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_ALIGN]    = 0x00000600;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_PROGRAM]  = 0x00000700;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_FPU]      = 0x00000800;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_DECR]     = 0x00000900;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_SYSCALL]  = 0x00000C00;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_TRACE]    = 0x00000D00;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_PERFM]    = 0x00000F00;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_IABR]     = 0x00001300;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_SMI]      = 0x00001400;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_THERM]    = 0x00001700;
target-ppc/translate_init.c:    env->hreset_excp_prefix = 0x00000000UL;
target-ppc/translate_init.c:    env->hreset_vector = 0xFFFFFFFCUL;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_RESET]    = 0x00000100;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_MCHECK]   = 0x00000200;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_DSI]      = 0x00000300;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_ISI]      = 0x00000400;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_EXTERNAL] = 0x00000500;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_ALIGN]    = 0x00000600;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_PROGRAM]  = 0x00000700;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_FPU]      = 0x00000800;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_DECR]     = 0x00000900;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_SYSCALL]  = 0x00000C00;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_TRACE]    = 0x00000D00;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_PERFM]    = 0x00000F00;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_IABR]     = 0x00001300;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_SMI]      = 0x00001400;
target-ppc/translate_init.c:    env->hreset_excp_prefix = 0x00000000UL;
target-ppc/translate_init.c:    env->hreset_vector = 0xFFFFFFFCUL;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_RESET]    = 0x00000100;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_MCHECK]   = 0x00000200;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_DSI]      = 0x00000300;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_ISI]      = 0x00000400;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_EXTERNAL] = 0x00000500;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_ALIGN]    = 0x00000600;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_PROGRAM]  = 0x00000700;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_FPU]      = 0x00000800;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_DECR]     = 0x00000900;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_SYSCALL]  = 0x00000C00;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_TRACE]    = 0x00000D00;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_PERFM]    = 0x00000F00;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_IABR]     = 0x00001300;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_THERM]    = 0x00001700;
target-ppc/translate_init.c:    env->hreset_excp_prefix = 0x00000000UL;
target-ppc/translate_init.c:    env->hreset_vector = 0xFFFFFFFCUL;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_RESET]    = 0x00000100;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_MCHECK]   = 0x00000200;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_DSI]      = 0x00000300;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_ISI]      = 0x00000400;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_EXTERNAL] = 0x00000500;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_ALIGN]    = 0x00000600;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_PROGRAM]  = 0x00000700;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_FPU]      = 0x00000800;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_DECR]     = 0x00000900;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_SYSCALL]  = 0x00000C00;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_TRACE]    = 0x00000D00;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_PERFM]    = 0x00000F00;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_IFTLB]    = 0x00001000;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_DLTLB]    = 0x00001100;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_DSTLB]    = 0x00001200;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_IABR]     = 0x00001300;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_SMI]      = 0x00001400;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_THERM]    = 0x00001700;
target-ppc/translate_init.c:    env->hreset_excp_prefix = 0x00000000UL;
target-ppc/translate_init.c:    env->hreset_vector = 0xFFFFFFFCUL;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_RESET]    = 0x00000100;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_MCHECK]   = 0x00000200;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_DSI]      = 0x00000300;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_ISI]      = 0x00000400;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_EXTERNAL] = 0x00000500;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_ALIGN]    = 0x00000600;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_PROGRAM]  = 0x00000700;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_FPU]      = 0x00000800;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_DECR]     = 0x00000900;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_SYSCALL]  = 0x00000C00;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_TRACE]    = 0x00000D00;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_PERFM]    = 0x00000F00;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_VPU]      = 0x00000F20;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_IABR]     = 0x00001300;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_SMI]      = 0x00001400;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_VPUA]     = 0x00001600;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_THERM]    = 0x00001700;
target-ppc/translate_init.c:    env->hreset_excp_prefix = 0x00000000UL;
target-ppc/translate_init.c:    env->hreset_vector = 0xFFFFFFFCUL;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_RESET]    = 0x00000100;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_MCHECK]   = 0x00000200;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_DSI]      = 0x00000300;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_ISI]      = 0x00000400;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_EXTERNAL] = 0x00000500;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_ALIGN]    = 0x00000600;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_PROGRAM]  = 0x00000700;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_FPU]      = 0x00000800;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_DECR]     = 0x00000900;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_SYSCALL]  = 0x00000C00;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_TRACE]    = 0x00000D00;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_PERFM]    = 0x00000F00;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_VPU]      = 0x00000F20;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_IFTLB]    = 0x00001000;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_DLTLB]    = 0x00001100;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_DSTLB]    = 0x00001200;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_IABR]     = 0x00001300;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_SMI]      = 0x00001400;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_VPUA]     = 0x00001600;
target-ppc/translate_init.c:    env->hreset_excp_prefix = 0x00000000UL;
target-ppc/translate_init.c:    env->hreset_vector = 0xFFFFFFFCUL;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_RESET]    = 0x00000100;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_MCHECK]   = 0x00000200;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_DSI]      = 0x00000300;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_DSEG]     = 0x00000380;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_ISI]      = 0x00000400;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_ISEG]     = 0x00000480;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_EXTERNAL] = 0x00000500;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_ALIGN]    = 0x00000600;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_PROGRAM]  = 0x00000700;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_FPU]      = 0x00000800;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_DECR]     = 0x00000900;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_HDECR]    = 0x00000980;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_SYSCALL]  = 0x00000C00;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_TRACE]    = 0x00000D00;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_PERFM]    = 0x00000F00;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_VPU]      = 0x00000F20;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_IABR]     = 0x00001300;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_MAINT]    = 0x00001600;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_VPUA]     = 0x00001700;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_THERM]    = 0x00001800;
target-ppc/translate_init.c:    env->hreset_excp_prefix = 0x00000000FFF00000ULL;
target-ppc/translate_init.c:    env->hreset_vector = 0x0000000000000100ULL;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_RESET]    = 0x00000100;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_MCHECK]   = 0x00000200;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_DSI]      = 0x00000300;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_DSEG]     = 0x00000380;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_ISI]      = 0x00000400;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_ISEG]     = 0x00000480;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_EXTERNAL] = 0x00000500;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_ALIGN]    = 0x00000600;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_PROGRAM]  = 0x00000700;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_FPU]      = 0x00000800;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_DECR]     = 0x00000900;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_HDECR]    = 0x00000980;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_SYSCALL]  = 0x00000C00;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_TRACE]    = 0x00000D00;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_PERFM]    = 0x00000F00;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_VPU]      = 0x00000F20;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_IABR]     = 0x00001300;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_MAINT]    = 0x00001600;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_VPUA]     = 0x00001700;
target-ppc/translate_init.c:    env->excp_vectors[POWERPC_EXCP_THERM]    = 0x00001800;
target-ppc/translate_init.c:    env->hreset_excp_prefix = 0;
target-ppc/translate_init.c:    env->hreset_vector = 0x0000000000000100ULL;
target-ppc/translate_init.c:    if (env->spr[SPR_HID0] & 0x00E00000)
target-ppc/translate_init.c:    if (env->spr[SPR_HID0] & 0x00600000)
target-ppc/translate_init.c:    env->dcache_line_size = 32;
target-ppc/translate_init.c:    env->icache_line_size = 32;
target-ppc/translate_init.c:    env->nb_tlb = 64;
target-ppc/translate_init.c:    env->nb_ways = 1;
target-ppc/translate_init.c:    env->id_tlbs = 0;
target-ppc/translate_init.c:    env->tlb_type = TLB_EMB;
target-ppc/translate_init.c:    env->dcache_line_size = 32;
target-ppc/translate_init.c:    env->icache_line_size = 32;
target-ppc/translate_init.c:    env->dcache_line_size = 32;
target-ppc/translate_init.c:    env->icache_line_size = 32;
target-ppc/translate_init.c:    env->nb_tlb = 64;
target-ppc/translate_init.c:    env->nb_ways = 1;
target-ppc/translate_init.c:    env->id_tlbs = 0;
target-ppc/translate_init.c:    env->tlb_type = TLB_EMB;
target-ppc/translate_init.c:    env->dcache_line_size = 32;
target-ppc/translate_init.c:    env->icache_line_size = 32;
target-ppc/translate_init.c:    env->dcache_line_size = 32;
target-ppc/translate_init.c:    env->icache_line_size = 32;
target-ppc/translate_init.c:    env->nb_tlb = 64;
target-ppc/translate_init.c:    env->nb_ways = 1;
target-ppc/translate_init.c:    env->id_tlbs = 0;
target-ppc/translate_init.c:    env->tlb_type = TLB_EMB;
target-ppc/translate_init.c:    env->dcache_line_size = 32;
target-ppc/translate_init.c:    env->icache_line_size = 32;
target-ppc/translate_init.c:    env->nb_tlb = 64;
target-ppc/translate_init.c:    env->nb_ways = 1;
target-ppc/translate_init.c:    env->id_tlbs = 0;
target-ppc/translate_init.c:    env->tlb_type = TLB_EMB;
target-ppc/translate_init.c:    env->dcache_line_size = 32;
target-ppc/translate_init.c:    env->icache_line_size = 32;
target-ppc/translate_init.c:    env->nb_tlb = 64;
target-ppc/translate_init.c:    env->nb_ways = 1;
target-ppc/translate_init.c:    env->id_tlbs = 0;
target-ppc/translate_init.c:    env->tlb_type = TLB_EMB;
target-ppc/translate_init.c:    env->dcache_line_size = 32;
target-ppc/translate_init.c:    env->icache_line_size = 32;
target-ppc/translate_init.c:    env->nb_tlb = 64;
target-ppc/translate_init.c:    env->nb_ways = 1;
target-ppc/translate_init.c:    env->id_tlbs = 0;
target-ppc/translate_init.c:    env->tlb_type = TLB_EMB;
target-ppc/translate_init.c:    env->dcache_line_size = 32;
target-ppc/translate_init.c:    env->icache_line_size = 32;
target-ppc/translate_init.c:    env->nb_tlb = 64;
target-ppc/translate_init.c:    env->nb_ways = 1;
target-ppc/translate_init.c:    env->id_tlbs = 0;
target-ppc/translate_init.c:    env->tlb_type = TLB_EMB;
target-ppc/translate_init.c:    env->dcache_line_size = 32;
target-ppc/translate_init.c:    env->icache_line_size = 32;
target-ppc/translate_init.c:    env->nb_tlb = 64;
target-ppc/translate_init.c:    env->nb_ways = 1;
target-ppc/translate_init.c:    env->id_tlbs = 0;
target-ppc/translate_init.c:    env->tlb_type = TLB_EMB;
target-ppc/translate_init.c:    env->dcache_line_size = 32;
target-ppc/translate_init.c:    env->icache_line_size = 32;
target-ppc/translate_init.c:    env->nb_tlb = 64;
target-ppc/translate_init.c:    env->nb_ways = 1;
target-ppc/translate_init.c:    env->id_tlbs = 0;
target-ppc/translate_init.c:    env->tlb_type = TLB_EMB;
target-ppc/translate_init.c:    env->dcache_line_size = 32;
target-ppc/translate_init.c:    env->icache_line_size = 32;
target-ppc/translate_init.c:    env->nb_tlb = 64;
target-ppc/translate_init.c:    env->nb_ways = 1;
target-ppc/translate_init.c:    env->id_tlbs = 0;
target-ppc/translate_init.c:    env->tlb_type = TLB_EMB;
target-ppc/translate_init.c:    env->dcache_line_size = 32;
target-ppc/translate_init.c:    env->icache_line_size = 32;
target-ppc/translate_init.c:    env->dcache_line_size = 32;
target-ppc/translate_init.c:    env->icache_line_size = 32;
target-ppc/translate_init.c:    env->dcache_line_size = 32;
target-ppc/translate_init.c:    env->icache_line_size = 32;
target-ppc/translate_init.c:    env->dcache_line_size = 32;
target-ppc/translate_init.c:    env->icache_line_size = 32;
target-ppc/translate_init.c:    env->dcache_line_size = 32;
target-ppc/translate_init.c:    env->icache_line_size = 32;
target-ppc/translate_init.c:    env->nb_tlb = 64;
target-ppc/translate_init.c:    env->nb_ways = 1;
target-ppc/translate_init.c:    env->id_tlbs = 0;
target-ppc/translate_init.c:    env->tlb_type = TLB_EMB;
target-ppc/translate_init.c:    env->dcache_line_size = 32;
target-ppc/translate_init.c:    env->icache_line_size = 32;
target-ppc/translate_init.c:    env->dcache_line_size = 32;
target-ppc/translate_init.c:    env->icache_line_size = 32;
target-ppc/translate_init.c:    env->nb_pids = 3;
target-ppc/translate_init.c:    env->nb_ways = 2;
target-ppc/translate_init.c:    env->id_tlbs = 0;
target-ppc/translate_init.c:        cpu_abort(env, "Unknown CPU: " TARGET_FMT_lx "\n", env->spr[SPR_PVR]);
target-ppc/translate_init.c:        env->dcache_line_size = 32;
target-ppc/translate_init.c:        env->icache_line_size = 32;
target-ppc/translate_init.c:        env->dcache_line_size = 64;
target-ppc/translate_init.c:        env->icache_line_size = 64;
target-ppc/translate_init.c:        cpu_abort(env, "Unknown CPU: " TARGET_FMT_lx "\n", env->spr[SPR_PVR]);
target-ppc/translate_init.c:    env->nb_tlb = 0;
target-ppc/translate_init.c:    env->tlb_type = TLB_MAS;
target-ppc/translate_init.c:        env->nb_tlb += booke206_tlb_size(env, i);
target-ppc/translate_init.c:    env->dcache_line_size = 32;
target-ppc/translate_init.c:    env->icache_line_size = 64;
target-ppc/translate_init.c:    env->dcache_line_size = 32;
target-ppc/translate_init.c:    env->icache_line_size = 32;
target-ppc/translate_init.c:    env->dcache_line_size = 32;
target-ppc/translate_init.c:    env->icache_line_size = 32;
target-ppc/translate_init.c:    env->dcache_line_size = 32;
target-ppc/translate_init.c:    env->icache_line_size = 32;
target-ppc/translate_init.c:    env->dcache_line_size = 32;
target-ppc/translate_init.c:    env->icache_line_size = 32;
target-ppc/translate_init.c:    env->dcache_line_size = 32;
target-ppc/translate_init.c:    env->icache_line_size = 32;
target-ppc/translate_init.c:    env->dcache_line_size = 32;
target-ppc/translate_init.c:    env->icache_line_size = 32;
target-ppc/translate_init.c:    env->dcache_line_size = 32;
target-ppc/translate_init.c:    env->icache_line_size = 32;
target-ppc/translate_init.c:    env->dcache_line_size = 32;
target-ppc/translate_init.c:    env->icache_line_size = 32;
target-ppc/translate_init.c:    env->dcache_line_size = 32;
target-ppc/translate_init.c:    env->icache_line_size = 32;
target-ppc/translate_init.c:    env->dcache_line_size = 32;
target-ppc/translate_init.c:    env->icache_line_size = 32;
target-ppc/translate_init.c:    env->dcache_line_size = 32;
target-ppc/translate_init.c:    env->icache_line_size = 32;
target-ppc/translate_init.c:    env->dcache_line_size = 32;
target-ppc/translate_init.c:    env->icache_line_size = 32;
target-ppc/translate_init.c:    env->dcache_line_size = 32;
target-ppc/translate_init.c:    env->icache_line_size = 32;
target-ppc/translate_init.c:    env->dcache_line_size = 32;
target-ppc/translate_init.c:    env->icache_line_size = 32;
target-ppc/translate_init.c:    env->dcache_line_size = 32;
target-ppc/translate_init.c:    env->icache_line_size = 32;
target-ppc/translate_init.c:    env->dcache_line_size = 32;
target-ppc/translate_init.c:    env->icache_line_size = 32;
target-ppc/translate_init.c:    env->dcache_line_size = 32;
target-ppc/translate_init.c:    env->icache_line_size = 32;
target-ppc/translate_init.c:    env->dcache_line_size = 32;
target-ppc/translate_init.c:    env->icache_line_size = 32;
target-ppc/translate_init.c:    env->dcache_line_size = 32;
target-ppc/translate_init.c:    env->icache_line_size = 32;
target-ppc/translate_init.c:    env->dcache_line_size = 32;
target-ppc/translate_init.c:    env->icache_line_size = 32;
target-ppc/translate_init.c:    if (env->spr[SPR_HID0] & 0x00600000)
target-ppc/translate_init.c:    env->slb_nr = 32;
target-ppc/translate_init.c:    env->dcache_line_size = 128;
target-ppc/translate_init.c:    env->icache_line_size = 128;
target-ppc/translate_init.c:    if (env->spr[SPR_HID0] & 0x00600000)
target-ppc/translate_init.c:    env->slb_nr = 64;
target-ppc/translate_init.c:    env->dcache_line_size = 128;
target-ppc/translate_init.c:    env->icache_line_size = 128;
target-ppc/translate_init.c:    if (env->spr[SPR_HID0] & 0x00600000)
target-ppc/translate_init.c:    env->slb_nr = 32;
target-ppc/translate_init.c:    env->dcache_line_size = 128;
target-ppc/translate_init.c:    env->icache_line_size = 128;
target-ppc/translate_init.c:    if (env->spr[SPR_HID0] & 0x01C00000)
target-ppc/translate_init.c:    env->slb_nr = 32;
target-ppc/translate_init.c:    env->dcache_line_size = 128;
target-ppc/translate_init.c:    env->icache_line_size = 128;
target-ppc/translate_init.c:    env->slb_nr = 32;
target-ppc/translate_init.c:    env->dcache_line_size = 128;
target-ppc/translate_init.c:    env->icache_line_size = 128;
target-ppc/translate_init.c:    env->dcache_line_size = 64;
target-ppc/translate_init.c:    env->icache_line_size = 64;
target-ppc/translate_init.c:    env->irq_inputs = NULL;
target-ppc/translate_init.c:        env->excp_vectors[i] = (target_ulong)(-1ULL);
target-ppc/translate_init.c:    env->hreset_excp_prefix = 0x00000000;
target-ppc/translate_init.c:    env->ivor_mask = 0x00000000;
target-ppc/translate_init.c:    env->ivpr_mask = 0x00000000;
target-ppc/translate_init.c:    env->nb_BATs = 0;
target-ppc/translate_init.c:    env->nb_tlb = 0;
target-ppc/translate_init.c:    env->nb_ways = 0;
target-ppc/translate_init.c:    env->tlb_type = TLB_NONE;
target-ppc/translate_init.c:    env->excp_prefix = env->hreset_excp_prefix;
target-ppc/translate_init.c:    if (env->msr_mask & (1 << 25)) {
target-ppc/translate_init.c:        switch (env->flags & (POWERPC_FLAG_SPE | POWERPC_FLAG_VRE)) {
target-ppc/translate_init.c:    } else if (env->flags & (POWERPC_FLAG_SPE | POWERPC_FLAG_VRE)) {
target-ppc/translate_init.c:    if (env->msr_mask & (1 << 17)) {
target-ppc/translate_init.c:        switch (env->flags & (POWERPC_FLAG_TGPR | POWERPC_FLAG_CE)) {
target-ppc/translate_init.c:    } else if (env->flags & (POWERPC_FLAG_TGPR | POWERPC_FLAG_CE)) {
target-ppc/translate_init.c:    if (env->msr_mask & (1 << 10)) {
target-ppc/translate_init.c:        switch (env->flags & (POWERPC_FLAG_SE | POWERPC_FLAG_DWE |
target-ppc/translate_init.c:    } else if (env->flags & (POWERPC_FLAG_SE | POWERPC_FLAG_DWE |
target-ppc/translate_init.c:    if (env->msr_mask & (1 << 9)) {
target-ppc/translate_init.c:        switch (env->flags & (POWERPC_FLAG_BE | POWERPC_FLAG_DE)) {
target-ppc/translate_init.c:    } else if (env->flags & (POWERPC_FLAG_BE | POWERPC_FLAG_DE)) {
target-ppc/translate_init.c:    if (env->msr_mask & (1 << 2)) {
target-ppc/translate_init.c:        switch (env->flags & (POWERPC_FLAG_PX | POWERPC_FLAG_PMM)) {
target-ppc/translate_init.c:    } else if (env->flags & (POWERPC_FLAG_PX | POWERPC_FLAG_PMM)) {
target-ppc/translate_init.c:    if ((env->flags & (POWERPC_FLAG_RTC_CLK | POWERPC_FLAG_BUS_CLK)) == 0) {
target-ppc/translate_init.c:    if (env->nb_tlb != 0) {
target-ppc/translate_init.c:        int nb_tlb = env->nb_tlb;
target-ppc/translate_init.c:        if (env->id_tlbs != 0)
target-ppc/translate_init.c:        switch (env->tlb_type) {
target-ppc/translate_init.c:            env->tlb.tlb6 = g_malloc0(nb_tlb * sizeof(ppc6xx_tlb_t));
target-ppc/translate_init.c:            env->tlb.tlbe = g_malloc0(nb_tlb * sizeof(ppcemb_tlb_t));
target-ppc/translate_init.c:            env->tlb.tlbm = g_malloc0(nb_tlb * sizeof(ppcmas_tlb_t));
target-ppc/translate_init.c:        env->tlb_per_way = env->nb_tlb / env->nb_ways;
target-ppc/translate_init.c:    if (env->irq_inputs == NULL) {
target-ppc/translate_init.c:    if (env->check_pow == NULL) {
target-ppc/translate_init.c:            spr = &env->spr_cb[n];
target-ppc/translate_init.c:    fill_new_table(env->opcodes, 0x40);
target-ppc/translate_init.c:            if (register_insn(env->opcodes, opc) < 0) {
target-ppc/translate_init.c:    fix_opcode_tables(env->opcodes);
target-ppc/translate_init.c:        table = env->opcodes;
target-ppc/translate_init.c:                table = env->opcodes;
target-ppc/translate_init.c:                handler = env->opcodes[opc1];
target-ppc/translate_init.c:        stfq_p(mem_buf, env->fpr[n]);
target-ppc/translate_init.c:        stl_p(mem_buf, env->fpscr);
target-ppc/translate_init.c:        env->fpr[n] = ldfq_p(mem_buf);
target-ppc/translate_init.c:        stq_p(mem_buf, env->avr[n].u64[0]);
target-ppc/translate_init.c:        stq_p(mem_buf+8, env->avr[n].u64[1]);
target-ppc/translate_init.c:        stq_p(mem_buf, env->avr[n].u64[1]);
target-ppc/translate_init.c:        stq_p(mem_buf+8, env->avr[n].u64[0]);
target-ppc/translate_init.c:        stl_p(mem_buf, env->vscr);
target-ppc/translate_init.c:        stl_p(mem_buf, (uint32_t)env->spr[SPR_VRSAVE]);
target-ppc/translate_init.c:        env->avr[n].u64[0] = ldq_p(mem_buf);
target-ppc/translate_init.c:        env->avr[n].u64[1] = ldq_p(mem_buf+8);
target-ppc/translate_init.c:        env->avr[n].u64[1] = ldq_p(mem_buf);
target-ppc/translate_init.c:        env->avr[n].u64[0] = ldq_p(mem_buf+8);
target-ppc/translate_init.c:        env->vscr = ldl_p(mem_buf);
target-ppc/translate_init.c:        env->spr[SPR_VRSAVE] = (target_ulong)ldl_p(mem_buf);
target-ppc/translate_init.c:        stl_p(mem_buf, env->gpr[n] >> 32);
target-ppc/translate_init.c:        stl_p(mem_buf, env->gprh[n]);
target-ppc/translate_init.c:        stq_p(mem_buf, env->spe_acc);
target-ppc/translate_init.c:        stl_p(mem_buf, env->spe_fscr);
target-ppc/translate_init.c:        target_ulong lo = (uint32_t)env->gpr[n];
target-ppc/translate_init.c:        env->gpr[n] = lo | hi;
target-ppc/translate_init.c:        env->gprh[n] = ldl_p(mem_buf);
target-ppc/translate_init.c:        env->spe_acc = ldq_p(mem_buf);
target-ppc/translate_init.c:        env->spe_fscr = ldl_p(mem_buf);
target-ppc/translate_init.c:    if ((env->insns_flags & ~PPC_TCG_INSNS)
target-ppc/translate_init.c:        || (env->insns_flags2 & ~PPC_TCG_INSNS2)) {
target-ppc/translate_init.c:                env->insns_flags & ~PPC_TCG_INSNS,
target-ppc/translate_init.c:                env->insns_flags2 & ~PPC_TCG_INSNS2);
target-ppc/translate_init.c:    env->insns_flags &= PPC_TCG_INSNS;
target-ppc/translate_init.c:    env->insns_flags2 &= PPC_TCG_INSNS2;
target-ppc/translate_init.c:    env->msr_mask = def->msr_mask;
target-ppc/translate_init.c:    env->mmu_model = def->mmu_model;
target-ppc/translate_init.c:    env->excp_model = def->excp_model;
target-ppc/translate_init.c:    env->bus_model = def->bus_model;
target-ppc/translate_init.c:    env->insns_flags = def->insns_flags;
target-ppc/translate_init.c:    env->insns_flags2 = def->insns_flags2;
target-ppc/translate_init.c:    env->flags = def->flags;
target-ppc/translate_init.c:    env->bfd_mach = def->bfd_mach;
target-ppc/translate_init.c:    env->check_pow = def->check_pow;
target-ppc/translate_init.c:        switch (env->mmu_model) {
target-ppc/translate_init.c:        switch (env->excp_model) {
target-ppc/translate_init.c:        switch (env->bus_model) {
target-ppc/translate_init.c:        if (env->tlb != NULL) {
target-ppc/translate_init.c:                   env->nb_tlb, env->id_tlbs ? "splitted" : "merged",
target-ppc/translate_init.c:                   env->nb_ways);
target-ppc/translate_init.c:        if (env->flags & POWERPC_FLAG_SPE)
target-ppc/translate_init.c:        else if (env->flags & POWERPC_FLAG_VRE)
target-ppc/translate_init.c:        if (env->flags & POWERPC_FLAG_TGPR)
target-ppc/translate_init.c:        else if (env->flags & POWERPC_FLAG_CE)
target-ppc/translate_init.c:        if (env->flags & POWERPC_FLAG_SE)
target-ppc/translate_init.c:        else if (env->flags & POWERPC_FLAG_DWE)
target-ppc/translate_init.c:        else if (env->flags & POWERPC_FLAG_UBLE)
target-ppc/translate_init.c:        if (env->flags & POWERPC_FLAG_BE)
target-ppc/translate_init.c:        else if (env->flags & POWERPC_FLAG_DE)
target-ppc/translate_init.c:        if (env->flags & POWERPC_FLAG_PX)
target-ppc/translate_init.c:        else if (env->flags & POWERPC_FLAG_PMM)
target-ppc/translate_init.c:        if (env->flags == POWERPC_FLAG_NONE)
target-ppc/translate_init.c:               env->flags & POWERPC_FLAG_RTC_CLK ? "RTC clock" : "bus clock");
target-ppc/translate_init.c:        qemu_log("CPU Reset (CPU %d)\n", env->cpu_index);
target-ppc/translate_init.c:    env->excp_prefix = env->hreset_excp_prefix;
target-ppc/translate_init.c:    env->nip = env->hreset_vector | env->excp_prefix;
target-ppc/translate_init.c:    if (env->mmu_model != POWERPC_MMU_REAL) {
target-ppc/translate_init.c:    env->msr = msr & env->msr_mask;
target-ppc/translate_init.c:    if (env->mmu_model & POWERPC_MMU_64) {
target-ppc/translate_init.c:        env->msr |= (1ULL << MSR_SF);
target-ppc/translate_init.c:    env->reserve_addr = (target_ulong)-1ULL;
target-ppc/translate_init.c:    env->pending_interrupts = 0;
target-ppc/translate_init.c:    env->exception_index = POWERPC_EXCP_NONE;
target-ppc/translate_init.c:    env->error_code = 0;
target-ppc/cpu.h:#define PPC_INPUT(env) (env->bus_model)
target-ppc/cpu.h:#define msr_sf   ((env->msr >> MSR_SF)   & 1)
target-ppc/cpu.h:#define msr_isf  ((env->msr >> MSR_ISF)  & 1)
target-ppc/cpu.h:#define msr_shv  ((env->msr >> MSR_SHV)  & 1)
target-ppc/cpu.h:#define msr_cm   ((env->msr >> MSR_CM)   & 1)
target-ppc/cpu.h:#define msr_icm  ((env->msr >> MSR_ICM)  & 1)
target-ppc/cpu.h:#define msr_thv  ((env->msr >> MSR_THV)  & 1)
target-ppc/cpu.h:#define msr_gs   ((env->msr >> MSR_GS)   & 1)
target-ppc/cpu.h:#define msr_ucle ((env->msr >> MSR_UCLE) & 1)
target-ppc/cpu.h:#define msr_vr   ((env->msr >> MSR_VR)   & 1)
target-ppc/cpu.h:#define msr_spe  ((env->msr >> MSR_SPE)  & 1)
target-ppc/cpu.h:#define msr_ap   ((env->msr >> MSR_AP)   & 1)
target-ppc/cpu.h:#define msr_sa   ((env->msr >> MSR_SA)   & 1)
target-ppc/cpu.h:#define msr_key  ((env->msr >> MSR_KEY)  & 1)
target-ppc/cpu.h:#define msr_pow  ((env->msr >> MSR_POW)  & 1)
target-ppc/cpu.h:#define msr_tgpr ((env->msr >> MSR_TGPR) & 1)
target-ppc/cpu.h:#define msr_ce   ((env->msr >> MSR_CE)   & 1)
target-ppc/cpu.h:#define msr_ile  ((env->msr >> MSR_ILE)  & 1)
target-ppc/cpu.h:#define msr_ee   ((env->msr >> MSR_EE)   & 1)
target-ppc/cpu.h:#define msr_pr   ((env->msr >> MSR_PR)   & 1)
target-ppc/cpu.h:#define msr_fp   ((env->msr >> MSR_FP)   & 1)
target-ppc/cpu.h:#define msr_me   ((env->msr >> MSR_ME)   & 1)
target-ppc/cpu.h:#define msr_fe0  ((env->msr >> MSR_FE0)  & 1)
target-ppc/cpu.h:#define msr_se   ((env->msr >> MSR_SE)   & 1)
target-ppc/cpu.h:#define msr_dwe  ((env->msr >> MSR_DWE)  & 1)
target-ppc/cpu.h:#define msr_uble ((env->msr >> MSR_UBLE) & 1)
target-ppc/cpu.h:#define msr_be   ((env->msr >> MSR_BE)   & 1)
target-ppc/cpu.h:#define msr_de   ((env->msr >> MSR_DE)   & 1)
target-ppc/cpu.h:#define msr_fe1  ((env->msr >> MSR_FE1)  & 1)
target-ppc/cpu.h:#define msr_al   ((env->msr >> MSR_AL)   & 1)
target-ppc/cpu.h:#define msr_ep   ((env->msr >> MSR_EP)   & 1)
target-ppc/cpu.h:#define msr_ir   ((env->msr >> MSR_IR)   & 1)
target-ppc/cpu.h:#define msr_dr   ((env->msr >> MSR_DR)   & 1)
target-ppc/cpu.h:#define msr_pe   ((env->msr >> MSR_PE)   & 1)
target-ppc/cpu.h:#define msr_px   ((env->msr >> MSR_PX)   & 1)
target-ppc/cpu.h:#define msr_pmm  ((env->msr >> MSR_PMM)  & 1)
target-ppc/cpu.h:#define msr_ri   ((env->msr >> MSR_RI)   & 1)
target-ppc/cpu.h:#define msr_le   ((env->msr >> MSR_LE)   & 1)
target-ppc/cpu.h:#define fpscr_fex    (((env->fpscr) >> FPSCR_FEX)    & 0x1)
target-ppc/cpu.h:#define fpscr_vx     (((env->fpscr) >> FPSCR_VX)     & 0x1)
target-ppc/cpu.h:#define fpscr_ox     (((env->fpscr) >> FPSCR_OX)     & 0x1)
target-ppc/cpu.h:#define fpscr_ux     (((env->fpscr) >> FPSCR_UX)     & 0x1)
target-ppc/cpu.h:#define fpscr_zx     (((env->fpscr) >> FPSCR_ZX)     & 0x1)
target-ppc/cpu.h:#define fpscr_xx     (((env->fpscr) >> FPSCR_XX)     & 0x1)
target-ppc/cpu.h:#define fpscr_vxsnan (((env->fpscr) >> FPSCR_VXSNAN) & 0x1)
target-ppc/cpu.h:#define fpscr_vxisi  (((env->fpscr) >> FPSCR_VXISI)  & 0x1)
target-ppc/cpu.h:#define fpscr_vxidi  (((env->fpscr) >> FPSCR_VXIDI)  & 0x1)
target-ppc/cpu.h:#define fpscr_vxzdz  (((env->fpscr) >> FPSCR_VXZDZ)  & 0x1)
target-ppc/cpu.h:#define fpscr_vximz  (((env->fpscr) >> FPSCR_VXIMZ)  & 0x1)
target-ppc/cpu.h:#define fpscr_vxvc   (((env->fpscr) >> FPSCR_VXVC)   & 0x1)
target-ppc/cpu.h:#define fpscr_fpcc   (((env->fpscr) >> FPSCR_FPCC)   & 0xF)
target-ppc/cpu.h:#define fpscr_vxsoft (((env->fpscr) >> FPSCR_VXSOFT) & 0x1)
target-ppc/cpu.h:#define fpscr_vxsqrt (((env->fpscr) >> FPSCR_VXSQRT) & 0x1)
target-ppc/cpu.h:#define fpscr_vxcvi  (((env->fpscr) >> FPSCR_VXCVI)  & 0x1)
target-ppc/cpu.h:#define fpscr_ve     (((env->fpscr) >> FPSCR_VE)     & 0x1)
target-ppc/cpu.h:#define fpscr_oe     (((env->fpscr) >> FPSCR_OE)     & 0x1)
target-ppc/cpu.h:#define fpscr_ue     (((env->fpscr) >> FPSCR_UE)     & 0x1)
target-ppc/cpu.h:#define fpscr_ze     (((env->fpscr) >> FPSCR_ZE)     & 0x1)
target-ppc/cpu.h:#define fpscr_xe     (((env->fpscr) >> FPSCR_XE)     & 0x1)
target-ppc/cpu.h:#define fpscr_ni     (((env->fpscr) >> FPSCR_NI)     & 0x1)
target-ppc/cpu.h:#define fpscr_rn     (((env->fpscr) >> FPSCR_RN)     & 0x3)
target-ppc/cpu.h:#define fpscr_ix ((env->fpscr) & ((1 << FPSCR_VXSNAN) | (1 << FPSCR_VXISI)  | \
target-ppc/cpu.h:#define fpscr_ex  (((env->fpscr) >> FPSCR_XX) & 0x1F)
target-ppc/cpu.h:#define fpscr_eex (((env->fpscr) >> FPSCR_XX) & ((env->fpscr) >> FPSCR_XE) &  \
target-ppc/cpu.h:#define vscr_nj		(((env->vscr) >> VSCR_NJ)	& 0x1)
target-ppc/cpu.h:#define vscr_sat	(((env->vscr) >> VSCR_SAT)	& 0x1)
target-ppc/cpu.h:    env->fit_period[0] = (a_);                  \
target-ppc/cpu.h:    env->fit_period[1] = (b_);                  \
target-ppc/cpu.h:    env->fit_period[2] = (c_);                  \
target-ppc/cpu.h:    env->fit_period[3] = (d_);                  \
target-ppc/cpu.h:    env->wdt_period[0] = (a_);                  \
target-ppc/cpu.h:    env->wdt_period[1] = (b_);                  \
target-ppc/cpu.h:    env->wdt_period[2] = (c_);                  \
target-ppc/cpu.h:    env->wdt_period[3] = (d_);                  \
target-ppc/cpu.h:    gprv = env->gpr[gprn];
target-ppc/cpu.h:    if (env->flags & POWERPC_FLAG_SPE) {
target-ppc/cpu.h:        gprv |= (uint64_t)env->gprh[gprn] << 32;
target-ppc/cpu.h:    return env->mmu_idx;
target-ppc/cpu.h:        env->gpr[1] = newsp;
target-ppc/cpu.h:    env->gpr[3] = 0;
target-ppc/cpu.h:#define xer_so  ((env->xer >> XER_SO)  &    1)
target-ppc/cpu.h:#define xer_ov  ((env->xer >> XER_OV)  &    1)
target-ppc/cpu.h:#define xer_ca  ((env->xer >> XER_CA)  &    1)
target-ppc/cpu.h:#define xer_cmp ((env->xer >> XER_CMP) & 0xFF)
target-ppc/cpu.h:#define xer_bc  ((env->xer >> XER_BC)  & 0x7F)
target-ppc/cpu.h:    *pc = env->nip;
target-ppc/cpu.h:    *flags = env->hflags;
target-ppc/cpu.h:    env->gpr[13] = newtls;
target-ppc/cpu.h:    env->gpr[2] = newtls;
target-ppc/cpu.h:    uintptr_t tlbl = (uintptr_t)env->tlb.tlbm;
target-ppc/cpu.h:    return (tlbml - tlbl) / sizeof(env->tlb.tlbm[0]);
target-ppc/cpu.h:    uint32_t tlbncfg = env->spr[SPR_BOOKE_TLB0CFG + tlbn];
target-ppc/cpu.h:    uint32_t tlbncfg = env->spr[SPR_BOOKE_TLB0CFG + tlbn];
target-ppc/cpu.h:    return &env->tlb.tlbm[r];
target-ppc/cpu.h:        ret = env->spr[SPR_BOOKE_TLB0PS + tlbn];
target-ppc/cpu.h:        uint32_t tlbncfg = env->spr[SPR_BOOKE_TLB0CFG + tlbn];
target-ppc/cpu.h:    return msr_ee && (env->interrupt_request & CPU_INTERRUPT_HARD);
target-ppc/cpu.h:    env->nip = tb->pc;
target-ppc/helper.c:        env->spr[SPR_DAR] = address;
target-ppc/helper.c:        env->spr[SPR_DSISR] = error_code;
target-ppc/helper.c:    env->exception_index = exception;
target-ppc/helper.c:    env->error_code = error_code;
target-ppc/helper.c:    nr = (eaddr >> TARGET_PAGE_BITS) & (env->tlb_per_way - 1);
target-ppc/helper.c:    nr += env->tlb_per_way * way;
target-ppc/helper.c:    if (is_code && env->id_tlbs == 1)
target-ppc/helper.c:        nr += env->nb_tlb;
target-ppc/helper.c:    max = env->nb_tlb;
target-ppc/helper.c:    if (env->id_tlbs == 1)
target-ppc/helper.c:        tlb = &env->tlb.tlb6[nr];
target-ppc/helper.c:    for (way = 0; way < env->nb_ways; way++) {
target-ppc/helper.c:        tlb = &env->tlb.tlb6[nr];
target-ppc/helper.c:                      env->nb_tlb, eaddr);
target-ppc/helper.c:    tlb = &env->tlb.tlb6[nr];
target-ppc/helper.c:              " PTE1 " TARGET_FMT_lx "\n", nr, env->nb_tlb, EPN, pte0, pte1);
target-ppc/helper.c:    env->last_way = way;
target-ppc/helper.c:    for (way = 0; way < env->nb_ways; way++) {
target-ppc/helper.c:        tlb = &env->tlb.tlb6[nr];
target-ppc/helper.c:                      "] <> " TARGET_FMT_lx "\n", nr, env->nb_tlb,
target-ppc/helper.c:                  TARGET_FMT_lx " %c %c\n", nr, env->nb_tlb,
target-ppc/helper.c:        pte_update_flags(ctx, &env->tlb.tlb6[best].pte1, ret, rw);
target-ppc/helper.c:        BATlt = env->IBAT[1];
target-ppc/helper.c:        BATut = env->IBAT[0];
target-ppc/helper.c:        BATlt = env->DBAT[1];
target-ppc/helper.c:        BATut = env->DBAT[0];
target-ppc/helper.c:    for (i = 0; i < env->nb_BATs; i++) {
target-ppc/helper.c:        if (unlikely(env->mmu_model == POWERPC_MMU_601)) {
target-ppc/helper.c:    return (hash * pte_size * 8) & env->htab_mask;
target-ppc/helper.c:            if (env->external_htab) {
target-ppc/helper.c:                pte0 = ldq_p(env->external_htab + pteg_off + (i * 16));
target-ppc/helper.c:                pte1 = ldq_p(env->external_htab + pteg_off + (i * 16) + 8);
target-ppc/helper.c:                pte0 = ldq_phys(env->htab_base + pteg_off + (i * 16));
target-ppc/helper.c:                pte1 = ldq_phys(env->htab_base + pteg_off + (i * 16) + 8);
target-ppc/helper.c:            if (env->external_htab) {
target-ppc/helper.c:                pte0 = ldl_p(env->external_htab + pteg_off + (i * 8));
target-ppc/helper.c:                pte1 = ldl_p(env->external_htab + pteg_off + (i * 8) + 4);
target-ppc/helper.c:                pte0 = ldl_phys(env->htab_base + pteg_off + (i * 8));
target-ppc/helper.c:                pte1 = ldl_phys(env->htab_base + pteg_off + (i * 8) + 4);
target-ppc/helper.c:                if (env->external_htab) {
target-ppc/helper.c:                    stq_p(env->external_htab + pteg_off + (good * 16) + 8,
target-ppc/helper.c:                    stq_phys_notdirty(env->htab_base + pteg_off +
target-ppc/helper.c:                if (env->external_htab) {
target-ppc/helper.c:                    stl_p(env->external_htab + pteg_off + (good * 8) + 4,
target-ppc/helper.c:                    stl_phys_notdirty(env->htab_base + pteg_off +
target-ppc/helper.c:    if (env->mmu_model & POWERPC_MMU_64)
target-ppc/helper.c:    for (n = 0; n < env->slb_nr; n++) {
target-ppc/helper.c:        ppc_slb_t *slb = &env->slb[n];
target-ppc/helper.c:    for (n = 1; n < env->slb_nr; n++) {
target-ppc/helper.c:        ppc_slb_t *slb = &env->slb[n];
target-ppc/helper.c:    ppc_slb_t *slb = &env->slb[slot];
target-ppc/helper.c:    if (rb & (0x1000 - env->slb_nr)) {
target-ppc/helper.c:    if ((rs & SLB_VSID_B) && !(env->mmu_model & POWERPC_MMU_1TSEG)) {
target-ppc/helper.c:    ppc_slb_t *slb = &env->slb[slot];
target-ppc/helper.c:    if (slot >= env->slb_nr) {
target-ppc/helper.c:    ppc_slb_t *slb = &env->slb[slot];
target-ppc/helper.c:    if (slot >= env->slb_nr) {
target-ppc/helper.c:    if (env->mmu_model & POWERPC_MMU_64) {
target-ppc/helper.c:        sr = env->sr[eaddr >> 28];
target-ppc/helper.c:                eaddr, (int)(eaddr >> 28), sr, env->nip, env->lr, (int)msr_ir,
target-ppc/helper.c:                    env->htab_base, env->htab_mask, hash);
target-ppc/helper.c:            if (unlikely(env->mmu_model == POWERPC_MMU_SOFT_6xx ||
target-ppc/helper.c:                         env->mmu_model == POWERPC_MMU_SOFT_74xx)) {
target-ppc/helper.c:                        env->htab_base, env->htab_mask, vsid, ctx->ptem,
target-ppc/helper.c:                                " hash=" TARGET_FMT_plx "\n", env->htab_base,
target-ppc/helper.c:                                env->htab_mask, vsid, ctx->ptem, ctx->hash[1]);
target-ppc/helper.c:        sr = env->sr[eaddr >> 28];
target-ppc/helper.c:    for (i = 0; i < env->nb_tlb; i++) {
target-ppc/helper.c:        tlb = &env->tlb.tlbe[i];
target-ppc/helper.c:    for (i = 0; i < env->nb_tlb; i++) {
target-ppc/helper.c:        tlb = &env->tlb.tlbe[i];
target-ppc/helper.c:    for (i = 0; i < env->nb_tlb; i++) {
target-ppc/helper.c:        tlb = &env->tlb.tlbe[i];
target-ppc/helper.c:    for (i = 0; i < env->nb_tlb; i++) {
target-ppc/helper.c:        tlb = &env->tlb.tlbe[i];
target-ppc/helper.c:                             env->spr[SPR_40x_PID], 0, i) < 0)
target-ppc/helper.c:        zpr = (env->spr[SPR_40x_ZPR] >> (30 - (2 * zsel))) & 0x3;
target-ppc/helper.c:                env->spr[SPR_40x_ESR] = 1 << 22;
target-ppc/helper.c:                env->spr[SPR_40x_ESR] = 0;
target-ppc/helper.c:    env->spr[SPR_405_SLER] = val;
target-ppc/helper.c:                         env->spr[SPR_BOOKE_PID],
target-ppc/helper.c:                         !env->nb_pids, i) >= 0) {
target-ppc/helper.c:    if (env->spr[SPR_BOOKE_PID1] &&
target-ppc/helper.c:                         env->spr[SPR_BOOKE_PID1], 0, i) >= 0) {
target-ppc/helper.c:    if (env->spr[SPR_BOOKE_PID2] &&
target-ppc/helper.c:                         env->spr[SPR_BOOKE_PID2], 0, i) >= 0) {
target-ppc/helper.c:    for (i = 0; i < env->nb_tlb; i++) {
target-ppc/helper.c:        tlb = &env->tlb.tlbe[i];
target-ppc/helper.c:    ppcmas_tlb_t *tlb = env->tlb.tlbm;
target-ppc/helper.c:                         env->spr[SPR_BOOKE_PID]) >= 0) {
target-ppc/helper.c:    if (env->spr[SPR_BOOKE_PID1] &&
target-ppc/helper.c:                         env->spr[SPR_BOOKE_PID1]) >= 0) {
target-ppc/helper.c:    if (env->spr[SPR_BOOKE_PID2] &&
target-ppc/helper.c:                         env->spr[SPR_BOOKE_PID2]) >= 0) {
target-ppc/helper.c:    if (kvm_enabled() && !env->kvm_sw_tlb) {
target-ppc/helper.c:    entry = &env->tlb.tlbe[0];
target-ppc/helper.c:    for (i = 0; i < env->nb_tlb; i++, entry++) {
target-ppc/helper.c:    entry = &env->tlb.tlbm[offset];
target-ppc/helper.c:    if (kvm_enabled() && !env->kvm_sw_tlb) {
target-ppc/helper.c:    for (i = 0; i < env->slb_nr; i++) {
target-ppc/helper.c:        slbe = env->slb[i].esid;
target-ppc/helper.c:        slbv = env->slb[i].vsid;
target-ppc/helper.c:    switch (env->mmu_model) {
target-ppc/helper.c:    switch (env->mmu_model) {
target-ppc/helper.c:                (env->pb[0] < env->pb[1] &&
target-ppc/helper.c:                 eaddr >= env->pb[0] && eaddr < env->pb[1]) ||
target-ppc/helper.c:                (env->pb[2] < env->pb[3] &&
target-ppc/helper.c:                 eaddr >= env->pb[2] && eaddr < env->pb[3]) ? 1 : 0;
target-ppc/helper.c:        if (env->mmu_model == POWERPC_MMU_BOOKE) {
target-ppc/helper.c:        } else if (env->mmu_model == POWERPC_MMU_BOOKE206) {
target-ppc/helper.c:        switch (env->mmu_model) {
target-ppc/helper.c:            if (env->nb_BATs != 0)
target-ppc/helper.c:    env->spr[SPR_BOOKE_MAS0] = env->spr[SPR_BOOKE_MAS4] & MAS4_TLBSELD_MASK;
target-ppc/helper.c:    env->spr[SPR_BOOKE_MAS1] = env->spr[SPR_BOOKE_MAS4] & MAS4_TSIZED_MASK;
target-ppc/helper.c:    env->spr[SPR_BOOKE_MAS2] = env->spr[SPR_BOOKE_MAS4] & MAS4_WIMGED_MASK;
target-ppc/helper.c:    env->spr[SPR_BOOKE_MAS3] = 0;
target-ppc/helper.c:    env->spr[SPR_BOOKE_MAS6] = 0;
target-ppc/helper.c:    env->spr[SPR_BOOKE_MAS7] = 0;
target-ppc/helper.c:        env->spr[SPR_BOOKE_MAS1] |= MAS1_TS;
target-ppc/helper.c:        env->spr[SPR_BOOKE_MAS6] |= MAS6_SAS;
target-ppc/helper.c:    env->spr[SPR_BOOKE_MAS1] |= MAS1_VALID;
target-ppc/helper.c:    env->spr[SPR_BOOKE_MAS2] |= address & MAS2_EPN_MASK;
target-ppc/helper.c:    switch (env->spr[SPR_BOOKE_MAS4] & MAS4_TIDSELD_PIDZ) {
target-ppc/helper.c:        env->spr[SPR_BOOKE_MAS1] |= env->spr[SPR_BOOKE_PID] << MAS1_TID_SHIFT;
target-ppc/helper.c:        env->spr[SPR_BOOKE_MAS1] |= env->spr[SPR_BOOKE_PID1] << MAS1_TID_SHIFT;
target-ppc/helper.c:        env->spr[SPR_BOOKE_MAS1] |= env->spr[SPR_BOOKE_PID2] << MAS1_TID_SHIFT;
target-ppc/helper.c:    env->spr[SPR_BOOKE_MAS6] |= env->spr[SPR_BOOKE_PID] << 16;
target-ppc/helper.c:    env->spr[SPR_BOOKE_MAS0] |= env->last_way << MAS0_ESEL_SHIFT;
target-ppc/helper.c:    env->last_way++;
target-ppc/helper.c:    env->last_way &= booke206_tlb_ways(env, 0) - 1;
target-ppc/helper.c:    env->spr[SPR_BOOKE_MAS0] |= env->last_way << MAS0_NV_SHIFT;
target-ppc/helper.c:        access_type = env->access_type;
target-ppc/helper.c:                switch (env->mmu_model) {
target-ppc/helper.c:                    env->exception_index = POWERPC_EXCP_IFTLB;
target-ppc/helper.c:                    env->error_code = 1 << 18;
target-ppc/helper.c:                    env->spr[SPR_IMISS] = address;
target-ppc/helper.c:                    env->spr[SPR_ICMP] = 0x80000000 | ctx.ptem;
target-ppc/helper.c:                    env->exception_index = POWERPC_EXCP_IFTLB;
target-ppc/helper.c:                    env->exception_index = POWERPC_EXCP_ITLB;
target-ppc/helper.c:                    env->error_code = 0;
target-ppc/helper.c:                    env->spr[SPR_40x_DEAR] = address;
target-ppc/helper.c:                    env->spr[SPR_40x_ESR] = 0x00000000;
target-ppc/helper.c:                    env->exception_index = POWERPC_EXCP_ISI;
target-ppc/helper.c:                    env->error_code = 0x40000000;
target-ppc/helper.c:                    env->exception_index = POWERPC_EXCP_ITLB;
target-ppc/helper.c:                    env->error_code = 0;
target-ppc/helper.c:                    env->spr[SPR_BOOKE_DEAR] = address;
target-ppc/helper.c:                env->exception_index = POWERPC_EXCP_ISI;
target-ppc/helper.c:                env->error_code = 0x08000000;
target-ppc/helper.c:                if ((env->mmu_model == POWERPC_MMU_BOOKE) ||
target-ppc/helper.c:                    (env->mmu_model == POWERPC_MMU_BOOKE206)) {
target-ppc/helper.c:                    env->spr[SPR_BOOKE_ESR] = 0x00000000;
target-ppc/helper.c:                env->exception_index = POWERPC_EXCP_ISI;
target-ppc/helper.c:                env->error_code = 0x10000000;
target-ppc/helper.c:                env->exception_index = POWERPC_EXCP_ISI;
target-ppc/helper.c:                env->error_code = 0x10000000;
target-ppc/helper.c:                if (env->mmu_model == POWERPC_MMU_620) {
target-ppc/helper.c:                    env->exception_index = POWERPC_EXCP_ISI;
target-ppc/helper.c:                    env->error_code = 0x40000000;
target-ppc/helper.c:                    env->exception_index = POWERPC_EXCP_ISEG;
target-ppc/helper.c:                    env->error_code = 0;
target-ppc/helper.c:                switch (env->mmu_model) {
target-ppc/helper.c:                        env->exception_index = POWERPC_EXCP_DSTLB;
target-ppc/helper.c:                        env->error_code = 1 << 16;
target-ppc/helper.c:                        env->exception_index = POWERPC_EXCP_DLTLB;
target-ppc/helper.c:                        env->error_code = 0;
target-ppc/helper.c:                    env->spr[SPR_DMISS] = address;
target-ppc/helper.c:                    env->spr[SPR_DCMP] = 0x80000000 | ctx.ptem;
target-ppc/helper.c:                    env->error_code |= ctx.key << 19;
target-ppc/helper.c:                    env->spr[SPR_HASH1] = env->htab_base +
target-ppc/helper.c:                    env->spr[SPR_HASH2] = env->htab_base +
target-ppc/helper.c:                        env->exception_index = POWERPC_EXCP_DSTLB;
target-ppc/helper.c:                        env->exception_index = POWERPC_EXCP_DLTLB;
target-ppc/helper.c:                    env->error_code = ctx.key << 19;
target-ppc/helper.c:                    env->spr[SPR_TLBMISS] = (address & ~((target_ulong)0x3)) |
target-ppc/helper.c:                        ((env->last_way + 1) & (env->nb_ways - 1));
target-ppc/helper.c:                    env->spr[SPR_PTEHI] = 0x80000000 | ctx.ptem;
target-ppc/helper.c:                    env->exception_index = POWERPC_EXCP_DTLB;
target-ppc/helper.c:                    env->error_code = 0;
target-ppc/helper.c:                    env->spr[SPR_40x_DEAR] = address;
target-ppc/helper.c:                        env->spr[SPR_40x_ESR] = 0x00800000;
target-ppc/helper.c:                        env->spr[SPR_40x_ESR] = 0x00000000;
target-ppc/helper.c:                    env->exception_index = POWERPC_EXCP_DSI;
target-ppc/helper.c:                    env->error_code = 0;
target-ppc/helper.c:                    env->spr[SPR_DAR] = address;
target-ppc/helper.c:                        env->spr[SPR_DSISR] = 0x42000000;
target-ppc/helper.c:                        env->spr[SPR_DSISR] = 0x40000000;
target-ppc/helper.c:                    env->exception_index = POWERPC_EXCP_DTLB;
target-ppc/helper.c:                    env->error_code = 0;
target-ppc/helper.c:                    env->spr[SPR_BOOKE_DEAR] = address;
target-ppc/helper.c:                    env->spr[SPR_BOOKE_ESR] = rw ? ESR_ST : 0;
target-ppc/helper.c:                env->exception_index = POWERPC_EXCP_DSI;
target-ppc/helper.c:                env->error_code = 0;
target-ppc/helper.c:                if (env->mmu_model == POWERPC_MMU_SOFT_4xx
target-ppc/helper.c:                    || env->mmu_model == POWERPC_MMU_SOFT_4xx_Z) {
target-ppc/helper.c:                    env->spr[SPR_40x_DEAR] = address;
target-ppc/helper.c:                        env->spr[SPR_40x_ESR] |= 0x00800000;
target-ppc/helper.c:                } else if ((env->mmu_model == POWERPC_MMU_BOOKE) ||
target-ppc/helper.c:                           (env->mmu_model == POWERPC_MMU_BOOKE206)) {
target-ppc/helper.c:                    env->spr[SPR_BOOKE_DEAR] = address;
target-ppc/helper.c:                    env->spr[SPR_BOOKE_ESR] = rw ? ESR_ST : 0;
target-ppc/helper.c:                    env->spr[SPR_DAR] = address;
target-ppc/helper.c:                        env->spr[SPR_DSISR] = 0x0A000000;
target-ppc/helper.c:                        env->spr[SPR_DSISR] = 0x08000000;
target-ppc/helper.c:                    env->exception_index = POWERPC_EXCP_ALIGN;
target-ppc/helper.c:                    env->error_code = POWERPC_EXCP_ALIGN_FP;
target-ppc/helper.c:                    env->spr[SPR_DAR] = address;
target-ppc/helper.c:                    env->exception_index = POWERPC_EXCP_DSI;
target-ppc/helper.c:                    env->error_code = 0;
target-ppc/helper.c:                    env->spr[SPR_DAR] = address;
target-ppc/helper.c:                        env->spr[SPR_DSISR] = 0x06000000;
target-ppc/helper.c:                        env->spr[SPR_DSISR] = 0x04000000;
target-ppc/helper.c:                    env->exception_index = POWERPC_EXCP_DSI;
target-ppc/helper.c:                    env->error_code = 0;
target-ppc/helper.c:                    env->spr[SPR_DAR] = address;
target-ppc/helper.c:                        env->spr[SPR_DSISR] = 0x06100000;
target-ppc/helper.c:                        env->spr[SPR_DSISR] = 0x04100000;
target-ppc/helper.c:                    env->exception_index = POWERPC_EXCP_PROGRAM;
target-ppc/helper.c:                    env->error_code =
target-ppc/helper.c:                    env->spr[SPR_DAR] = address;
target-ppc/helper.c:                if (env->mmu_model == POWERPC_MMU_620) {
target-ppc/helper.c:                    env->exception_index = POWERPC_EXCP_DSI;
target-ppc/helper.c:                    env->error_code = 0;
target-ppc/helper.c:                    env->spr[SPR_DAR] = address;
target-ppc/helper.c:                        env->spr[SPR_DSISR] = 0x42000000;
target-ppc/helper.c:                        env->spr[SPR_DSISR] = 0x40000000;
target-ppc/helper.c:                    env->exception_index = POWERPC_EXCP_DSEG;
target-ppc/helper.c:                    env->error_code = 0;
target-ppc/helper.c:                    env->spr[SPR_DAR] = address;
target-ppc/helper.c:               env->exception, env->error_code);
target-ppc/helper.c:             nr, ul == 0 ? 'u' : 'l', value, env->nip);
target-ppc/helper.c:    if (env->IBAT[0][nr] != value) {
target-ppc/helper.c:        do_invalidate_BAT(env, env->IBAT[0][nr], mask);
target-ppc/helper.c:        env->IBAT[0][nr] = (value & 0x00001FFFUL) |
target-ppc/helper.c:        env->IBAT[1][nr] = (env->IBAT[1][nr] & 0x0000007B) |
target-ppc/helper.c:            (env->IBAT[1][nr] & ~0x0001FFFF & ~mask);
target-ppc/helper.c:        do_invalidate_BAT(env, env->IBAT[0][nr], mask);
target-ppc/helper.c:    env->IBAT[1][nr] = value;
target-ppc/helper.c:    if (env->DBAT[0][nr] != value) {
target-ppc/helper.c:        do_invalidate_BAT(env, env->DBAT[0][nr], mask);
target-ppc/helper.c:        env->DBAT[0][nr] = (value & 0x00001FFFUL) |
target-ppc/helper.c:        env->DBAT[1][nr] = (env->DBAT[1][nr] & 0x0000007B) |
target-ppc/helper.c:            (env->DBAT[1][nr] & ~0x0001FFFF & ~mask);
target-ppc/helper.c:        do_invalidate_BAT(env, env->DBAT[0][nr], mask);
target-ppc/helper.c:    env->DBAT[1][nr] = value;
target-ppc/helper.c:    if (env->IBAT[0][nr] != value) {
target-ppc/helper.c:        mask = (env->IBAT[1][nr] << 17) & 0x0FFE0000UL;
target-ppc/helper.c:        if (env->IBAT[1][nr] & 0x40) {
target-ppc/helper.c:            do_invalidate_BAT(env, env->IBAT[0][nr], mask);
target-ppc/helper.c:        env->IBAT[0][nr] = (value & 0x00001FFFUL) |
target-ppc/helper.c:        env->DBAT[0][nr] = env->IBAT[0][nr];
target-ppc/helper.c:        if (env->IBAT[1][nr] & 0x40) {
target-ppc/helper.c:            do_invalidate_BAT(env, env->IBAT[0][nr], mask);
target-ppc/helper.c:    if (env->IBAT[1][nr] != value) {
target-ppc/helper.c:        if (env->IBAT[1][nr] & 0x40) {
target-ppc/helper.c:            mask = (env->IBAT[1][nr] << 17) & 0x0FFE0000UL;
target-ppc/helper.c:            do_invalidate_BAT(env, env->IBAT[0][nr], mask);
target-ppc/helper.c:            do_invalidate_BAT(env, env->IBAT[0][nr], mask);
target-ppc/helper.c:        env->IBAT[1][nr] = value;
target-ppc/helper.c:        env->DBAT[1][nr] = value;
target-ppc/helper.c:    switch (env->mmu_model) {
target-ppc/helper.c:    switch (env->mmu_model) {
target-ppc/helper.c:        if (env->id_tlbs == 1)
target-ppc/helper.c:        ppc4xx_tlb_invalidate_virt(env, addr, env->spr[SPR_40x_PID]);
target-ppc/helper.c:    if (env->asr != value) {
target-ppc/helper.c:        env->asr = value;
target-ppc/helper.c:    if (env->spr[SPR_SDR1] != value) {
target-ppc/helper.c:        env->spr[SPR_SDR1] = value;
target-ppc/helper.c:        if (env->mmu_model & POWERPC_MMU_64) {
target-ppc/helper.c:            env->htab_mask = (1ULL << (htabsize + 18)) - 1;
target-ppc/helper.c:            env->htab_base = value & SDR_64_HTABORG;
target-ppc/helper.c:            env->htab_mask = ((value & SDR_32_HTABMASK) << 16) | 0xFFFF;
target-ppc/helper.c:            env->htab_base = value & SDR_32_HTABORG;
target-ppc/helper.c:            srnum, value, env->sr[srnum]);
target-ppc/helper.c:    if (env->mmu_model & POWERPC_MMU_64) {
target-ppc/helper.c:    if (env->sr[srnum] != value) {
target-ppc/helper.c:        env->sr[srnum] = value;
target-ppc/helper.c:    env->exception_index = POWERPC_EXCP_NONE;
target-ppc/helper.c:    env->error_code = 0;
target-ppc/helper.c:    env->exception_index = POWERPC_EXCP_NONE;
target-ppc/helper.c:    env->error_code = 0;
target-ppc/helper.c:                  ppc_dump_gpr(env, 6), env->nip);
target-ppc/helper.c:        lpes0 = (env->spr[SPR_LPCR] >> 1) & 1;
target-ppc/helper.c:        lpes1 = (env->spr[SPR_LPCR] >> 2) & 1;
target-ppc/helper.c:                  " => %08x (%02x)\n", env->nip, excp, env->error_code);
target-ppc/helper.c:    msr = env->msr & ~0x783f0000ULL;
target-ppc/helper.c:    new_msr = env->msr & ((target_ulong)1 << MSR_ME);
target-ppc/helper.c:            env->halted = 1;
target-ppc/helper.c:            env->interrupt_request |= CPU_INTERRUPT_EXITTB;
target-ppc/helper.c:                 "\n", env->spr[SPR_DSISR], env->spr[SPR_DAR]);
target-ppc/helper.c:                 "\n", msr, env->nip);
target-ppc/helper.c:        msr |= env->error_code;
target-ppc/helper.c:        env->spr[SPR_DSISR] |= (ldl_code((env->nip - 4)) & 0x03FF0000) >> 16;
target-ppc/helper.c:        switch (env->error_code & ~0xF) {
target-ppc/helper.c:                env->exception_index = POWERPC_EXCP_NONE;
target-ppc/helper.c:                env->error_code = 0;
target-ppc/helper.c:            LOG_EXCP("Invalid instruction at " TARGET_FMT_lx "\n", env->nip);
target-ppc/helper.c:            env->spr[SPR_BOOKE_ESR] = ESR_PIL;
target-ppc/helper.c:            env->spr[SPR_BOOKE_ESR] = ESR_PPR;
target-ppc/helper.c:            env->spr[SPR_BOOKE_ESR] = ESR_PTR;
target-ppc/helper.c:                      env->error_code);
target-ppc/helper.c:        lev = env->error_code;
target-ppc/helper.c:        env->spr[SPR_BOOKE_ESR] = ESR_SPV;
target-ppc/helper.c:        env->spr[SPR_BOOKE_ESR] = ESR_SPV;
target-ppc/helper.c:        env->spr[SPR_BOOKE_ESR] = ESR_SPV;
target-ppc/helper.c:        new_msr |= env->msr & ((target_ulong)1 << MSR_RI);
target-ppc/helper.c:        new_msr |= env->msr & ((target_ulong)1 << MSR_RI);
target-ppc/helper.c:        new_msr |= env->msr & ((target_ulong)1 << MSR_RI);
target-ppc/helper.c:        new_msr |= env->msr & ((target_ulong)1 << MSR_RI);
target-ppc/helper.c:        new_msr |= env->msr & ((target_ulong)1 << MSR_RI);
target-ppc/helper.c:                    miss = &env->spr[SPR_IMISS];
target-ppc/helper.c:                    cmp = &env->spr[SPR_ICMP];
target-ppc/helper.c:                    miss = &env->spr[SPR_DMISS];
target-ppc/helper.c:                    cmp = &env->spr[SPR_DCMP];
target-ppc/helper.c:                         env->spr[SPR_HASH1], env->spr[SPR_HASH2],
target-ppc/helper.c:                         env->error_code);
target-ppc/helper.c:            msr |= env->crf[0] << 28;
target-ppc/helper.c:            msr |= env->error_code; /* key, D/I, S/L bits */
target-ppc/helper.c:            msr |= ((env->last_way + 1) & (env->nb_ways - 1)) << 17;
target-ppc/helper.c:                    miss = &env->spr[SPR_TLBMISS];
target-ppc/helper.c:                    cmp = &env->spr[SPR_PTEHI];
target-ppc/helper.c:                    miss = &env->spr[SPR_TLBMISS];
target-ppc/helper.c:                    cmp = &env->spr[SPR_PTEHI];
target-ppc/helper.c:                         env->error_code);
target-ppc/helper.c:            msr |= env->error_code; /* key bit */
target-ppc/helper.c:        env->spr[srr0] = env->nip - 4;
target-ppc/helper.c:        env->spr[srr0] = env->nip;
target-ppc/helper.c:    env->spr[srr1] = msr;
target-ppc/helper.c:        env->spr[asrr0] = env->spr[srr0];
target-ppc/helper.c:        env->spr[asrr1] = env->spr[srr1];
target-ppc/helper.c:    vector = env->excp_vectors[excp];
target-ppc/helper.c:    vector |= env->excp_prefix;
target-ppc/helper.c:        if (!msr_isf && !(env->mmu_model & POWERPC_MMU_64)) {
target-ppc/helper.c:    env->msr = new_msr & env->msr_mask;
target-ppc/helper.c:    env->nip = vector;
target-ppc/helper.c:    env->exception_index = POWERPC_EXCP_NONE;
target-ppc/helper.c:    env->error_code = 0;
target-ppc/helper.c:    if ((env->mmu_model == POWERPC_MMU_BOOKE) ||
target-ppc/helper.c:        (env->mmu_model == POWERPC_MMU_BOOKE206)) {
target-ppc/helper.c:    powerpc_excp(env, env->excp_model, env->exception_index);
target-ppc/helper.c:                __func__, env, env->pending_interrupts,
target-ppc/helper.c:                env->interrupt_request, (int)msr_me, (int)msr_ee);
target-ppc/helper.c:    if (env->pending_interrupts & (1 << PPC_INTERRUPT_RESET)) {
target-ppc/helper.c:        env->pending_interrupts &= ~(1 << PPC_INTERRUPT_RESET);
target-ppc/helper.c:        powerpc_excp(env, env->excp_model, POWERPC_EXCP_RESET);
target-ppc/helper.c:    if (env->pending_interrupts & (1 << PPC_INTERRUPT_MCK)) {
target-ppc/helper.c:        env->pending_interrupts &= ~(1 << PPC_INTERRUPT_MCK);
target-ppc/helper.c:        powerpc_excp(env, env->excp_model, POWERPC_EXCP_MCHECK);
target-ppc/helper.c:    if (env->pending_interrupts & (1 << PPC_INTERRUPT_DEBUG)) {
target-ppc/helper.c:        env->pending_interrupts &= ~(1 << PPC_INTERRUPT_DEBUG);
target-ppc/helper.c:        powerpc_excp(env, env->excp_model, POWERPC_EXCP_DEBUG);
target-ppc/helper.c:        hdice = env->spr[SPR_LPCR] & 1;
target-ppc/helper.c:        if (env->pending_interrupts & (1 << PPC_INTERRUPT_HDECR)) {
target-ppc/helper.c:            env->pending_interrupts &= ~(1 << PPC_INTERRUPT_HDECR);
target-ppc/helper.c:            powerpc_excp(env, env->excp_model, POWERPC_EXCP_HDECR);
target-ppc/helper.c:        if (env->pending_interrupts & (1 << PPC_INTERRUPT_CEXT)) {
target-ppc/helper.c:            env->pending_interrupts &= ~(1 << PPC_INTERRUPT_CEXT);
target-ppc/helper.c:            powerpc_excp(env, env->excp_model, POWERPC_EXCP_CRITICAL);
target-ppc/helper.c:        if (env->pending_interrupts & (1 << PPC_INTERRUPT_WDT)) {
target-ppc/helper.c:            env->pending_interrupts &= ~(1 << PPC_INTERRUPT_WDT);
target-ppc/helper.c:            powerpc_excp(env, env->excp_model, POWERPC_EXCP_WDT);
target-ppc/helper.c:        if (env->pending_interrupts & (1 << PPC_INTERRUPT_CDOORBELL)) {
target-ppc/helper.c:            env->pending_interrupts &= ~(1 << PPC_INTERRUPT_CDOORBELL);
target-ppc/helper.c:            powerpc_excp(env, env->excp_model, POWERPC_EXCP_DOORCI);
target-ppc/helper.c:        if (env->pending_interrupts & (1 << PPC_INTERRUPT_FIT)) {
target-ppc/helper.c:            env->pending_interrupts &= ~(1 << PPC_INTERRUPT_FIT);
target-ppc/helper.c:            powerpc_excp(env, env->excp_model, POWERPC_EXCP_FIT);
target-ppc/helper.c:        if (env->pending_interrupts & (1 << PPC_INTERRUPT_PIT)) {
target-ppc/helper.c:            env->pending_interrupts &= ~(1 << PPC_INTERRUPT_PIT);
target-ppc/helper.c:            powerpc_excp(env, env->excp_model, POWERPC_EXCP_PIT);
target-ppc/helper.c:        if (env->pending_interrupts & (1 << PPC_INTERRUPT_DECR)) {
target-ppc/helper.c:            env->pending_interrupts &= ~(1 << PPC_INTERRUPT_DECR);
target-ppc/helper.c:            powerpc_excp(env, env->excp_model, POWERPC_EXCP_DECR);
target-ppc/helper.c:        if (env->pending_interrupts & (1 << PPC_INTERRUPT_EXT)) {
target-ppc/helper.c:            env->pending_interrupts &= ~(1 << PPC_INTERRUPT_EXT);
target-ppc/helper.c:            powerpc_excp(env, env->excp_model, POWERPC_EXCP_EXTERNAL);
target-ppc/helper.c:        if (env->pending_interrupts & (1 << PPC_INTERRUPT_DOORBELL)) {
target-ppc/helper.c:            env->pending_interrupts &= ~(1 << PPC_INTERRUPT_DOORBELL);
target-ppc/helper.c:            powerpc_excp(env, env->excp_model, POWERPC_EXCP_DOORI);
target-ppc/helper.c:        if (env->pending_interrupts & (1 << PPC_INTERRUPT_PERFM)) {
target-ppc/helper.c:            env->pending_interrupts &= ~(1 << PPC_INTERRUPT_PERFM);
target-ppc/helper.c:            powerpc_excp(env, env->excp_model, POWERPC_EXCP_PERFM);
target-ppc/helper.c:        if (env->pending_interrupts & (1 << PPC_INTERRUPT_THERM)) {
target-ppc/helper.c:            env->pending_interrupts &= ~(1 << PPC_INTERRUPT_THERM);
target-ppc/helper.c:            powerpc_excp(env, env->excp_model, POWERPC_EXCP_THERM);
target-ppc/helper.c:    env->cpu_model_str = cpu_model;
target-ppc/helper_regs.h:    tmp = env->gpr[0];
target-ppc/helper_regs.h:    env->gpr[0] = env->tgpr[0];
target-ppc/helper_regs.h:    env->tgpr[0] = tmp;
target-ppc/helper_regs.h:    tmp = env->gpr[1];
target-ppc/helper_regs.h:    env->gpr[1] = env->tgpr[1];
target-ppc/helper_regs.h:    env->tgpr[1] = tmp;
target-ppc/helper_regs.h:    tmp = env->gpr[2];
target-ppc/helper_regs.h:    env->gpr[2] = env->tgpr[2];
target-ppc/helper_regs.h:    env->tgpr[2] = tmp;
target-ppc/helper_regs.h:    tmp = env->gpr[3];
target-ppc/helper_regs.h:    env->gpr[3] = env->tgpr[3];
target-ppc/helper_regs.h:    env->tgpr[3] = tmp;
target-ppc/helper_regs.h:        env->mmu_idx = 2;
target-ppc/helper_regs.h:        env->mmu_idx = 1 - msr_pr;
target-ppc/helper_regs.h:    env->hflags = env->msr & hflags_mask;
target-ppc/helper_regs.h:    env->hflags |= env->hflags_nmsr;
target-ppc/helper_regs.h:    value &= env->msr_mask;
target-ppc/helper_regs.h:        value |= env->msr & MSR_HVB;
target-ppc/helper_regs.h:        env->interrupt_request |= CPU_INTERRUPT_EXITTB;
target-ppc/helper_regs.h:    if (unlikely((env->flags & POWERPC_FLAG_TGPR) &&
target-ppc/helper_regs.h:                 ((value ^ env->msr) & (1 << MSR_TGPR)))) {
target-ppc/helper_regs.h:        env->excp_prefix = ((value >> MSR_EP) & 1) * 0xFFF00000;
target-ppc/helper_regs.h:    env->msr = value;
target-ppc/helper_regs.h:        if ((*env->check_pow)(env)) {
target-ppc/helper_regs.h:            env->halted = 1;
target-ppc/kvm.c:    if (cenv->excp_model == POWERPC_EXCP_BOOKE) {
target-ppc/kvm.c:    sregs.pvr = cenv->spr[SPR_PVR];
target-ppc/kvm.c:        !kvm_check_extension(env->kvm_state, KVM_CAP_SW_TLB)) {
target-ppc/kvm.c:    assert(entries == env->nb_tlb);
target-ppc/kvm.c:    env->tlb_dirty = true;
target-ppc/kvm.c:    cfg.array = (uintptr_t)env->tlb.tlbm;
target-ppc/kvm.c:    env->kvm_sw_tlb = true;
target-ppc/kvm.c:    switch (cenv->mmu_model) {
target-ppc/kvm.c:    if (!env->kvm_sw_tlb) {
target-ppc/kvm.c:    bitmap = g_malloc((env->nb_tlb + 7) / 8);
target-ppc/kvm.c:    memset(bitmap, 0xFF, (env->nb_tlb + 7) / 8);
target-ppc/kvm.c:    dirty_tlb.num_dirty = env->nb_tlb;
target-ppc/kvm.c:    regs.ctr = env->ctr;
target-ppc/kvm.c:    regs.lr  = env->lr;
target-ppc/kvm.c:    regs.xer = env->xer;
target-ppc/kvm.c:    regs.msr = env->msr;
target-ppc/kvm.c:    regs.pc = env->nip;
target-ppc/kvm.c:    regs.srr0 = env->spr[SPR_SRR0];
target-ppc/kvm.c:    regs.srr1 = env->spr[SPR_SRR1];
target-ppc/kvm.c:    regs.sprg0 = env->spr[SPR_SPRG0];
target-ppc/kvm.c:    regs.sprg1 = env->spr[SPR_SPRG1];
target-ppc/kvm.c:    regs.sprg2 = env->spr[SPR_SPRG2];
target-ppc/kvm.c:    regs.sprg3 = env->spr[SPR_SPRG3];
target-ppc/kvm.c:    regs.sprg4 = env->spr[SPR_SPRG4];
target-ppc/kvm.c:    regs.sprg5 = env->spr[SPR_SPRG5];
target-ppc/kvm.c:    regs.sprg6 = env->spr[SPR_SPRG6];
target-ppc/kvm.c:    regs.sprg7 = env->spr[SPR_SPRG7];
target-ppc/kvm.c:    regs.pid = env->spr[SPR_BOOKE_PID];
target-ppc/kvm.c:        regs.gpr[i] = env->gpr[i];
target-ppc/kvm.c:    if (env->tlb_dirty) {
target-ppc/kvm.c:        env->tlb_dirty = false;
target-ppc/kvm.c:        env->crf[i] = cr & 15;
target-ppc/kvm.c:    env->ctr = regs.ctr;
target-ppc/kvm.c:    env->lr = regs.lr;
target-ppc/kvm.c:    env->xer = regs.xer;
target-ppc/kvm.c:    env->msr = regs.msr;
target-ppc/kvm.c:    env->nip = regs.pc;
target-ppc/kvm.c:    env->spr[SPR_SRR0] = regs.srr0;
target-ppc/kvm.c:    env->spr[SPR_SRR1] = regs.srr1;
target-ppc/kvm.c:    env->spr[SPR_SPRG0] = regs.sprg0;
target-ppc/kvm.c:    env->spr[SPR_SPRG1] = regs.sprg1;
target-ppc/kvm.c:    env->spr[SPR_SPRG2] = regs.sprg2;
target-ppc/kvm.c:    env->spr[SPR_SPRG3] = regs.sprg3;
target-ppc/kvm.c:    env->spr[SPR_SPRG4] = regs.sprg4;
target-ppc/kvm.c:    env->spr[SPR_SPRG5] = regs.sprg5;
target-ppc/kvm.c:    env->spr[SPR_SPRG6] = regs.sprg6;
target-ppc/kvm.c:    env->spr[SPR_SPRG7] = regs.sprg7;
target-ppc/kvm.c:    env->spr[SPR_BOOKE_PID] = regs.pid;
target-ppc/kvm.c:        env->gpr[i] = regs.gpr[i];
target-ppc/kvm.c:            env->spr[SPR_BOOKE_CSRR0] = sregs.u.e.csrr0;
target-ppc/kvm.c:            env->spr[SPR_BOOKE_CSRR1] = sregs.u.e.csrr1;
target-ppc/kvm.c:            env->spr[SPR_BOOKE_ESR] = sregs.u.e.esr;
target-ppc/kvm.c:            env->spr[SPR_BOOKE_DEAR] = sregs.u.e.dear;
target-ppc/kvm.c:            env->spr[SPR_BOOKE_MCSR] = sregs.u.e.mcsr;
target-ppc/kvm.c:            env->spr[SPR_BOOKE_TSR] = sregs.u.e.tsr;
target-ppc/kvm.c:            env->spr[SPR_BOOKE_TCR] = sregs.u.e.tcr;
target-ppc/kvm.c:            env->spr[SPR_DECR] = sregs.u.e.dec;
target-ppc/kvm.c:            env->spr[SPR_TBL] = sregs.u.e.tb & 0xffffffff;
target-ppc/kvm.c:            env->spr[SPR_TBU] = sregs.u.e.tb >> 32;
target-ppc/kvm.c:            env->spr[SPR_VRSAVE] = sregs.u.e.vrsave;
target-ppc/kvm.c:            env->spr[SPR_BOOKE_PIR] = sregs.u.e.pir;
target-ppc/kvm.c:            env->spr[SPR_BOOKE_MCSRR0] = sregs.u.e.mcsrr0;
target-ppc/kvm.c:            env->spr[SPR_BOOKE_MCSRR1] = sregs.u.e.mcsrr1;
target-ppc/kvm.c:            env->spr[SPR_BOOKE_DECAR] = sregs.u.e.decar;
target-ppc/kvm.c:            env->spr[SPR_BOOKE_IVPR] = sregs.u.e.ivpr;
target-ppc/kvm.c:            env->spr[SPR_BOOKE_EPCR] = sregs.u.e.epcr;
target-ppc/kvm.c:            env->spr[SPR_BOOKE_SPRG8] = sregs.u.e.sprg8;
target-ppc/kvm.c:            env->spr[SPR_BOOKE_IVOR0] = sregs.u.e.ivor_low[0];
target-ppc/kvm.c:            env->spr[SPR_BOOKE_IVOR1] = sregs.u.e.ivor_low[1];
target-ppc/kvm.c:            env->spr[SPR_BOOKE_IVOR2] = sregs.u.e.ivor_low[2];
target-ppc/kvm.c:            env->spr[SPR_BOOKE_IVOR3] = sregs.u.e.ivor_low[3];
target-ppc/kvm.c:            env->spr[SPR_BOOKE_IVOR4] = sregs.u.e.ivor_low[4];
target-ppc/kvm.c:            env->spr[SPR_BOOKE_IVOR5] = sregs.u.e.ivor_low[5];
target-ppc/kvm.c:            env->spr[SPR_BOOKE_IVOR6] = sregs.u.e.ivor_low[6];
target-ppc/kvm.c:            env->spr[SPR_BOOKE_IVOR7] = sregs.u.e.ivor_low[7];
target-ppc/kvm.c:            env->spr[SPR_BOOKE_IVOR8] = sregs.u.e.ivor_low[8];
target-ppc/kvm.c:            env->spr[SPR_BOOKE_IVOR9] = sregs.u.e.ivor_low[9];
target-ppc/kvm.c:            env->spr[SPR_BOOKE_IVOR10] = sregs.u.e.ivor_low[10];
target-ppc/kvm.c:            env->spr[SPR_BOOKE_IVOR11] = sregs.u.e.ivor_low[11];
target-ppc/kvm.c:            env->spr[SPR_BOOKE_IVOR12] = sregs.u.e.ivor_low[12];
target-ppc/kvm.c:            env->spr[SPR_BOOKE_IVOR13] = sregs.u.e.ivor_low[13];
target-ppc/kvm.c:            env->spr[SPR_BOOKE_IVOR14] = sregs.u.e.ivor_low[14];
target-ppc/kvm.c:            env->spr[SPR_BOOKE_IVOR15] = sregs.u.e.ivor_low[15];
target-ppc/kvm.c:                env->spr[SPR_BOOKE_IVOR32] = sregs.u.e.ivor_high[0];
target-ppc/kvm.c:                env->spr[SPR_BOOKE_IVOR33] = sregs.u.e.ivor_high[1];
target-ppc/kvm.c:                env->spr[SPR_BOOKE_IVOR34] = sregs.u.e.ivor_high[2];
target-ppc/kvm.c:                env->spr[SPR_BOOKE_IVOR35] = sregs.u.e.ivor_high[3];
target-ppc/kvm.c:                env->spr[SPR_BOOKE_IVOR36] = sregs.u.e.ivor_high[4];
target-ppc/kvm.c:                env->spr[SPR_BOOKE_IVOR37] = sregs.u.e.ivor_high[5];
target-ppc/kvm.c:            env->spr[SPR_BOOKE_MAS0] = sregs.u.e.mas0;
target-ppc/kvm.c:            env->spr[SPR_BOOKE_MAS1] = sregs.u.e.mas1;
target-ppc/kvm.c:            env->spr[SPR_BOOKE_MAS2] = sregs.u.e.mas2;
target-ppc/kvm.c:            env->spr[SPR_BOOKE_MAS3] = sregs.u.e.mas7_3 & 0xffffffff;
target-ppc/kvm.c:            env->spr[SPR_BOOKE_MAS4] = sregs.u.e.mas4;
target-ppc/kvm.c:            env->spr[SPR_BOOKE_MAS6] = sregs.u.e.mas6;
target-ppc/kvm.c:            env->spr[SPR_BOOKE_MAS7] = sregs.u.e.mas7_3 >> 32;
target-ppc/kvm.c:            env->spr[SPR_MMUCFG] = sregs.u.e.mmucfg;
target-ppc/kvm.c:            env->spr[SPR_BOOKE_TLB0CFG] = sregs.u.e.tlbcfg[0];
target-ppc/kvm.c:            env->spr[SPR_BOOKE_TLB1CFG] = sregs.u.e.tlbcfg[1];
target-ppc/kvm.c:            env->spr[SPR_BOOKE_EPR] = sregs.u.e.epr;
target-ppc/kvm.c:            env->spr[SPR_BOOKE_EPLC] = sregs.u.e.eplc;
target-ppc/kvm.c:            env->spr[SPR_BOOKE_EPSC] = sregs.u.e.epsc;
target-ppc/kvm.c:            env->spr[SPR_E500_SVR] = sregs.u.e.impl.fsl.svr;
target-ppc/kvm.c:            env->spr[SPR_Exxx_MCAR] = sregs.u.e.impl.fsl.mcar;
target-ppc/kvm.c:            env->spr[SPR_HID0] = sregs.u.e.impl.fsl.hid0;
target-ppc/kvm.c:                env->spr[SPR_BOOKE_PID1] = sregs.u.e.impl.fsl.pid1;
target-ppc/kvm.c:                env->spr[SPR_BOOKE_PID2] = sregs.u.e.impl.fsl.pid2;
target-ppc/kvm.c:            env->sr[i] = sregs.u.s.ppc32.sr[i];
target-ppc/kvm.c:            env->DBAT[0][i] = sregs.u.s.ppc32.dbat[i] & 0xffffffff;
target-ppc/kvm.c:            env->DBAT[1][i] = sregs.u.s.ppc32.dbat[i] >> 32;
target-ppc/kvm.c:            env->IBAT[0][i] = sregs.u.s.ppc32.ibat[i] & 0xffffffff;
target-ppc/kvm.c:            env->IBAT[1][i] = sregs.u.s.ppc32.ibat[i] >> 32;
target-ppc/kvm.c:     * interrupt, reset, etc) in PPC-specific env->irq_input_state. */
target-ppc/kvm.c:        (env->interrupt_request & CPU_INTERRUPT_HARD) &&
target-ppc/kvm.c:        (env->irq_input_state & (1<<PPC_INPUT_INT)))
target-ppc/kvm.c:            printf("cpu %d fail inject %x\n", env->cpu_index, irq);
target-ppc/kvm.c:    return env->halted;
target-ppc/kvm.c:    if (!(env->interrupt_request & CPU_INTERRUPT_HARD) && (msr_ee)) {
target-ppc/kvm.c:        env->halted = 1;
target-ppc/kvm.c:        env->exception_index = EXCP_HLT;
target-ppc/kvm.c:    if (ppc_dcr_read(env->dcr_env, dcrn, data) < 0)
target-ppc/kvm.c:    if (ppc_dcr_write(env->dcr_env, dcrn, data) < 0)
target-ppc/kvm.c:    if (kvm_check_extension(env->kvm_state, KVM_CAP_PPC_GET_PVINFO) &&
target-ppc/kvm.c:        !kvm_vm_ioctl(env->kvm_state, KVM_PPC_GET_PVINFO, &pvinfo)) {
target-ppc/kvm.c:    uint64_t hior = env->spr[SPR_HIOR];
target-ppc/kvm.c:    sregs.u.s.sdr1 = env->spr[SPR_SDR1];
target-ppc/kvm.c:    env->cpu_index = (env->cpu_index / smp_threads) * smt
target-ppc/kvm.c:        + (env->cpu_index % smp_threads);
target-ppc/machine.c:        qemu_put_betls(f, &env->gpr[i]);
target-ppc/machine.c:        qemu_put_betls(f, &env->gprh[i]);
target-ppc/machine.c:    qemu_put_betls(f, &env->lr);
target-ppc/machine.c:    qemu_put_betls(f, &env->ctr);
target-ppc/machine.c:        qemu_put_be32s(f, &env->crf[i]);
target-ppc/machine.c:    qemu_put_betls(f, &env->xer);
target-ppc/machine.c:    qemu_put_betls(f, &env->reserve_addr);
target-ppc/machine.c:    qemu_put_betls(f, &env->msr);
target-ppc/machine.c:        qemu_put_betls(f, &env->tgpr[i]);
target-ppc/machine.c:        u.d = env->fpr[i];
target-ppc/machine.c:    qemu_put_be32s(f, &env->fpscr);
target-ppc/machine.c:    qemu_put_sbe32s(f, &env->access_type);
target-ppc/machine.c:    qemu_put_betls(f, &env->asr);
target-ppc/machine.c:    qemu_put_sbe32s(f, &env->slb_nr);
target-ppc/machine.c:    qemu_put_betls(f, &env->spr[SPR_SDR1]);
target-ppc/machine.c:        qemu_put_betls(f, &env->sr[i]);
target-ppc/machine.c:            qemu_put_betls(f, &env->DBAT[i][j]);
target-ppc/machine.c:            qemu_put_betls(f, &env->IBAT[i][j]);
target-ppc/machine.c:    qemu_put_sbe32s(f, &env->nb_tlb);
target-ppc/machine.c:    qemu_put_sbe32s(f, &env->tlb_per_way);
target-ppc/machine.c:    qemu_put_sbe32s(f, &env->nb_ways);
target-ppc/machine.c:    qemu_put_sbe32s(f, &env->last_way);
target-ppc/machine.c:    qemu_put_sbe32s(f, &env->id_tlbs);
target-ppc/machine.c:    qemu_put_sbe32s(f, &env->nb_pids);
target-ppc/machine.c:    if (env->tlb.tlb6) {
target-ppc/machine.c:        for (i = 0; i < env->nb_tlb; i++) {
target-ppc/machine.c:            qemu_put_betls(f, &env->tlb.tlb6[i].pte0);
target-ppc/machine.c:            qemu_put_betls(f, &env->tlb.tlb6[i].pte1);
target-ppc/machine.c:            qemu_put_betls(f, &env->tlb.tlb6[i].EPN);
target-ppc/machine.c:        qemu_put_betls(f, &env->pb[i]);
target-ppc/machine.c:        qemu_put_betls(f, &env->spr[i]);
target-ppc/machine.c:    qemu_put_be32s(f, &env->vscr);
target-ppc/machine.c:    qemu_put_be64s(f, &env->spe_acc);
target-ppc/machine.c:    qemu_put_be32s(f, &env->spe_fscr);
target-ppc/machine.c:    qemu_put_betls(f, &env->msr_mask);
target-ppc/machine.c:    qemu_put_be32s(f, &env->flags);
target-ppc/machine.c:    qemu_put_sbe32s(f, &env->error_code);
target-ppc/machine.c:    qemu_put_be32s(f, &env->pending_interrupts);
target-ppc/machine.c:    qemu_put_be32s(f, &env->irq_input_state);
target-ppc/machine.c:        qemu_put_betls(f, &env->excp_vectors[i]);
target-ppc/machine.c:    qemu_put_betls(f, &env->excp_prefix);
target-ppc/machine.c:    qemu_put_betls(f, &env->hreset_excp_prefix);
target-ppc/machine.c:    qemu_put_betls(f, &env->ivor_mask);
target-ppc/machine.c:    qemu_put_betls(f, &env->ivpr_mask);
target-ppc/machine.c:    qemu_put_betls(f, &env->hreset_vector);
target-ppc/machine.c:    qemu_put_betls(f, &env->nip);
target-ppc/machine.c:    qemu_put_betls(f, &env->hflags);
target-ppc/machine.c:    qemu_put_betls(f, &env->hflags_nmsr);
target-ppc/machine.c:    qemu_put_sbe32s(f, &env->mmu_idx);
target-ppc/machine.c:    qemu_put_sbe32s(f, &env->power_mode);
target-ppc/machine.c:        qemu_get_betls(f, &env->gpr[i]);
target-ppc/machine.c:        qemu_get_betls(f, &env->gprh[i]);
target-ppc/machine.c:    qemu_get_betls(f, &env->lr);
target-ppc/machine.c:    qemu_get_betls(f, &env->ctr);
target-ppc/machine.c:        qemu_get_be32s(f, &env->crf[i]);
target-ppc/machine.c:    qemu_get_betls(f, &env->xer);
target-ppc/machine.c:    qemu_get_betls(f, &env->reserve_addr);
target-ppc/machine.c:    qemu_get_betls(f, &env->msr);
target-ppc/machine.c:        qemu_get_betls(f, &env->tgpr[i]);
target-ppc/machine.c:        env->fpr[i] = u.d;
target-ppc/machine.c:    qemu_get_be32s(f, &env->fpscr);
target-ppc/machine.c:    qemu_get_sbe32s(f, &env->access_type);
target-ppc/machine.c:    qemu_get_betls(f, &env->asr);
target-ppc/machine.c:    qemu_get_sbe32s(f, &env->slb_nr);
target-ppc/machine.c:        qemu_get_betls(f, &env->sr[i]);
target-ppc/machine.c:            qemu_get_betls(f, &env->DBAT[i][j]);
target-ppc/machine.c:            qemu_get_betls(f, &env->IBAT[i][j]);
target-ppc/machine.c:    qemu_get_sbe32s(f, &env->nb_tlb);
target-ppc/machine.c:    qemu_get_sbe32s(f, &env->tlb_per_way);
target-ppc/machine.c:    qemu_get_sbe32s(f, &env->nb_ways);
target-ppc/machine.c:    qemu_get_sbe32s(f, &env->last_way);
target-ppc/machine.c:    qemu_get_sbe32s(f, &env->id_tlbs);
target-ppc/machine.c:    qemu_get_sbe32s(f, &env->nb_pids);
target-ppc/machine.c:    if (env->tlb.tlb6) {
target-ppc/machine.c:        for (i = 0; i < env->nb_tlb; i++) {
target-ppc/machine.c:            qemu_get_betls(f, &env->tlb.tlb6[i].pte0);
target-ppc/machine.c:            qemu_get_betls(f, &env->tlb.tlb6[i].pte1);
target-ppc/machine.c:            qemu_get_betls(f, &env->tlb.tlb6[i].EPN);
target-ppc/machine.c:        qemu_get_betls(f, &env->pb[i]);
target-ppc/machine.c:        qemu_get_betls(f, &env->spr[i]);
target-ppc/machine.c:    qemu_get_be32s(f, &env->vscr);
target-ppc/machine.c:    qemu_get_be64s(f, &env->spe_acc);
target-ppc/machine.c:    qemu_get_be32s(f, &env->spe_fscr);
target-ppc/machine.c:    qemu_get_betls(f, &env->msr_mask);
target-ppc/machine.c:    qemu_get_be32s(f, &env->flags);
target-ppc/machine.c:    qemu_get_sbe32s(f, &env->error_code);
target-ppc/machine.c:    qemu_get_be32s(f, &env->pending_interrupts);
target-ppc/machine.c:    qemu_get_be32s(f, &env->irq_input_state);
target-ppc/machine.c:        qemu_get_betls(f, &env->excp_vectors[i]);
target-ppc/machine.c:    qemu_get_betls(f, &env->excp_prefix);
target-ppc/machine.c:    qemu_get_betls(f, &env->hreset_excp_prefix);
target-ppc/machine.c:    qemu_get_betls(f, &env->ivor_mask);
target-ppc/machine.c:    qemu_get_betls(f, &env->ivpr_mask);
target-ppc/machine.c:    qemu_get_betls(f, &env->hreset_vector);
target-ppc/machine.c:    qemu_get_betls(f, &env->nip);
target-ppc/machine.c:    qemu_get_betls(f, &env->hflags);
target-ppc/machine.c:    qemu_get_betls(f, &env->hflags_nmsr);
target-ppc/machine.c:    qemu_get_sbe32s(f, &env->mmu_idx);
target-ppc/machine.c:    qemu_get_sbe32s(f, &env->power_mode);
target-ppc/translate.c:                env->nip, env->lr, env->ctr, env->xer);
target-ppc/translate.c:                TARGET_FMT_lx " idx %d\n", env->msr, env->spr[SPR_HID0],
target-ppc/translate.c:                env->hflags, env->mmu_idx);
target-ppc/translate.c:        cpu_fprintf(f, "%01x", env->crf[i]);
target-ppc/translate.c:        if (env->crf[i] & 0x08)
target-ppc/translate.c:        else if (env->crf[i] & 0x04)
target-ppc/translate.c:        else if (env->crf[i] & 0x02)
target-ppc/translate.c:        cpu_fprintf(f, " %c%c", a, env->crf[i] & 0x01 ? 'O' : ' ');
target-ppc/translate.c:                env->reserve_addr);
target-ppc/translate.c:        cpu_fprintf(f, " %016" PRIx64, *((uint64_t *)&env->fpr[i]));
target-ppc/translate.c:    cpu_fprintf(f, "FPSCR %08x\n", env->fpscr);
target-ppc/translate.c:                env->spr[SPR_SRR0], env->spr[SPR_SRR1],
target-ppc/translate.c:                env->spr[SPR_PVR], env->spr[SPR_VRSAVE]);
target-ppc/translate.c:                env->spr[SPR_SPRG0], env->spr[SPR_SPRG1],
target-ppc/translate.c:                env->spr[SPR_SPRG2], env->spr[SPR_SPRG3]);
target-ppc/translate.c:                env->spr[SPR_SPRG4], env->spr[SPR_SPRG5],
target-ppc/translate.c:                env->spr[SPR_SPRG6], env->spr[SPR_SPRG7]);
target-ppc/translate.c:    if (env->excp_model == POWERPC_EXCP_BOOKE) {
target-ppc/translate.c:                    env->spr[SPR_BOOKE_CSRR0], env->spr[SPR_BOOKE_CSRR1],
target-ppc/translate.c:                    env->spr[SPR_BOOKE_MCSRR0], env->spr[SPR_BOOKE_MCSRR1]);
target-ppc/translate.c:                    env->spr[SPR_BOOKE_TCR], env->spr[SPR_BOOKE_TSR],
target-ppc/translate.c:                    env->spr[SPR_BOOKE_ESR], env->spr[SPR_BOOKE_DEAR]);
target-ppc/translate.c:                    env->spr[SPR_BOOKE_PIR], env->spr[SPR_BOOKE_DECAR],
target-ppc/translate.c:                    env->spr[SPR_BOOKE_IVPR], env->spr[SPR_BOOKE_EPCR]);
target-ppc/translate.c:                    env->spr[SPR_BOOKE_MCSR], env->spr[SPR_BOOKE_SPRG8],
target-ppc/translate.c:                    env->spr[SPR_BOOKE_EPR]);
target-ppc/translate.c:                    env->spr[SPR_Exxx_MCAR], env->spr[SPR_BOOKE_PID1],
target-ppc/translate.c:                    env->spr[SPR_BOOKE_PID2], env->spr[SPR_E500_SVR]);
target-ppc/translate.c:    if (env->flags & POWERPC_FLAG_CFAR) {
target-ppc/translate.c:        cpu_fprintf(f, " CFAR " TARGET_FMT_lx"\n", env->cfar);
target-ppc/translate.c:    switch (env->mmu_model) {
target-ppc/translate.c:        cpu_fprintf(f, " SDR1 " TARGET_FMT_lx "\n", env->spr[SPR_SDR1]);
target-ppc/translate.c:                    env->spr[SPR_BOOKE_MAS0], env->spr[SPR_BOOKE_MAS1],
target-ppc/translate.c:                    env->spr[SPR_BOOKE_MAS2], env->spr[SPR_BOOKE_MAS3]);
target-ppc/translate.c:                    env->spr[SPR_BOOKE_MAS4], env->spr[SPR_BOOKE_MAS6],
target-ppc/translate.c:                    env->spr[SPR_BOOKE_MAS7], env->spr[SPR_BOOKE_PID]);
target-ppc/translate.c:                    env->spr[SPR_MMUCFG], env->spr[SPR_BOOKE_TLB0CFG],
target-ppc/translate.c:                    env->spr[SPR_BOOKE_TLB1CFG]);
target-ppc/translate.c:    t1 = env->opcodes;
target-ppc/translate.c:    ctx.spr_cb = env->spr_cb;
target-ppc/translate.c:    ctx.mem_idx = env->mmu_idx;
target-ppc/translate.c:    ctx.le_mode = env->hflags & (1 << MSR_LE) ? 1 : 0;
target-ppc/translate.c:    ctx.has_cfar = !!(env->flags & POWERPC_FLAG_CFAR);
target-ppc/translate.c:    if ((env->flags & POWERPC_FLAG_SPE) && msr_spe)
target-ppc/translate.c:    if ((env->flags & POWERPC_FLAG_VRE) && msr_vr)
target-ppc/translate.c:    if ((env->flags & POWERPC_FLAG_SE) && msr_se)
target-ppc/translate.c:    if ((env->flags & POWERPC_FLAG_BE) && msr_be)
target-ppc/translate.c:    if (unlikely(env->singlestep_enabled))
target-ppc/translate.c:        if (unlikely(!QTAILQ_EMPTY(&env->breakpoints))) {
target-ppc/translate.c:            QTAILQ_FOREACH(bp, &env->breakpoints, entry) {
target-ppc/translate.c:        table = env->opcodes;
target-ppc/translate.c:                            (env->singlestep_enabled) ||
target-ppc/translate.c:        if (unlikely(env->singlestep_enabled)) {
target-ppc/translate.c:        flags = env->bfd_mach;
target-ppc/translate.c:    env->nip = gen_opc_pc[pc_pos];
target-s390x/op_helper.c:    env->exception_index = excp;
target-s390x/op_helper.c:    uint64_t asc = env->psw.mask & PSW_MASK_ASC;
target-s390x/op_helper.c:    uint64_t asc = env->psw.mask & PSW_MASK_ASC;
target-s390x/op_helper.c:    __uint128_t res = (__uint128_t)env->regs[r1 + 1];
target-s390x/op_helper.c:    env->regs[r1] = (uint64_t)(res >> 64);
target-s390x/op_helper.c:    env->regs[r1 + 1] = (uint64_t)res;
target-s390x/op_helper.c:    mulu64(&env->regs[r1 + 1], &env->regs[r1], env->regs[r1 + 1], v2);
target-s390x/op_helper.c:    if (!env->regs[r1]) {
target-s390x/op_helper.c:        env->regs[r1] = env->regs[r1+1] % divisor;
target-s390x/op_helper.c:        env->regs[r1+1] = env->regs[r1+1] / divisor;
target-s390x/op_helper.c:        __uint128_t dividend = (((__uint128_t)env->regs[r1]) << 64) |
target-s390x/op_helper.c:                               (env->regs[r1+1]);
target-s390x/op_helper.c:        env->regs[r1+1] = quotient;
target-s390x/op_helper.c:        env->regs[r1] = remainder;
target-s390x/op_helper.c:        r += env->regs[x2];
target-s390x/op_helper.c:        r += env->regs[b2];
target-s390x/op_helper.c:    if (!(env->psw.mask & PSW_MASK_64)) {
target-s390x/op_helper.c:    uint64_t r = env->regs[reg];
target-s390x/op_helper.c:    if (!(env->psw.mask & PSW_MASK_64)) {
target-s390x/op_helper.c:               c, env->regs[r1], env->regs[r2]);
target-s390x/op_helper.c:            env->regs[r1] = i;
target-s390x/op_helper.c:        env->regs[r1] = s1;
target-s390x/op_helper.c:        env->regs[r2] = s2;
target-s390x/op_helper.c:    env->regs[r1] = dest; /* FIXME: 31-bit mode! */
target-s390x/op_helper.c:    if (env->regs[r1] == v2) {
target-s390x/op_helper.c:        stq(a2, env->regs[r3]);
target-s390x/op_helper.c:        env->regs[r1] = v2;
target-s390x/op_helper.c:    uint64_t v1_hi = env->regs[r1];
target-s390x/op_helper.c:    uint64_t v1_lo = env->regs[r1 + 1];
target-s390x/op_helper.c:        stq(a2, env->regs[r3]);
target-s390x/op_helper.c:        stq(a2 + 8, env->regs[r3 + 1]);
target-s390x/op_helper.c:        env->regs[r1] = v2_hi;
target-s390x/op_helper.c:        env->regs[r1 + 1] = v2_lo;
target-s390x/op_helper.c:    if (((uint32_t)env->regs[r1]) == v2) {
target-s390x/op_helper.c:        stl(a2, (uint32_t)env->regs[r3]);
target-s390x/op_helper.c:        env->regs[r1] = (env->regs[r1] & 0xffffffff00000000ULL) | v2;
target-s390x/op_helper.c:            env->regs[r1] &= ~rmask;
target-s390x/op_helper.c:            env->regs[r1] |= (uint64_t)val << pos;
target-s390x/op_helper.c:        env->psw.addr = ret - 4;
target-s390x/op_helper.c:        env->int_svc_code = (insn|v1) & 0xff;
target-s390x/op_helper.c:        env->int_svc_ilc = 4;
target-s390x/op_helper.c:            stb(address, (env->regs[r1] >> pos) & 0xff);
target-s390x/op_helper.c:            env->regs[r1] &= ~rmask;
target-s390x/op_helper.c:            env->regs[r1] |= (uint64_t)val << pos;
target-s390x/op_helper.c:    uint64_t r = env->regs[r1];
target-s390x/op_helper.c:    r |= (cc << 28) | ( (env->psw.mask >> 40) & 0xf );
target-s390x/op_helper.c:    env->regs[r1] = r;
target-s390x/op_helper.c:               cc, env->psw.mask, r);
target-s390x/op_helper.c:        env->aregs[i] = ldl(a2);
target-s390x/op_helper.c:        stl(a2, env->aregs[i]);
target-s390x/op_helper.c:    uint64_t destlen = env->regs[r1 + 1] & 0xffffff;
target-s390x/op_helper.c:    uint64_t srclen = env->regs[r2 + 1] & 0xffffff;
target-s390x/op_helper.c:    env->regs[r1 + 1] = destlen;
target-s390x/op_helper.c:    env->regs[r2 + 1] -= src - env->regs[r2];
target-s390x/op_helper.c:    env->regs[r1] = dest;
target-s390x/op_helper.c:    env->regs[r2] = src;
target-s390x/op_helper.c:    uint64_t destlen = env->regs[r1 + 1];
target-s390x/op_helper.c:    uint64_t dest = env->regs[r1];
target-s390x/op_helper.c:    uint64_t srclen = env->regs[r3 + 1];
target-s390x/op_helper.c:    uint64_t src = env->regs[r3];
target-s390x/op_helper.c:    if (!(env->psw.mask & PSW_MASK_64)) {
target-s390x/op_helper.c:    env->regs[r1 + 1] = destlen;
target-s390x/op_helper.c:    env->regs[r3 + 1] -= src - env->regs[r3];
target-s390x/op_helper.c:    env->regs[r1] = dest;
target-s390x/op_helper.c:    env->regs[r3] = src;
target-s390x/op_helper.c:    uint64_t destlen = env->regs[r1 + 1];
target-s390x/op_helper.c:    uint64_t srclen = env->regs[r3 + 1];
target-s390x/op_helper.c:    env->regs[r1 + 1] = destlen;
target-s390x/op_helper.c:    env->regs[r3 + 1] -= src - env->regs[r3];
target-s390x/op_helper.c:    env->regs[r1] = dest;
target-s390x/op_helper.c:    env->regs[r3] = src;
target-s390x/op_helper.c:    uint32_t v1 = env->regs[r1];
target-s390x/op_helper.c:    env->regs[r1] = (env->regs[r1] & 0xffffffff00000000ULL) | res;
target-s390x/op_helper.c:    env->regs[r1] = res;
target-s390x/op_helper.c:    return float_comp_to_cc(float32_compare_quiet(v1, v2, &env->fpu_status));
target-s390x/op_helper.c:    return float_comp_to_cc(float64_compare_quiet(v1, v2, &env->fpu_status));
target-s390x/op_helper.c:    env->fregs[f1].d = int32_to_float64(v2, &env->fpu_status);
target-s390x/op_helper.c:    v1.q = int32_to_float128(v2, &env->fpu_status);
target-s390x/op_helper.c:    env->fregs[f1].ll = v1.ll.upper;
target-s390x/op_helper.c:    env->fregs[f1 + 2].ll = v1.ll.lower;
target-s390x/op_helper.c:    env->fregs[f1].l.upper = int64_to_float32(v2, &env->fpu_status);
target-s390x/op_helper.c:    env->fregs[f1].d = int64_to_float64(v2, &env->fpu_status);
target-s390x/op_helper.c:    x1.q = int64_to_float128(v2, &env->fpu_status);
target-s390x/op_helper.c:    env->fregs[f1].ll = x1.ll.upper;
target-s390x/op_helper.c:    env->fregs[f1 + 2].ll = x1.ll.lower;
target-s390x/op_helper.c:    env->fregs[f1].l.upper = int32_to_float32(v2, &env->fpu_status);
target-s390x/op_helper.c:               env->fregs[f1].l.upper, f1);
target-s390x/op_helper.c:    env->fregs[f1].l.upper = float32_add(env->fregs[f1].l.upper,
target-s390x/op_helper.c:                                         env->fregs[f2].l.upper,
target-s390x/op_helper.c:                                         &env->fpu_status);
target-s390x/op_helper.c:               env->fregs[f2].l.upper, env->fregs[f1].l.upper, f1);
target-s390x/op_helper.c:    return set_cc_nz_f32(env->fregs[f1].l.upper);
target-s390x/op_helper.c:    env->fregs[f1].d = float64_add(env->fregs[f1].d, env->fregs[f2].d,
target-s390x/op_helper.c:                                   &env->fpu_status);
target-s390x/op_helper.c:               env->fregs[f2].d, env->fregs[f1].d, f1);
target-s390x/op_helper.c:    return set_cc_nz_f64(env->fregs[f1].d);
target-s390x/op_helper.c:    env->fregs[f1].l.upper = float32_sub(env->fregs[f1].l.upper,
target-s390x/op_helper.c:                                         env->fregs[f2].l.upper,
target-s390x/op_helper.c:                                         &env->fpu_status);
target-s390x/op_helper.c:               env->fregs[f2].l.upper, env->fregs[f1].l.upper, f1);
target-s390x/op_helper.c:    return set_cc_nz_f32(env->fregs[f1].l.upper);
target-s390x/op_helper.c:    env->fregs[f1].d = float64_sub(env->fregs[f1].d, env->fregs[f2].d,
target-s390x/op_helper.c:                                   &env->fpu_status);
target-s390x/op_helper.c:               __FUNCTION__, env->fregs[f2].d, env->fregs[f1].d, f1);
target-s390x/op_helper.c:    return set_cc_nz_f64(env->fregs[f1].d);
target-s390x/op_helper.c:    env->fregs[f1].l.upper = float32_div(env->fregs[f1].l.upper,
target-s390x/op_helper.c:                                         env->fregs[f2].l.upper,
target-s390x/op_helper.c:                                         &env->fpu_status);
target-s390x/op_helper.c:    v1.ll.upper = env->fregs[f1].ll;
target-s390x/op_helper.c:    v1.ll.lower = env->fregs[f1 + 2].ll;
target-s390x/op_helper.c:    v2.ll.upper = env->fregs[f2].ll;
target-s390x/op_helper.c:    v2.ll.lower = env->fregs[f2 + 2].ll;
target-s390x/op_helper.c:    res.q = float128_div(v1.q, v2.q, &env->fpu_status);
target-s390x/op_helper.c:    env->fregs[f1].ll = res.ll.upper;
target-s390x/op_helper.c:    env->fregs[f1 + 2].ll = res.ll.lower;
target-s390x/op_helper.c:    env->fregs[f1].d = float64_mul(env->fregs[f1].d, env->fregs[f2].d,
target-s390x/op_helper.c:                                   &env->fpu_status);
target-s390x/op_helper.c:    v1.ll.upper = env->fregs[f1].ll;
target-s390x/op_helper.c:    v1.ll.lower = env->fregs[f1 + 2].ll;
target-s390x/op_helper.c:    v2.ll.upper = env->fregs[f2].ll;
target-s390x/op_helper.c:    v2.ll.lower = env->fregs[f2 + 2].ll;
target-s390x/op_helper.c:    res.q = float128_mul(v1.q, v2.q, &env->fpu_status);
target-s390x/op_helper.c:    env->fregs[f1].ll = res.ll.upper;
target-s390x/op_helper.c:    env->fregs[f1 + 2].ll = res.ll.lower;
target-s390x/op_helper.c:    env->fregs[r1].d = float32_to_float64(env->fregs[r2].l.upper,
target-s390x/op_helper.c:                                          &env->fpu_status);
target-s390x/op_helper.c:    x2.ll.upper = env->fregs[f2].ll;
target-s390x/op_helper.c:    x2.ll.lower = env->fregs[f2 + 2].ll;
target-s390x/op_helper.c:    env->fregs[f1].d = float128_to_float64(x2.q, &env->fpu_status);
target-s390x/op_helper.c:    HELPER_LOG("%s: to 0x%ld\n", __FUNCTION__, env->fregs[f1].d);
target-s390x/op_helper.c:    res.q = float64_to_float128(env->fregs[f2].d, &env->fpu_status);
target-s390x/op_helper.c:    env->fregs[f1].ll = res.ll.upper;
target-s390x/op_helper.c:    env->fregs[f1 + 2].ll = res.ll.lower;
target-s390x/op_helper.c:    float64 d2 = env->fregs[f2].d;
target-s390x/op_helper.c:    env->fregs[f1].l.upper = float64_to_float32(d2, &env->fpu_status);
target-s390x/op_helper.c:    x2.ll.upper = env->fregs[f2].ll;
target-s390x/op_helper.c:    x2.ll.lower = env->fregs[f2 + 2].ll;
target-s390x/op_helper.c:    env->fregs[f1].l.upper = float128_to_float32(x2.q, &env->fpu_status);
target-s390x/op_helper.c:    HELPER_LOG("%s: to 0x%d\n", __FUNCTION__, env->fregs[f1].l.upper);
target-s390x/op_helper.c:    float32 v2 = env->fregs[f2].d;
target-s390x/op_helper.c:    env->fregs[f1].d = v1;
target-s390x/op_helper.c:    float64 v2 = env->fregs[f2].d;
target-s390x/op_helper.c:    env->fregs[f1].d = v1;
target-s390x/op_helper.c:    v2.ll.upper = env->fregs[f2].ll;
target-s390x/op_helper.c:    v2.ll.lower = env->fregs[f2 + 2].ll;
target-s390x/op_helper.c:    env->fregs[f1].ll = v1.ll.upper;
target-s390x/op_helper.c:    env->fregs[f1 + 2].ll = v1.ll.lower;
target-s390x/op_helper.c:    env->fregs[f1].d = env->fregs[f2].d;
target-s390x/op_helper.c:    return set_cc_nz_f64(env->fregs[f1].d);
target-s390x/op_helper.c:    env->fregs[f1].l.upper = env->fregs[f2].l.upper;
target-s390x/op_helper.c:    return set_cc_nz_f32(env->fregs[f1].l.upper);
target-s390x/op_helper.c:    x.ll.upper = env->fregs[f2].ll;
target-s390x/op_helper.c:    x.ll.lower = env->fregs[f2 + 2].ll;
target-s390x/op_helper.c:    env->fregs[f1].ll = x.ll.upper;
target-s390x/op_helper.c:    env->fregs[f1 + 2].ll = x.ll.lower;
target-s390x/op_helper.c:    env->fregs[f1].l.upper = float32_chs(env->fregs[f2].l.upper);
target-s390x/op_helper.c:    return set_cc_nz_f32(env->fregs[f1].l.upper);
target-s390x/op_helper.c:    env->fregs[f1].d = float64_chs(env->fregs[f2].d);
target-s390x/op_helper.c:    return set_cc_nz_f64(env->fregs[f1].d);
target-s390x/op_helper.c:    x2.ll.upper = env->fregs[f2].ll;
target-s390x/op_helper.c:    x2.ll.lower = env->fregs[f2 + 2].ll;
target-s390x/op_helper.c:    env->fregs[f1].ll = x1.ll.upper;
target-s390x/op_helper.c:    env->fregs[f1 + 2].ll = x1.ll.lower;
target-s390x/op_helper.c:    float32 v1 = env->fregs[f1].l.upper;
target-s390x/op_helper.c:    env->fregs[f1].l.upper = float32_add(v1, v2.f, &env->fpu_status);
target-s390x/op_helper.c:    float32 v1 = env->fregs[f1].l.upper;
target-s390x/op_helper.c:    env->fregs[f1].l.upper = float32_div(v1, v2.f, &env->fpu_status);
target-s390x/op_helper.c:    float32 v1 = env->fregs[f1].l.upper;
target-s390x/op_helper.c:    env->fregs[f1].l.upper = float32_mul(v1, v2.f, &env->fpu_status);
target-s390x/op_helper.c:    float32 v1 = env->fregs[f1].l.upper;
target-s390x/op_helper.c:    float32 v2 = env->fregs[f2].l.upper;
target-s390x/op_helper.c:    float64 v1 = env->fregs[f1].d;
target-s390x/op_helper.c:    float64 v2 = env->fregs[f2].d;
target-s390x/op_helper.c:    v1.ll.upper = env->fregs[f1].ll;
target-s390x/op_helper.c:    v1.ll.lower = env->fregs[f1 + 2].ll;
target-s390x/op_helper.c:    v2.ll.upper = env->fregs[f2].ll;
target-s390x/op_helper.c:    v2.ll.lower = env->fregs[f2 + 2].ll;
target-s390x/op_helper.c:                            &env->fpu_status));
target-s390x/op_helper.c:    float64 v1 = env->fregs[f1].d;
target-s390x/op_helper.c:    float64 v1 = env->fregs[f1].d;
target-s390x/op_helper.c:    env->fregs[f1].d = v1 = float64_add(v1, v2.d, &env->fpu_status);
target-s390x/op_helper.c:    float32 v1 = env->fregs[f1].l.upper;
target-s390x/op_helper.c:    env->fregs[f1].l.upper = float32_sub(v1, v2.f, &env->fpu_status);
target-s390x/op_helper.c:    float64 v1 = env->fregs[f1].d;
target-s390x/op_helper.c:    env->fregs[f1].d = v1 = float64_sub(v1, v2.d, &env->fpu_status);
target-s390x/op_helper.c:    float64 v1 = env->fregs[f1].d;
target-s390x/op_helper.c:    env->fregs[f1].d = float64_mul(v1, v2.d, &env->fpu_status);
target-s390x/op_helper.c:    float64 v1 = env->fregs[f1].d;
target-s390x/op_helper.c:    env->fregs[f1].d = float64_div(v1, v2.d, &env->fpu_status);
target-s390x/op_helper.c:        set_float_rounding_mode(float_round_nearest_even, &env->fpu_status);
target-s390x/op_helper.c:        set_float_rounding_mode(float_round_to_zero, &env->fpu_status);
target-s390x/op_helper.c:        set_float_rounding_mode(float_round_up, &env->fpu_status);
target-s390x/op_helper.c:        set_float_rounding_mode(float_round_down, &env->fpu_status);
target-s390x/op_helper.c:    float32 v2 = env->fregs[f2].l.upper;
target-s390x/op_helper.c:    env->regs[r1] = float32_to_int64(v2, &env->fpu_status);
target-s390x/op_helper.c:    float64 v2 = env->fregs[f2].d;
target-s390x/op_helper.c:    env->regs[r1] = float64_to_int64(v2, &env->fpu_status);
target-s390x/op_helper.c:    v2.ll.upper = env->fregs[f2].ll;
target-s390x/op_helper.c:    v2.ll.lower = env->fregs[f2 + 2].ll;
target-s390x/op_helper.c:    env->regs[r1] = float128_to_int64(v2.q, &env->fpu_status);
target-s390x/op_helper.c:    float32 v2 = env->fregs[f2].l.upper;
target-s390x/op_helper.c:    env->regs[r1] = (env->regs[r1] & 0xffffffff00000000ULL) |
target-s390x/op_helper.c:                     float32_to_int32(v2, &env->fpu_status);
target-s390x/op_helper.c:    float64 v2 = env->fregs[f2].d;
target-s390x/op_helper.c:    env->regs[r1] = (env->regs[r1] & 0xffffffff00000000ULL) |
target-s390x/op_helper.c:                     float64_to_int32(v2, &env->fpu_status);
target-s390x/op_helper.c:    v2.ll.upper = env->fregs[f2].ll;
target-s390x/op_helper.c:    v2.ll.lower = env->fregs[f2 + 2].ll;
target-s390x/op_helper.c:    env->regs[r1] = (env->regs[r1] & 0xffffffff00000000ULL) |
target-s390x/op_helper.c:                     float128_to_int32(v2.q, &env->fpu_status);
target-s390x/op_helper.c:    env->fregs[f1].l.upper = float32_zero;
target-s390x/op_helper.c:    env->fregs[f1].d = float64_zero;
target-s390x/op_helper.c:    x.q = float64_to_float128(float64_zero, &env->fpu_status);
target-s390x/op_helper.c:    env->fregs[f1].ll = x.ll.upper;
target-s390x/op_helper.c:    env->fregs[f1 + 1].ll = x.ll.lower;
target-s390x/op_helper.c:    v1.ll.upper = env->fregs[f1].ll;
target-s390x/op_helper.c:    v1.ll.lower = env->fregs[f1 + 2].ll;
target-s390x/op_helper.c:    v2.ll.upper = env->fregs[f2].ll;
target-s390x/op_helper.c:    v2.ll.lower = env->fregs[f2 + 2].ll;
target-s390x/op_helper.c:    res.q = float128_sub(v1.q, v2.q, &env->fpu_status);
target-s390x/op_helper.c:    env->fregs[f1].ll = res.ll.upper;
target-s390x/op_helper.c:    env->fregs[f1 + 2].ll = res.ll.lower;
target-s390x/op_helper.c:    v1.ll.upper = env->fregs[f1].ll;
target-s390x/op_helper.c:    v1.ll.lower = env->fregs[f1 + 2].ll;
target-s390x/op_helper.c:    v2.ll.upper = env->fregs[f2].ll;
target-s390x/op_helper.c:    v2.ll.lower = env->fregs[f2 + 2].ll;
target-s390x/op_helper.c:    res.q = float128_add(v1.q, v2.q, &env->fpu_status);
target-s390x/op_helper.c:    env->fregs[f1].ll = res.ll.upper;
target-s390x/op_helper.c:    env->fregs[f1 + 2].ll = res.ll.lower;
target-s390x/op_helper.c:    env->fregs[f1].l.upper = float32_mul(env->fregs[f1].l.upper,
target-s390x/op_helper.c:                                         env->fregs[f2].l.upper,
target-s390x/op_helper.c:                                         &env->fpu_status);
target-s390x/op_helper.c:    env->fregs[f1].d = float64_div(env->fregs[f1].d, env->fregs[f2].d,
target-s390x/op_helper.c:                                   &env->fpu_status);
target-s390x/op_helper.c:    env->fregs[f1].d = float64_add(env->fregs[f1].d,
target-s390x/op_helper.c:                                   float64_mul(v2.d, env->fregs[f3].d,
target-s390x/op_helper.c:                                               &env->fpu_status),
target-s390x/op_helper.c:                                   &env->fpu_status);
target-s390x/op_helper.c:    env->fregs[f1].d = float64_add(float64_mul(env->fregs[f2].d,
target-s390x/op_helper.c:                                               env->fregs[f3].d,
target-s390x/op_helper.c:                                               &env->fpu_status),
target-s390x/op_helper.c:                                   env->fregs[f1].d, &env->fpu_status);
target-s390x/op_helper.c:    env->fregs[f1].d = float64_sub(float64_mul(env->fregs[f2].d,
target-s390x/op_helper.c:                                               env->fregs[f3].d,
target-s390x/op_helper.c:                                               &env->fpu_status),
target-s390x/op_helper.c:                                   env->fregs[f1].d, &env->fpu_status);
target-s390x/op_helper.c:    env->fregs[f1].l.upper = float32_add(env->fregs[f1].l.upper,
target-s390x/op_helper.c:                                         float32_mul(env->fregs[f2].l.upper,
target-s390x/op_helper.c:                                                     env->fregs[f3].l.upper,
target-s390x/op_helper.c:                                                     &env->fpu_status),
target-s390x/op_helper.c:                                         &env->fpu_status);
target-s390x/op_helper.c:    env->fregs[f1].d = float32_to_float64(v2,
target-s390x/op_helper.c:                                          &env->fpu_status);
target-s390x/op_helper.c:    v1.q = float64_to_float128(v2.d, &env->fpu_status);
target-s390x/op_helper.c:    env->fregs[f1].ll = v1.ll.upper;
target-s390x/op_helper.c:    env->fregs[f1 + 2].ll = v1.ll.lower;
target-s390x/op_helper.c:    float32 v1 = env->fregs[f1].l.upper;
target-s390x/op_helper.c:    float64 v1 = env->fregs[f1].d;
target-s390x/op_helper.c:    v1.ll.upper = env->fregs[f1].ll;
target-s390x/op_helper.c:    v1.ll.lower = env->fregs[f1 + 2].ll;
target-s390x/op_helper.c:        env->regs[r1] = 64;
target-s390x/op_helper.c:        env->regs[r1 + 1] = 0;
target-s390x/op_helper.c:        env->regs[r1] = res;
target-s390x/op_helper.c:        env->regs[r1 + 1] = ov2 & ~(0x8000000000000000ULL >> res);
target-s390x/op_helper.c:    env->fregs[f1].d = float64_sqrt(env->fregs[f2].d, &env->fpu_status);
target-s390x/op_helper.c:    uint64_t src_len = env->regs[(r2 + 1) & 15];
target-s390x/op_helper.c:    uint64_t cksm = (uint32_t)env->regs[r1];
target-s390x/op_helper.c:    env->regs[r2] = src + src_len;
target-s390x/op_helper.c:    env->regs[(r2 + 1) & 15] = 0;
target-s390x/op_helper.c:    env->regs[r1] = (env->regs[r1] & 0xffffffff00000000ULL) |
target-s390x/op_helper.c:    qemu_log("program interrupt at %#" PRIx64 "\n", env->psw.addr);
target-s390x/op_helper.c:        env->int_pgm_code = code;
target-s390x/op_helper.c:        env->int_pgm_ilc = ilc;
target-s390x/op_helper.c:        env->exception_index = EXCP_PGM;
target-s390x/op_helper.c:                env->psw.addr += 4;
target-s390x/op_helper.c:    stq(a1, env->cpu_num);
target-s390x/op_helper.c:    env->psa = prefix & 0xfffff000;
target-s390x/op_helper.c:    time = env->tod_offset +
target-s390x/op_helper.c:           time2tod(qemu_get_clock_ns(vm_clock) - env->tod_basetime);
target-s390x/op_helper.c:    stq(a1 + 1, clock_value(env) | env->cpu_num);
target-s390x/op_helper.c:    qemu_mod_timer(env->tod_timer, qemu_get_clock_ns(vm_clock) + time);
target-s390x/op_helper.c:    qemu_mod_timer(env->cpu_timer, qemu_get_clock_ns(vm_clock) + time);
target-s390x/op_helper.c:            stw_p(&sysib.cpu_addr, env->cpu_num);
target-s390x/op_helper.c:            stw_p(&sysib.cpu_addr, env->cpu_num);
target-s390x/op_helper.c:        env->regs[0] = STSI_LEVEL_3;
target-s390x/op_helper.c:        env->cregs[i] = ldq(src);
target-s390x/op_helper.c:                   i, src, env->cregs[i]);
target-s390x/op_helper.c:        env->cregs[i] = (env->cregs[i] & 0xFFFFFFFF00000000ULL) | ldl(src);
target-s390x/op_helper.c:        stq(dest, env->cregs[i]);
target-s390x/op_helper.c:        stl(dest, env->cregs[i]);
target-s390x/op_helper.c:    return env->storage_keys[addr / TARGET_PAGE_SIZE];
target-s390x/op_helper.c:    env->storage_keys[addr / TARGET_PAGE_SIZE] = r1;
target-s390x/op_helper.c:    key = env->storage_keys[r2 / TARGET_PAGE_SIZE];
target-s390x/op_helper.c:    env->storage_keys[r2 / TARGET_PAGE_SIZE] = (key & ~SK_R);
target-s390x/op_helper.c:    uint32_t o1 = env->regs[r1];
target-s390x/op_helper.c:        stl(a2, env->regs[(r1 + 1) & 15]);
target-s390x/op_helper.c:        if (env->regs[r2] & 0x3) {
target-s390x/op_helper.c:        env->regs[r1] = (env->regs[r1] & 0xffffffff00000000ULL) | o2;
target-s390x/op_helper.c:        env->regs[r1] &= 0xffffffff00000000ULL;
target-s390x/op_helper.c:        env->psw.mask &= ~PSW_MASK_ASC;
target-s390x/op_helper.c:        env->psw.mask |= PSW_ASC_PRIMARY;
target-s390x/op_helper.c:        env->psw.mask &= ~PSW_MASK_ASC;
target-s390x/op_helper.c:        env->psw.mask |= PSW_ASC_SECONDARY;
target-s390x/op_helper.c:        env->psw.mask &= ~PSW_MASK_ASC;
target-s390x/op_helper.c:        env->psw.mask |= PSW_ASC_HOME;
target-s390x/op_helper.c:    int old_exc = env->exception_index;
target-s390x/op_helper.c:    uint64_t asc = env->psw.mask & PSW_MASK_ASC;
target-s390x/op_helper.c:    if (!(env->psw.mask & PSW_MASK_64) && (addr >> 32)) {
target-s390x/op_helper.c:    env->exception_index = old_exc;
target-s390x/op_helper.c:    if (env->exception_index == EXCP_PGM) {
target-s390x/op_helper.c:        ret = env->int_pgm_code | 0x80000000;
target-s390x/op_helper.c:    env->exception_index = old_exc;
target-s390x/op_helper.c:    if (!(env->psw.mask & PSW_MASK_64)) {
target-s390x/op_helper.c:        env->regs[r1] = (env->regs[r1] & 0xffffffff00000000ULL) | (ret & 0xffffffffULL);
target-s390x/op_helper.c:        env->regs[r1] = ret;
target-s390x/cpu.h:        env->regs[15] = newsp;
target-s390x/cpu.h:    env->regs[0] = 0;
target-s390x/cpu.h:    if (env->psw.mask & PSW_MASK_PSTATE) {
target-s390x/cpu.h:    *pc = env->psw.addr;
target-s390x/cpu.h:    *flags = ((env->psw.mask >> 32) & ~FLAG_MASK_CC) |
target-s390x/cpu.h:             ((env->psw.mask & PSW_MASK_32) ? FLAG_MASK_32 : 0);
target-s390x/cpu.h:    env->aregs[0] = newtls >> 32;
target-s390x/cpu.h:    env->aregs[1] = newtls & 0xffffffffULL;
target-s390x/cpu.h:    CC_OP_DYNAMIC,              /* CC calculation defined by env->cc_op */
target-s390x/cpu.h:    CC_OP_STATIC,               /* CC value is env->cc_op */
target-s390x/cpu.h:    CC_OP_NZ,                   /* env->cc_dst != 0 */
target-s390x/cpu.h:    if (env->ext_index == MAX_EXT_QUEUE - 1) {
target-s390x/cpu.h:    env->ext_index++;
target-s390x/cpu.h:    assert(env->ext_index < MAX_EXT_QUEUE);
target-s390x/cpu.h:    env->ext_queue[env->ext_index].code = code;
target-s390x/cpu.h:    env->ext_queue[env->ext_index].param = param;
target-s390x/cpu.h:    env->ext_queue[env->ext_index].param64 = param64;
target-s390x/cpu.h:    env->pending_int |= INTERRUPT_EXT;
target-s390x/cpu.h:    return (env->interrupt_request & CPU_INTERRUPT_HARD) &&
target-s390x/cpu.h:        (env->psw.mask & PSW_MASK_EXT);
target-s390x/cpu.h:    env->psw.addr = tb->pc;
target-s390x/helper.c:    env->pending_int |= INTERRUPT_TOD;
target-s390x/helper.c:    env->pending_int |= INTERRUPT_CPUTIMER;
target-s390x/helper.c:    env->cpu_model_str = cpu_model;
target-s390x/helper.c:    env->exception_index = -1;
target-s390x/helper.c:    env->exception_index = EXCP_ADDR;
target-s390x/helper.c:    env->__excp_addr = address; /* FIXME: find out how this works on a real machine */
target-s390x/helper.c:    env->exception_index = EXCP_PGM;
target-s390x/helper.c:    env->int_pgm_code = code;
target-s390x/helper.c:    env->int_pgm_ilc = ilc;
target-s390x/helper.c:    stq_phys(env->psa + offsetof(LowCore, trans_exc_code), vaddr | bits);
target-s390x/helper.c:    stq_phys(env->psa + offsetof(LowCore, trans_exc_code), vaddr | bits);
target-s390x/helper.c:        asce = env->cregs[1];
target-s390x/helper.c:        asce = env->cregs[7];
target-s390x/helper.c:        asce = env->cregs[13];
target-s390x/helper.c:    if (!(env->psw.mask & PSW_MASK_DAT)) {
target-s390x/helper.c:        *raddr = *raddr + env->psa;
target-s390x/helper.c:        sk = &env->storage_keys[*raddr / TARGET_PAGE_SIZE];
target-s390x/helper.c:    uint64_t asc = env->psw.mask & PSW_MASK_ASC;
target-s390x/helper.c:    if (!(env->psw.mask & PSW_MASK_64)) {
target-s390x/helper.c:    int old_exc = env->exception_index;
target-s390x/helper.c:    uint64_t asc = env->psw.mask & PSW_MASK_ASC;
target-s390x/helper.c:    if (!(env->psw.mask & PSW_MASK_64)) {
target-s390x/helper.c:    env->exception_index = old_exc;
target-s390x/helper.c:        env->halted = 1;
target-s390x/helper.c:        env->exception_index = EXCP_HLT;
target-s390x/helper.c:    env->psw.addr = addr;
target-s390x/helper.c:    env->psw.mask = mask;
target-s390x/helper.c:    env->cc_op = (mask >> 13) & 3;
target-s390x/helper.c:    uint64_t r = env->psw.mask;
target-s390x/helper.c:    env->cc_op = calc_cc(env, env->cc_op, env->cc_src, env->cc_dst, env->cc_vr);
target-s390x/helper.c:    assert(!(env->cc_op & ~3));
target-s390x/helper.c:    r |= env->cc_op << 13;
target-s390x/helper.c:    lowcore = cpu_physical_memory_map(env->psa, &len, 1);
target-s390x/helper.c:    lowcore->svc_code = cpu_to_be16(env->int_svc_code);
target-s390x/helper.c:    lowcore->svc_ilc = cpu_to_be16(env->int_svc_ilc);
target-s390x/helper.c:    lowcore->svc_old_psw.addr = cpu_to_be64(env->psw.addr + (env->int_svc_ilc));
target-s390x/helper.c:    int ilc = env->int_pgm_ilc;
target-s390x/helper.c:        ilc = get_ilc(ldub_code(env->psw.addr));
target-s390x/helper.c:        ilc = get_ilc(ldub_code(env->psw.addr));
target-s390x/helper.c:        env->psw.addr += ilc * 2;
target-s390x/helper.c:        ilc = get_ilc(ldub_code(env->psw.addr)) * 2;
target-s390x/helper.c:        env->psw.addr += ilc;
target-s390x/helper.c:    qemu_log("%s: code=0x%x ilc=%d\n", __FUNCTION__, env->int_pgm_code, ilc);
target-s390x/helper.c:    lowcore = cpu_physical_memory_map(env->psa, &len, 1);
target-s390x/helper.c:    lowcore->pgm_code = cpu_to_be16(env->int_pgm_code);
target-s390x/helper.c:    lowcore->program_old_psw.addr = cpu_to_be64(env->psw.addr);
target-s390x/helper.c:            env->int_pgm_code, ilc, env->psw.mask,
target-s390x/helper.c:            env->psw.addr);
target-s390x/helper.c:    if (!(env->psw.mask & PSW_MASK_EXT)) {
target-s390x/helper.c:    if (env->ext_index < 0 || env->ext_index > MAX_EXT_QUEUE) {
target-s390x/helper.c:        cpu_abort(env, "Ext queue overrun: %d\n", env->ext_index);
target-s390x/helper.c:    q = &env->ext_queue[env->ext_index];
target-s390x/helper.c:    lowcore = cpu_physical_memory_map(env->psa, &len, 1);
target-s390x/helper.c:    lowcore->external_old_psw.addr = cpu_to_be64(env->psw.addr);
target-s390x/helper.c:    lowcore->cpu_addr = cpu_to_be16(env->cpu_num | VIRTIO_SUBCODE_64);
target-s390x/helper.c:    env->ext_index--;
target-s390x/helper.c:    if (env->ext_index == -1) {
target-s390x/helper.c:        env->pending_int &= ~INTERRUPT_EXT;
target-s390x/helper.c:            env->psw.mask, env->psw.addr);
target-s390x/helper.c:    qemu_log("%s: %d at pc=%" PRIx64 "\n", __FUNCTION__, env->exception_index,
target-s390x/helper.c:             env->psw.addr);
target-s390x/helper.c:    if ((env->psw.mask & PSW_MASK_EXT) &&
target-s390x/helper.c:        env->exception_index == -1) {
target-s390x/helper.c:        if (env->pending_int & INTERRUPT_EXT) {
target-s390x/helper.c:            env->exception_index = EXCP_EXT;
target-s390x/helper.c:        } else if (env->pending_int & INTERRUPT_TOD) {
target-s390x/helper.c:            env->exception_index = EXCP_EXT;
target-s390x/helper.c:            env->pending_int &= ~INTERRUPT_EXT;
target-s390x/helper.c:            env->pending_int &= ~INTERRUPT_TOD;
target-s390x/helper.c:        } else if (env->pending_int & INTERRUPT_CPUTIMER) {
target-s390x/helper.c:            env->exception_index = EXCP_EXT;
target-s390x/helper.c:            env->pending_int &= ~INTERRUPT_EXT;
target-s390x/helper.c:            env->pending_int &= ~INTERRUPT_TOD;
target-s390x/helper.c:    switch (env->exception_index) {
target-s390x/helper.c:    env->exception_index = -1;
target-s390x/helper.c:    if (!env->pending_int) {
target-s390x/helper.c:        env->interrupt_request &= ~CPU_INTERRUPT_HARD;
target-s390x/cpu.c:        qemu_log("CPU Reset (CPU %d)\n", env->cpu_index);
target-s390x/cpu.c:    env->tod_offset = TOD_UNIX_EPOCH +
target-s390x/cpu.c:    env->tod_basetime = 0;
target-s390x/cpu.c:    env->tod_timer = qemu_new_timer_ns(vm_clock, s390x_tod_timer, cpu);
target-s390x/cpu.c:    env->cpu_timer = qemu_new_timer_ns(vm_clock, s390x_cpu_timer, cpu);
target-s390x/cpu.c:    env->cpu_num = cpu_num++;
target-s390x/cpu.c:    env->ext_index = -1;
target-s390x/kvm.c:        regs.gprs[i] = env->regs[i];
target-s390x/kvm.c:    env->kvm_run->psw_addr = env->psw.addr;
target-s390x/kvm.c:    env->kvm_run->psw_mask = env->psw.mask;
target-s390x/kvm.c:        env->regs[i] = regs.gprs[i];
target-s390x/kvm.c:    env->psw.addr = env->kvm_run->psw_addr;
target-s390x/kvm.c:    env->psw.mask = env->kvm_run->psw_mask;
target-s390x/kvm.c:    return env->halted;
target-s390x/kvm.c:    if (!env->kvm_state) {
target-s390x/kvm.c:        r = kvm_vm_ioctl(env->kvm_state, KVM_S390_INTERRUPT, &kvmint);
target-s390x/kvm.c:    env->kvm_run->psw_mask &= ~(3ull << 44);
target-s390x/kvm.c:    env->kvm_run->psw_mask |= (cc & 3) << 44;
target-s390x/kvm.c:    env->psw.mask &= ~(3ul << 44);
target-s390x/kvm.c:    env->psw.mask |= (cc & 3) << 44;
target-s390x/kvm.c:    sccb = env->regs[ipbh0 & 0xf];
target-s390x/kvm.c:    code = env->regs[(ipbh0 & 0xf0) >> 4];
target-s390x/kvm.c:    env->regs[2] = s390_virtio_hypercall(env, env->regs[2], env->regs[1]);
target-s390x/kvm.c:        env->regs[i] = 0;
target-s390x/kvm.c:        order_code = env->regs[order_code];
target-s390x/kvm.c:    parameter = env->regs[t] & 0x7ffffe00;
target-s390x/kvm.c:    cpu_addr = env->regs[ipa1 & 0x0f];
target-s390x/kvm.c:    return env->kvm_run->psw_addr == 0xfffUL;
target-s390x/kvm.c:    struct kvm_run *run = env->kvm_run;
target-s390x/kvm.c:            (long)env->kvm_run->psw_addr);
target-s390x/translate.c:        cpu_fprintf(f, "R%02d=%016" PRIx64, i, env->regs[i]);
target-s390x/translate.c:        cpu_fprintf(f, "F%02d=%016" PRIx64, i, *(uint64_t *)&env->fregs[i]);
target-s390x/translate.c:        cpu_fprintf(f, "C%02d=%016" PRIx64, i, env->cregs[i]);
target-s390x/translate.c:    if (env->cc_op > 3) {
target-s390x/translate.c:                    env->psw.mask, env->psw.addr, cc_name(env->cc_op));
target-s390x/translate.c:                    env->psw.mask, env->psw.addr, env->cc_op);
target-s390x/translate.c:/* CC value is in env->cc_op */
target-s390x/translate.c:        /* env->cc_op already is the cc value */
target-s390x/translate.c:            /* i.e. env->cc = 0 */
target-s390x/translate.c:        if (unlikely(!QTAILQ_EMPTY(&env->breakpoints))) {
target-s390x/translate.c:            QTAILQ_FOREACH(bp, &env->breakpoints, entry) {
target-s390x/translate.c:        if (env->singlestep_enabled) {
target-s390x/translate.c:             && num_insns < max_insns && !env->singlestep_enabled
target-s390x/translate.c:    env->psw.addr = gen_opc_pc[pc_pos];
target-s390x/translate.c:        env->cc_op = cc_op;
target-sh4/op_helper.c:    env->exception_index = index;
target-sh4/op_helper.c:    env->exception_index = EXCP_DEBUG;
target-sh4/op_helper.c:    env->halted = 1;
target-sh4/op_helper.c:    env->in_sleep = 1;
target-sh4/op_helper.c:    env->exception_index = EXCP_HLT;
target-sh4/op_helper.c:    env->pc = next_pc;
target-sh4/op_helper.c:    env->tra = tra << 2;
target-sh4/op_helper.c:	*(env->movcal_backup_tail) = r;
target-sh4/op_helper.c:	env->movcal_backup_tail = &(r->next);
target-sh4/op_helper.c:    memory_content *current = env->movcal_backup;
target-sh4/op_helper.c:	env->movcal_backup = current = next;
target-sh4/op_helper.c:	    env->movcal_backup_tail = &(env->movcal_backup);
target-sh4/op_helper.c:    memory_content **current = &(env->movcal_backup);
target-sh4/op_helper.c:		env->movcal_backup_tail = current;
target-sh4/op_helper.c:    arg1 = tmp1 + (env->sr & 1);
target-sh4/op_helper.c:	env->sr |= SR_T;
target-sh4/op_helper.c:	env->sr &= ~SR_T;
target-sh4/op_helper.c:	env->sr |= SR_T;
target-sh4/op_helper.c:	    env->sr |= SR_T;
target-sh4/op_helper.c:	    env->sr &= ~SR_T;
target-sh4/op_helper.c:	env->sr &= ~SR_T;
target-sh4/op_helper.c:#define T (env->sr & SR_T)
target-sh4/op_helper.c:#define Q (env->sr & SR_Q ? 1 : 0)
target-sh4/op_helper.c:#define M (env->sr & SR_M ? 1 : 0)
target-sh4/op_helper.c:#define SETT env->sr |= SR_T
target-sh4/op_helper.c:#define CLRT env->sr &= ~SR_T
target-sh4/op_helper.c:#define SETQ env->sr |= SR_Q
target-sh4/op_helper.c:#define CLRQ env->sr &= ~SR_Q
target-sh4/op_helper.c:#define SETM env->sr |= SR_M
target-sh4/op_helper.c:#define CLRM env->sr &= ~SR_M
target-sh4/op_helper.c:    res = ((uint64_t) env->mach << 32) | env->macl;
target-sh4/op_helper.c:    env->mach = (res >> 32) & 0xffffffff;
target-sh4/op_helper.c:    env->macl = res & 0xffffffff;
target-sh4/op_helper.c:    if (env->sr & SR_S) {
target-sh4/op_helper.c:	    env->mach |= 0xffff0000;
target-sh4/op_helper.c:	    env->mach &= 0x00007fff;
target-sh4/op_helper.c:    res = ((uint64_t) env->mach << 32) | env->macl;
target-sh4/op_helper.c:    env->mach = (res >> 32) & 0xffffffff;
target-sh4/op_helper.c:    env->macl = res & 0xffffffff;
target-sh4/op_helper.c:    if (env->sr & SR_S) {
target-sh4/op_helper.c:	    env->mach = 1;
target-sh4/op_helper.c:	    env->macl = 0x80000000;
target-sh4/op_helper.c:	    env->mach = 1;
target-sh4/op_helper.c:	    env->macl = 0x7fffffff;
target-sh4/op_helper.c:    arg1 = tmp1 - (env->sr & SR_T);
target-sh4/op_helper.c:	env->sr |= SR_T;
target-sh4/op_helper.c:	env->sr &= ~SR_T;
target-sh4/op_helper.c:	env->sr |= SR_T;
target-sh4/op_helper.c:	    env->sr |= SR_T;
target-sh4/op_helper.c:	    env->sr &= ~SR_T;
target-sh4/op_helper.c:	env->sr &= ~SR_T;
target-sh4/op_helper.c:    env->sr |= SR_T;
target-sh4/op_helper.c:    env->sr &= ~SR_T;
target-sh4/op_helper.c:    env->fpscr = val & FPSCR_MASK;
target-sh4/op_helper.c:	set_float_rounding_mode(float_round_to_zero, &env->fp_status);
target-sh4/op_helper.c:	set_float_rounding_mode(float_round_nearest_even, &env->fp_status);
target-sh4/op_helper.c:    set_flush_to_zero((val & FPSCR_DN) != 0, &env->fp_status);
target-sh4/op_helper.c:    xcpt = get_float_exception_flags(&env->fp_status);
target-sh4/op_helper.c:    env->fpscr &= ~FPSCR_FLAG_MASK;
target-sh4/op_helper.c:            env->fpscr |= FPSCR_FLAG_V;
target-sh4/op_helper.c:            env->fpscr |= FPSCR_FLAG_Z;
target-sh4/op_helper.c:            env->fpscr |= FPSCR_FLAG_O;
target-sh4/op_helper.c:            env->fpscr |= FPSCR_FLAG_U;
target-sh4/op_helper.c:            env->fpscr |= FPSCR_FLAG_I;
target-sh4/op_helper.c:        env->fpscr |= (env->fpscr & FPSCR_FLAG_MASK)
target-sh4/op_helper.c:        cause = (env->fpscr & FPSCR_CAUSE_MASK) >> FPSCR_CAUSE_SHIFT;
target-sh4/op_helper.c:        enable = (env->fpscr & FPSCR_ENABLE_MASK) >> FPSCR_ENABLE_SHIFT;
target-sh4/op_helper.c:            env->exception_index = 0x120;
target-sh4/op_helper.c:    set_float_exception_flags(0, &env->fp_status);
target-sh4/op_helper.c:    t0 = float32_add(t0, t1, &env->fp_status);
target-sh4/op_helper.c:    set_float_exception_flags(0, &env->fp_status);
target-sh4/op_helper.c:    t0 = float64_add(t0, t1, &env->fp_status);
target-sh4/op_helper.c:    set_float_exception_flags(0, &env->fp_status);
target-sh4/op_helper.c:    relation = float32_compare(t0, t1, &env->fp_status);
target-sh4/op_helper.c:    set_float_exception_flags(0, &env->fp_status);
target-sh4/op_helper.c:    relation = float64_compare(t0, t1, &env->fp_status);
target-sh4/op_helper.c:    set_float_exception_flags(0, &env->fp_status);
target-sh4/op_helper.c:    relation = float32_compare(t0, t1, &env->fp_status);
target-sh4/op_helper.c:    set_float_exception_flags(0, &env->fp_status);
target-sh4/op_helper.c:    relation = float64_compare(t0, t1, &env->fp_status);
target-sh4/op_helper.c:    set_float_exception_flags(0, &env->fp_status);
target-sh4/op_helper.c:    ret = float32_to_float64(t0, &env->fp_status);
target-sh4/op_helper.c:    set_float_exception_flags(0, &env->fp_status);
target-sh4/op_helper.c:    ret = float64_to_float32(t0, &env->fp_status);
target-sh4/op_helper.c:    set_float_exception_flags(0, &env->fp_status);
target-sh4/op_helper.c:    t0 = float32_div(t0, t1, &env->fp_status);
target-sh4/op_helper.c:    set_float_exception_flags(0, &env->fp_status);
target-sh4/op_helper.c:    t0 = float64_div(t0, t1, &env->fp_status);
target-sh4/op_helper.c:    set_float_exception_flags(0, &env->fp_status);
target-sh4/op_helper.c:    ret = int32_to_float32(t0, &env->fp_status);
target-sh4/op_helper.c:    set_float_exception_flags(0, &env->fp_status);
target-sh4/op_helper.c:    ret = int32_to_float64(t0, &env->fp_status);
target-sh4/op_helper.c:    set_float_exception_flags(0, &env->fp_status);
target-sh4/op_helper.c:    t0 = float32_mul(t0, t1, &env->fp_status);
target-sh4/op_helper.c:    t0 = float32_add(t0, t2, &env->fp_status);
target-sh4/op_helper.c:    set_float_exception_flags(0, &env->fp_status);
target-sh4/op_helper.c:    t0 = float32_mul(t0, t1, &env->fp_status);
target-sh4/op_helper.c:    set_float_exception_flags(0, &env->fp_status);
target-sh4/op_helper.c:    t0 = float64_mul(t0, t1, &env->fp_status);
target-sh4/op_helper.c:    set_float_exception_flags(0, &env->fp_status);
target-sh4/op_helper.c:    t0 = float32_sqrt(t0, &env->fp_status);
target-sh4/op_helper.c:    set_float_exception_flags(0, &env->fp_status);
target-sh4/op_helper.c:    t0 = float64_sqrt(t0, &env->fp_status);
target-sh4/op_helper.c:    set_float_exception_flags(0, &env->fp_status);
target-sh4/op_helper.c:    t0 = float32_sub(t0, t1, &env->fp_status);
target-sh4/op_helper.c:    set_float_exception_flags(0, &env->fp_status);
target-sh4/op_helper.c:    t0 = float64_sub(t0, t1, &env->fp_status);
target-sh4/op_helper.c:    set_float_exception_flags(0, &env->fp_status);
target-sh4/op_helper.c:    ret = float32_to_int32_round_to_zero(t0, &env->fp_status);
target-sh4/op_helper.c:    set_float_exception_flags(0, &env->fp_status);
target-sh4/op_helper.c:    ret = float64_to_int32_round_to_zero(t0, &env->fp_status);
target-sh4/op_helper.c:    bank = (env->sr & FPSCR_FR) ? 16 : 0;
target-sh4/op_helper.c:    set_float_exception_flags(0, &env->fp_status);
target-sh4/op_helper.c:        p = float32_mul(env->fregs[bank + m + i],
target-sh4/op_helper.c:                        env->fregs[bank + n + i],
target-sh4/op_helper.c:                        &env->fp_status);
target-sh4/op_helper.c:        r = float32_add(r, p, &env->fp_status);
target-sh4/op_helper.c:    env->fregs[bank + n + 3] = r;
target-sh4/op_helper.c:    bank_matrix = (env->sr & FPSCR_FR) ? 0 : 16;
target-sh4/op_helper.c:    bank_vector = (env->sr & FPSCR_FR) ? 16 : 0;
target-sh4/op_helper.c:    set_float_exception_flags(0, &env->fp_status);
target-sh4/op_helper.c:            p = float32_mul(env->fregs[bank_matrix + 4 * j + i],
target-sh4/op_helper.c:                            env->fregs[bank_vector + j],
target-sh4/op_helper.c:                            &env->fp_status);
target-sh4/op_helper.c:            r[i] = float32_add(r[i], p, &env->fp_status);
target-sh4/op_helper.c:        env->fregs[bank_vector + i] = r[i];
target-sh4/cpu.h:  env->gbr = newtls;
target-sh4/cpu.h:    return (env->sr & SR_MD) == 0 ? 1 : 0;
target-sh4/cpu.h:        env->gregs[15] = newsp;
target-sh4/cpu.h:    env->gregs[0] = 0;
target-sh4/cpu.h:    *pc = env->pc;
target-sh4/cpu.h:    *flags = (env->flags & (DELAY_SLOT | DELAY_SLOT_CONDITIONAL
target-sh4/cpu.h:            | (env->fpscr & (FPSCR_FR | FPSCR_SZ | FPSCR_PR))  /* Bits 19-21 */
target-sh4/cpu.h:            | (env->sr & (SR_MD | SR_RB))                      /* Bits 29-30 */
target-sh4/cpu.h:            | (env->sr & SR_FD)                                /* Bit 15 */
target-sh4/cpu.h:            | (env->movcal_backup ? TB_FLAG_PENDING_MOVCA : 0); /* Bit 4 */
target-sh4/cpu.h:    return env->interrupt_request & CPU_INTERRUPT_HARD;
target-sh4/cpu.h:    env->pc = tb->pc;
target-sh4/cpu.h:    env->flags = tb->flags;
target-sh4/helper.c:  env->exception_index = -1;
target-sh4/helper.c:    env->tea = address;
target-sh4/helper.c:    env->exception_index = -1;
target-sh4/helper.c:        env->exception_index = 0x0a0;
target-sh4/helper.c:        env->exception_index = 0x0c0;
target-sh4/helper.c:        env->exception_index = 0x0a0;
target-sh4/helper.c:    int do_irq = env->interrupt_request & CPU_INTERRUPT_HARD;
target-sh4/helper.c:    int do_exp, irq_vector = env->exception_index;
target-sh4/helper.c:    do_exp = env->exception_index != -1;
target-sh4/helper.c:    do_irq = do_irq && (env->exception_index == -1);
target-sh4/helper.c:    if (env->sr & SR_BL) {
target-sh4/helper.c:        if (do_exp && env->exception_index != 0x1e0) {
target-sh4/helper.c:            env->exception_index = 0x000; /* masked exception -> reset */
target-sh4/helper.c:        if (do_irq && !env->in_sleep) {
target-sh4/helper.c:    env->in_sleep = 0;
target-sh4/helper.c:        irq_vector = sh_intc_get_pending_vector(env->intc_handle,
target-sh4/helper.c:						(env->sr >> 4) & 0xf);
target-sh4/helper.c:	switch (env->exception_index) {
target-sh4/helper.c:    env->ssr = env->sr;
target-sh4/helper.c:    env->spc = env->pc;
target-sh4/helper.c:    env->sgr = env->gregs[15];
target-sh4/helper.c:    env->sr |= SR_BL | SR_MD | SR_RB;
target-sh4/helper.c:    if (env->flags & (DELAY_SLOT | DELAY_SLOT_CONDITIONAL)) {
target-sh4/helper.c:	env->spc -= 2;
target-sh4/helper.c:	env->flags &= ~(DELAY_SLOT | DELAY_SLOT_CONDITIONAL | DELAY_SLOT_TRUE);
target-sh4/helper.c:    if (env->flags & DELAY_SLOT_CLEARME)
target-sh4/helper.c:        env->flags = 0;
target-sh4/helper.c:        env->expevt = env->exception_index;
target-sh4/helper.c:        switch (env->exception_index) {
target-sh4/helper.c:            env->sr &= ~SR_FD;
target-sh4/helper.c:            env->sr |= 0xf << 4; /* IMASK */
target-sh4/helper.c:            env->pc = 0xa0000000;
target-sh4/helper.c:            env->pc = env->vbr + 0x400;
target-sh4/helper.c:            env->spc += 2; /* special case for TRAPA */
target-sh4/helper.c:            env->pc = env->vbr + 0x100;
target-sh4/helper.c:        env->intevt = irq_vector;
target-sh4/helper.c:        env->pc = env->vbr + 0x600;
target-sh4/helper.c:    env->mmucr &= (and_mask << 24) | 0x00ffffff;
target-sh4/helper.c:    env->mmucr |= (or_mask << 24);
target-sh4/helper.c:    if ((env->mmucr & 0xe0000000) == 0xe0000000)
target-sh4/helper.c:    if ((env->mmucr & 0x98000000) == 0x18000000)
target-sh4/helper.c:    if ((env->mmucr & 0x54000000) == 0x04000000)
target-sh4/helper.c:    if ((env->mmucr & 0x2c000000) == 0x00000000)
target-sh4/helper.c:    asid = env->pteh & 0xff;
target-sh4/helper.c:    urb = ((env->mmucr) >> 18) & 0x3f;
target-sh4/helper.c:    urc = ((env->mmucr) >> 10) & 0x3f;
target-sh4/helper.c:    env->mmucr = (env->mmucr & 0xffff03ff) | (urc << 10);
target-sh4/helper.c:    ientry = &env->itlb[itlb];
target-sh4/helper.c:    *ientry = env->utlb[utlb];
target-sh4/helper.c:    e = find_tlb_entry(env, address, env->itlb, ITLB_SIZE, use_asid);
target-sh4/helper.c:    return find_tlb_entry(env, address, env->utlb, UTLB_SIZE, use_asid);
target-sh4/helper.c:    use_asid = (env->mmucr & MMUCR_SV) == 0 || (env->sr & SR_MD) == 0;
target-sh4/helper.c:	    matching = &env->itlb[n];
target-sh4/helper.c:	    if (!(env->sr & SR_MD) && !(matching->pr & 2))
target-sh4/helper.c:                matching = &env->itlb[n];
target-sh4/helper.c:                if (!(env->sr & SR_MD) && !(matching->pr & 2)) {
target-sh4/helper.c:	    matching = &env->utlb[n];
target-sh4/helper.c:            if (!(env->sr & SR_MD) && !(matching->pr & 2)) {
target-sh4/helper.c:	if (!(env->sr & SR_MD)
target-sh4/helper.c:    if (!(env->mmucr & MMUCR_AT)) {
target-sh4/helper.c:	env->tea = address;
target-sh4/helper.c:	    env->pteh = (env->pteh & PTEH_ASID_MASK) |
target-sh4/helper.c:	    env->exception_index = 0x040;
target-sh4/helper.c:	    env->exception_index = 0x140;
target-sh4/helper.c:	    env->exception_index = 0x0a0;
target-sh4/helper.c:	    env->exception_index = 0x060;
target-sh4/helper.c:	    env->exception_index = 0x080;
target-sh4/helper.c:	    env->exception_index = 0x0a0;
target-sh4/helper.c:	    env->exception_index = 0x0c0;
target-sh4/helper.c:	    env->exception_index = 0x0e0;
target-sh4/helper.c:	    env->exception_index = 0x100;
target-sh4/helper.c:    int n = cpu_mmucr_urc(env->mmucr);
target-sh4/helper.c:    tlb_t * entry = &env->utlb[n];
target-sh4/helper.c:    entry->asid = (uint8_t)cpu_pteh_asid(env->pteh);
target-sh4/helper.c:    entry->vpn  = cpu_pteh_vpn(env->pteh);
target-sh4/helper.c:    entry->v    = (uint8_t)cpu_ptel_v(env->ptel);
target-sh4/helper.c:    entry->ppn  = cpu_ptel_ppn(env->ptel);
target-sh4/helper.c:    entry->sz   = (uint8_t)cpu_ptel_sz(env->ptel);
target-sh4/helper.c:    entry->sh   = (uint8_t)cpu_ptel_sh(env->ptel);
target-sh4/helper.c:    entry->c    = (uint8_t)cpu_ptel_c(env->ptel);
target-sh4/helper.c:    entry->pr   = (uint8_t)cpu_ptel_pr(env->ptel);
target-sh4/helper.c:    entry->d    = (uint8_t)cpu_ptel_d(env->ptel);
target-sh4/helper.c:    entry->wt   = (uint8_t)cpu_ptel_wt(env->ptel);
target-sh4/helper.c:    entry->sa   = (uint8_t)cpu_ptea_sa(env->ptea);
target-sh4/helper.c:    entry->tc   = (uint8_t)cpu_ptea_tc(env->ptea);
target-sh4/helper.c:    int use_asid = (env->mmucr & MMUCR_SV) == 0 || (env->sr & SR_MD) == 0;
target-sh4/helper.c:    if (env->sr & SR_MD) {
target-sh4/helper.c:    if (!(env->ccr & 1))
target-sh4/helper.c:    if (env->mmucr & MMUCR_AT)
target-sh4/helper.c:    n = find_tlb_entry(env, addr, env->itlb, ITLB_SIZE, use_asid);
target-sh4/helper.c:        return env->itlb[n].c;
target-sh4/helper.c:    n = find_tlb_entry(env, addr, env->utlb, UTLB_SIZE, use_asid);
target-sh4/helper.c:        return env->utlb[n].c;
target-sh4/cpu.c:        qemu_log("CPU Reset (CPU %d)\n", env->cpu_index);
target-sh4/cpu.c:    env->pc = 0xA0000000;
target-sh4/cpu.c:    env->fpscr = FPSCR_PR; /* value for userspace according to the kernel */
target-sh4/cpu.c:    set_float_rounding_mode(float_round_nearest_even, &env->fp_status); /* ?! */
target-sh4/cpu.c:    env->sr = SR_MD | SR_RB | SR_BL | SR_I3 | SR_I2 | SR_I1 | SR_I0;
target-sh4/cpu.c:    env->fpscr = FPSCR_DN | FPSCR_RM_ZERO; /* CPU reset value according to SH4 manual */
target-sh4/cpu.c:    set_float_rounding_mode(float_round_to_zero, &env->fp_status);
target-sh4/cpu.c:    set_flush_to_zero(1, &env->fp_status);
target-sh4/cpu.c:    set_default_nan_mode(1, &env->fp_status);
target-sh4/cpu.c:    env->movcal_backup_tail = &(env->movcal_backup);
target-sh4/translate.c:		env->pc, env->sr, env->pr, env->fpscr);
target-sh4/translate.c:		env->spc, env->ssr, env->gbr, env->vbr);
target-sh4/translate.c:		env->sgr, env->dbr, env->delayed_pc, env->fpul);
target-sh4/translate.c:		    i, env->gregs[i], i + 1, env->gregs[i + 1],
target-sh4/translate.c:		    i + 2, env->gregs[i + 2], i + 3, env->gregs[i + 3]);
target-sh4/translate.c:    if (env->flags & DELAY_SLOT) {
target-sh4/translate.c:		    env->delayed_pc);
target-sh4/translate.c:    } else if (env->flags & DELAY_SLOT_CONDITIONAL) {
target-sh4/translate.c:		    env->delayed_pc);
target-sh4/translate.c:    env->pvr = def->pvr;
target-sh4/translate.c:    env->prr = def->prr;
target-sh4/translate.c:    env->cvr = def->cvr;
target-sh4/translate.c:    env->id = def->id;
target-sh4/translate.c:    env->features = def->features;
target-sh4/translate.c:    env->cpu_model_str = cpu_model;
target-sh4/translate.c:    ctx.sr = env->sr;
target-sh4/translate.c:    ctx.fpscr = env->fpscr;
target-sh4/translate.c:    ctx.memidx = (env->sr & SR_MD) == 0 ? 1 : 0;
target-sh4/translate.c:    ctx.singlestep_enabled = env->singlestep_enabled;
target-sh4/translate.c:    ctx.features = env->features;
target-sh4/translate.c:        if (unlikely(!QTAILQ_EMPTY(&env->breakpoints))) {
target-sh4/translate.c:            QTAILQ_FOREACH(bp, &env->breakpoints, entry) {
target-sh4/translate.c:	if (env->singlestep_enabled)
target-sh4/translate.c:    if (env->singlestep_enabled) {
target-sh4/translate.c:    env->pc = gen_opc_pc[pc_pos];
target-sh4/translate.c:    env->flags = gen_opc_hflags[pc_pos];
target-sparc/cc_helper.c:    return env->psr & PSR_ICC;
target-sparc/cc_helper.c:    return env->psr & PSR_CARRY;
target-sparc/cc_helper.c:    return env->xcc & PSR_ICC;
target-sparc/cc_helper.c:    return env->xcc & PSR_CARRY;
target-sparc/cc_helper.c:    env->psr = new_psr;
target-sparc/cc_helper.c:    env->xcc = new_psr;
target-sparc/mmu_helper.c:    if ((env->mmuregs[0] & MMU_E) == 0) { /* MMU disabled */
target-sparc/mmu_helper.c:        if (rw == 2 && (env->mmuregs[0] & env->def->mmu_bm)) {
target-sparc/mmu_helper.c:            *physical = env->prom_addr | (address & 0x7ffffULL);
target-sparc/mmu_helper.c:    pde_ptr = (env->mmuregs[1] << 4) + (env->mmuregs[2] << 2);
target-sparc/mmu_helper.c:    if (error_code && !((env->mmuregs[0] & MMU_NF) && is_user)) {
target-sparc/mmu_helper.c:    if (env->mmuregs[3]) { /* Fault status register */
target-sparc/mmu_helper.c:        env->mmuregs[3] = 1; /* overflow (not read before another fault) */
target-sparc/mmu_helper.c:    env->mmuregs[3] |= (access_index << 5) | error_code | 2;
target-sparc/mmu_helper.c:    env->mmuregs[4] = address; /* Fault address register */
target-sparc/mmu_helper.c:    if ((env->mmuregs[0] & MMU_NF) || env->psret == 0)  {
target-sparc/mmu_helper.c:            env->exception_index = TT_TFAULT;
target-sparc/mmu_helper.c:            env->exception_index = TT_DFAULT;
target-sparc/mmu_helper.c:    pde_ptr = (target_phys_addr_t)(env->mmuregs[1] << 4) +
target-sparc/mmu_helper.c:        (env->mmuregs[2] << 2);
target-sparc/mmu_helper.c:    pde_ptr = (env->mmuregs[1] << 4) + (env->mmuregs[2] << 2);
target-sparc/mmu_helper.c:                   (target_phys_addr_t)env->mmuregs[1] << 4, env->mmuregs[2]);
target-sparc/mmu_helper.c:    int cwp = env->cwp;
target-sparc/mmu_helper.c:        for (i = 0; i < env->nwindows; i++) {
target-sparc/mmu_helper.c:            target_ulong fp = env->regbase[cwp * 16 + 22];
target-sparc/mmu_helper.c:            if (env->wim & (1 << cwp)) {
target-sparc/mmu_helper.c:                u.v = cpu_to_be32(env->regbase[reg]);
target-sparc/mmu_helper.c:    if ((env->lsu & DMMU_E) == 0) { /* DMMU disabled */
target-sparc/mmu_helper.c:        context = env->dmmu.mmu_primary_context & 0x1fff;
target-sparc/mmu_helper.c:        context = env->dmmu.mmu_secondary_context & 0x1fff;
target-sparc/mmu_helper.c:        if (ultrasparc_tag_match(&env->dtlb[i], address, context, physical)) {
target-sparc/mmu_helper.c:            if (TTE_IS_PRIV(env->dtlb[i].tte) && is_user) {
target-sparc/mmu_helper.c:                trace_mmu_helper_dfault(address, context, mmu_idx, env->tl);
target-sparc/mmu_helper.c:                if (TTE_IS_SIDEEFFECT(env->dtlb[i].tte)) {
target-sparc/mmu_helper.c:                if (TTE_IS_NFO(env->dtlb[i].tte)) {
target-sparc/mmu_helper.c:                env->exception_index = TT_DFAULT;
target-sparc/mmu_helper.c:            } else if (!TTE_IS_W_OK(env->dtlb[i].tte) && (rw == 1)) {
target-sparc/mmu_helper.c:                env->exception_index = TT_DPROT;
target-sparc/mmu_helper.c:                trace_mmu_helper_dprot(address, context, mmu_idx, env->tl);
target-sparc/mmu_helper.c:                if (TTE_IS_W_OK(env->dtlb[i].tte)) {
target-sparc/mmu_helper.c:                TTE_SET_USED(env->dtlb[i].tte);
target-sparc/mmu_helper.c:            if (env->dmmu.sfsr & SFSR_VALID_BIT) { /* Fault status register */
target-sparc/mmu_helper.c:            if (env->pstate & PS_PRIV) {
target-sparc/mmu_helper.c:            env->dmmu.sfsr = sfsr | SFSR_VALID_BIT;
target-sparc/mmu_helper.c:            env->dmmu.sfar = address; /* Fault address register */
target-sparc/mmu_helper.c:            env->dmmu.tag_access = (address & ~0x1fffULL) | context;
target-sparc/mmu_helper.c:    env->dmmu.tag_access = (address & ~0x1fffULL) | context;
target-sparc/mmu_helper.c:    env->exception_index = TT_DMISS;
target-sparc/mmu_helper.c:    if ((env->lsu & IMMU_E) == 0 || (env->pstate & PS_RED) != 0) {
target-sparc/mmu_helper.c:    if (env->tl == 0) {
target-sparc/mmu_helper.c:        context = env->dmmu.mmu_primary_context & 0x1fff;
target-sparc/mmu_helper.c:        if (ultrasparc_tag_match(&env->itlb[i],
target-sparc/mmu_helper.c:            if (TTE_IS_PRIV(env->itlb[i].tte) && is_user) {
target-sparc/mmu_helper.c:                if (env->immu.sfsr & SFSR_VALID_BIT) {
target-sparc/mmu_helper.c:                    env->immu.sfsr = SFSR_OW_BIT; /* overflow (not read before
target-sparc/mmu_helper.c:                    env->immu.sfsr = 0;
target-sparc/mmu_helper.c:                if (env->pstate & PS_PRIV) {
target-sparc/mmu_helper.c:                    env->immu.sfsr |= SFSR_PR_BIT;
target-sparc/mmu_helper.c:                if (env->tl > 0) {
target-sparc/mmu_helper.c:                    env->immu.sfsr |= SFSR_CT_NUCLEUS;
target-sparc/mmu_helper.c:                env->immu.sfsr |= SFSR_FT_PRIV_BIT | SFSR_VALID_BIT;
target-sparc/mmu_helper.c:                env->exception_index = TT_TFAULT;
target-sparc/mmu_helper.c:                env->immu.tag_access = (address & ~0x1fffULL) | context;
target-sparc/mmu_helper.c:            TTE_SET_USED(env->itlb[i].tte);
target-sparc/mmu_helper.c:    env->immu.tag_access = (address & ~0x1fffULL) | context;
target-sparc/mmu_helper.c:    env->exception_index = TT_TMISS;
target-sparc/mmu_helper.c:    if (env->tl > 0 && mmu_idx != MMU_NUCLEUS_IDX) {
target-sparc/mmu_helper.c:            trace_mmu_helper_get_phys_addr_code(env->tl, mmu_idx,
target-sparc/mmu_helper.c:                                                env->dmmu.mmu_primary_context,
target-sparc/mmu_helper.c:                                                env->dmmu.mmu_secondary_context,
target-sparc/mmu_helper.c:            trace_mmu_helper_get_phys_addr_data(env->tl, mmu_idx,
target-sparc/mmu_helper.c:                                                env->dmmu.mmu_primary_context,
target-sparc/mmu_helper.c:                                                env->dmmu.mmu_secondary_context,
target-sparc/mmu_helper.c:        trace_mmu_helper_mmu_fault(address, paddr, mmu_idx, env->tl,
target-sparc/mmu_helper.c:                                   env->dmmu.mmu_primary_context,
target-sparc/mmu_helper.c:                                   env->dmmu.mmu_secondary_context);
target-sparc/mmu_helper.c:                   env->dmmu.mmu_primary_context,
target-sparc/mmu_helper.c:                   env->dmmu.mmu_secondary_context);
target-sparc/mmu_helper.c:    if ((env->lsu & DMMU_E) == 0) {
target-sparc/mmu_helper.c:            switch (TTE_PGSIZE(env->dtlb[i].tte)) {
target-sparc/mmu_helper.c:            if (TTE_IS_VALID(env->dtlb[i].tte)) {
target-sparc/mmu_helper.c:                               env->dtlb[i].tag & (uint64_t)~0x1fffULL,
target-sparc/mmu_helper.c:                               TTE_PA(env->dtlb[i].tte),
target-sparc/mmu_helper.c:                               TTE_IS_PRIV(env->dtlb[i].tte) ? "priv" : "user",
target-sparc/mmu_helper.c:                               TTE_IS_W_OK(env->dtlb[i].tte) ? "RW" : "RO",
target-sparc/mmu_helper.c:                               TTE_IS_LOCKED(env->dtlb[i].tte) ?
target-sparc/mmu_helper.c:                               env->dtlb[i].tag & (uint64_t)0x1fffULL,
target-sparc/mmu_helper.c:                               TTE_IS_GLOBAL(env->dtlb[i].tte) ?
target-sparc/mmu_helper.c:    if ((env->lsu & IMMU_E) == 0) {
target-sparc/mmu_helper.c:            switch (TTE_PGSIZE(env->itlb[i].tte)) {
target-sparc/mmu_helper.c:            if (TTE_IS_VALID(env->itlb[i].tte)) {
target-sparc/mmu_helper.c:                               env->itlb[i].tag & (uint64_t)~0x1fffULL,
target-sparc/mmu_helper.c:                               TTE_PA(env->itlb[i].tte),
target-sparc/mmu_helper.c:                               TTE_IS_PRIV(env->itlb[i].tte) ? "priv" : "user",
target-sparc/mmu_helper.c:                               TTE_IS_LOCKED(env->itlb[i].tte) ?
target-sparc/mmu_helper.c:                               env->itlb[i].tag & (uint64_t)0x1fffULL,
target-sparc/mmu_helper.c:                               TTE_IS_GLOBAL(env->itlb[i].tte) ?
target-sparc/fop_helper.c:#define QT0 (env->qt0)
target-sparc/fop_helper.c:#define QT1 (env->qt1)
target-sparc/fop_helper.c:    status = get_float_exception_flags(&env->fp_status);
target-sparc/fop_helper.c:            env->fsr |= FSR_NVC;
target-sparc/fop_helper.c:            env->fsr |= FSR_OFC;
target-sparc/fop_helper.c:            env->fsr |= FSR_UFC;
target-sparc/fop_helper.c:            env->fsr |= FSR_DZC;
target-sparc/fop_helper.c:            env->fsr |= FSR_NXC;
target-sparc/fop_helper.c:        if ((env->fsr & FSR_CEXC_MASK) & ((env->fsr & FSR_TEM_MASK) >> 23)) {
target-sparc/fop_helper.c:            env->fsr |= FSR_FTT_IEEE_EXCP;
target-sparc/fop_helper.c:            env->fsr |= (env->fsr & FSR_CEXC_MASK) << 5;
target-sparc/fop_helper.c:    set_float_exception_flags(0, &env->fp_status);
target-sparc/fop_helper.c:        ret = float32_ ## name (src1, src2, &env->fp_status);   \
target-sparc/fop_helper.c:        ret = float64_ ## name (src1, src2, &env->fp_status);   \
target-sparc/fop_helper.c:        QT0 = float128_ ## name (QT0, QT1, &env->fp_status);    \
target-sparc/fop_helper.c:    ret = float64_mul(float32_to_float64(src1, &env->fp_status),
target-sparc/fop_helper.c:                      float32_to_float64(src2, &env->fp_status),
target-sparc/fop_helper.c:                      &env->fp_status);
target-sparc/fop_helper.c:    QT0 = float128_mul(float64_to_float128(src1, &env->fp_status),
target-sparc/fop_helper.c:                       float64_to_float128(src2, &env->fp_status),
target-sparc/fop_helper.c:                       &env->fp_status);
target-sparc/fop_helper.c:    ret = int32_to_float32(src, &env->fp_status);
target-sparc/fop_helper.c:    return int32_to_float64(src, &env->fp_status);
target-sparc/fop_helper.c:    QT0 = int32_to_float128(src, &env->fp_status);
target-sparc/fop_helper.c:    ret = int64_to_float32(src, &env->fp_status);
target-sparc/fop_helper.c:    ret = int64_to_float64(src, &env->fp_status);
target-sparc/fop_helper.c:    QT0 = int64_to_float128(src, &env->fp_status);
target-sparc/fop_helper.c:    ret = float64_to_float32(src, &env->fp_status);
target-sparc/fop_helper.c:    ret = float32_to_float64(src, &env->fp_status);
target-sparc/fop_helper.c:    ret = float128_to_float32(QT1, &env->fp_status);
target-sparc/fop_helper.c:    QT0 = float32_to_float128(src, &env->fp_status);
target-sparc/fop_helper.c:    ret = float128_to_float64(QT1, &env->fp_status);
target-sparc/fop_helper.c:    QT0 = float64_to_float128(src, &env->fp_status);
target-sparc/fop_helper.c:    ret = float32_to_int32_round_to_zero(src, &env->fp_status);
target-sparc/fop_helper.c:    ret = float64_to_int32_round_to_zero(src, &env->fp_status);
target-sparc/fop_helper.c:    ret = float128_to_int32_round_to_zero(QT1, &env->fp_status);
target-sparc/fop_helper.c:    ret = float32_to_int64_round_to_zero(src, &env->fp_status);
target-sparc/fop_helper.c:    ret = float64_to_int64_round_to_zero(src, &env->fp_status);
target-sparc/fop_helper.c:    ret = float128_to_int64_round_to_zero(QT1, &env->fp_status);
target-sparc/fop_helper.c:    ret = float32_sqrt(src, &env->fp_status);
target-sparc/fop_helper.c:    ret = float64_sqrt(src, &env->fp_status);
target-sparc/fop_helper.c:    QT0 = float128_sqrt(QT1, &env->fp_status);
target-sparc/fop_helper.c:        env->fsr &= FSR_FTT_NMASK;                                      \
target-sparc/fop_helper.c:            (env->fsr & FSR_NVM)) {                                     \
target-sparc/fop_helper.c:            env->fsr |= FSR_NVC;                                        \
target-sparc/fop_helper.c:            env->fsr |= FSR_FTT_IEEE_EXCP;                              \
target-sparc/fop_helper.c:        switch (glue(size, _compare) (reg1, reg2, &env->fp_status)) {   \
target-sparc/fop_helper.c:            if ((env->fsr & FSR_NVM)) {                                 \
target-sparc/fop_helper.c:                env->fsr |= FSR_NVC;                                    \
target-sparc/fop_helper.c:                env->fsr |= FSR_FTT_IEEE_EXCP;                          \
target-sparc/fop_helper.c:                env->fsr &= ~((FSR_FCC1 | FSR_FCC0) << FS);             \
target-sparc/fop_helper.c:                env->fsr |= (FSR_FCC1 | FSR_FCC0) << FS;                \
target-sparc/fop_helper.c:                env->fsr |= FSR_NVA;                                    \
target-sparc/fop_helper.c:            env->fsr &= ~((FSR_FCC1 | FSR_FCC0) << FS);                 \
target-sparc/fop_helper.c:            env->fsr |= FSR_FCC0 << FS;                                 \
target-sparc/fop_helper.c:            env->fsr &= ~((FSR_FCC1 | FSR_FCC0) << FS);                 \
target-sparc/fop_helper.c:            env->fsr |= FSR_FCC1 << FS;                                 \
target-sparc/fop_helper.c:            env->fsr &= ~((FSR_FCC1 | FSR_FCC0) << FS);                 \
target-sparc/fop_helper.c:        env->fsr &= FSR_FTT_NMASK;                                      \
target-sparc/fop_helper.c:            (env->fsr & FSR_NVM)) {                                     \
target-sparc/fop_helper.c:            env->fsr |= FSR_NVC;                                        \
target-sparc/fop_helper.c:            env->fsr |= FSR_FTT_IEEE_EXCP;                              \
target-sparc/fop_helper.c:        switch (glue(size, _compare) (src1, src2, &env->fp_status)) {   \
target-sparc/fop_helper.c:            if ((env->fsr & FSR_NVM)) {                                 \
target-sparc/fop_helper.c:                env->fsr |= FSR_NVC;                                    \
target-sparc/fop_helper.c:                env->fsr |= FSR_FTT_IEEE_EXCP;                          \
target-sparc/fop_helper.c:                env->fsr &= ~((FSR_FCC1 | FSR_FCC0) << FS);             \
target-sparc/fop_helper.c:                env->fsr |= (FSR_FCC1 | FSR_FCC0) << FS;                \
target-sparc/fop_helper.c:                env->fsr |= FSR_NVA;                                    \
target-sparc/fop_helper.c:            env->fsr &= ~((FSR_FCC1 | FSR_FCC0) << FS);                 \
target-sparc/fop_helper.c:            env->fsr |= FSR_FCC0 << FS;                                 \
target-sparc/fop_helper.c:            env->fsr &= ~((FSR_FCC1 | FSR_FCC0) << FS);                 \
target-sparc/fop_helper.c:            env->fsr |= FSR_FCC1 << FS;                                 \
target-sparc/fop_helper.c:            env->fsr &= ~((FSR_FCC1 | FSR_FCC0) << FS);                 \
target-sparc/fop_helper.c:    switch (env->fsr & FSR_RD_MASK) {
target-sparc/fop_helper.c:    set_float_rounding_mode(rnd_mode, &env->fp_status);
target-sparc/fop_helper.c:    env->fsr = (new_fsr & FSR_LDFSR_MASK) | (env->fsr & FSR_LDFSR_OLDMASK);
target-sparc/fop_helper.c:    env->fsr = (new_fsr & FSR_LDXFSR_MASK) | (env->fsr & FSR_LDXFSR_OLDMASK);
target-sparc/cpu.h:#define CC_SRC (env->cc_src)
target-sparc/cpu.h:#define CC_SRC2 (env->cc_src2)
target-sparc/cpu.h:#define CC_DST (env->cc_dst)
target-sparc/cpu.h:#define CC_OP  (env->cc_op)
target-sparc/cpu.h:        env->regwptr[22] = newsp;
target-sparc/cpu.h:    env->regwptr[0] = 0;
target-sparc/cpu.h:    *pc = env->pc;
target-sparc/cpu.h:    *cs_base = env->npc;
target-sparc/cpu.h:    *flags = (env->pstate & PS_PRIV)               /* 2 */
target-sparc/cpu.h:        | ((env->lsu & (DMMU_E | IMMU_E)) >> 2)    /* 1, 0 */
target-sparc/cpu.h:        | ((env->tl & 0xff) << 8)
target-sparc/cpu.h:        | (env->dmmu.mmu_primary_context << 16);   /* 16... */
target-sparc/cpu.h:    if (env->pstate & PS_AM) {
target-sparc/cpu.h:    if ((env->def->features & CPU_FEATURE_FLOAT) && (env->pstate & PS_PEF)
target-sparc/cpu.h:        && (env->fprs & FPRS_FEF)) {
target-sparc/cpu.h:    *flags = env->psrs;
target-sparc/cpu.h:    if ((env->def->features & CPU_FEATURE_FLOAT) && env->psref) {
target-sparc/cpu.h:    env->pc = tb->pc;
target-sparc/cpu.h:    env->npc = tb->cs_base;
target-sparc/helper.c:    env->exception_index = tt;
target-sparc/helper.c:    env->exception_index = EXCP_DEBUG;
target-sparc/helper.c:    x0 = (a & 0xffffffff) | ((int64_t) (env->y) << 32);
target-sparc/helper.c:        env->cc_dst = x0;
target-sparc/helper.c:        env->cc_src2 = overflow;
target-sparc/helper.c:        env->cc_op = CC_OP_DIV;
target-sparc/helper.c:    x0 = (a & 0xffffffff) | ((int64_t) (env->y) << 32);
target-sparc/helper.c:        env->cc_dst = x0;
target-sparc/helper.c:        env->cc_src2 = overflow;
target-sparc/helper.c:        env->cc_op = CC_OP_DIV;
target-sparc/ldst_helper.c:#define QT0 (env->qt0)
target-sparc/ldst_helper.c:#define QT1 (env->qt1)
target-sparc/ldst_helper.c:               "\n", addr, env->pc);
target-sparc/ldst_helper.c:           env->mxccdata[0], env->mxccdata[1],
target-sparc/ldst_helper.c:           env->mxccdata[2], env->mxccdata[3]);
target-sparc/ldst_helper.c:           env->mxccregs[0], env->mxccregs[1],
target-sparc/ldst_helper.c:           env->mxccregs[2], env->mxccregs[3],
target-sparc/ldst_helper.c:           env->mxccregs[4], env->mxccregs[5],
target-sparc/ldst_helper.c:           env->mxccregs[6], env->mxccregs[7]);
target-sparc/ldst_helper.c:        env->cache_control = val;
target-sparc/ldst_helper.c:        ret = env->cache_control;
target-sparc/ldst_helper.c:            if (env->def->features & CPU_FEATURE_CACHE_CTRL) {
target-sparc/ldst_helper.c:                ret = env->mxccregs[3];
target-sparc/ldst_helper.c:                ret = env->mxccregs[3];
target-sparc/ldst_helper.c:                ret = env->mxccregs[5];
target-sparc/ldst_helper.c:                ret = env->mxccregs[7];
target-sparc/ldst_helper.c:            ret = env->mmuregs[reg];
target-sparc/ldst_helper.c:                env->mmuregs[3] = 0;
target-sparc/ldst_helper.c:                ret = env->mmuregs[3];
target-sparc/ldst_helper.c:                ret = env->mmuregs[4];
target-sparc/ldst_helper.c:                ret = env->mmubpregs[reg];
target-sparc/ldst_helper.c:                ret = env->mmubpregs[reg];
target-sparc/ldst_helper.c:                ret = env->mmubpregs[reg];
target-sparc/ldst_helper.c:                ret = env->mmubpregs[reg];
target-sparc/ldst_helper.c:                env->mmubpregs[reg] = 0ULL;
target-sparc/ldst_helper.c:        ret = env->mmubpctrv;
target-sparc/ldst_helper.c:        ret = env->mmubpctrc;
target-sparc/ldst_helper.c:        ret = env->mmubpctrs;
target-sparc/ldst_helper.c:        ret = env->mmubpaction;
target-sparc/ldst_helper.c:            if (env->def->features & CPU_FEATURE_CACHE_CTRL) {
target-sparc/ldst_helper.c:                env->mxccdata[0] = val;
target-sparc/ldst_helper.c:                env->mxccdata[1] = val;
target-sparc/ldst_helper.c:                env->mxccdata[2] = val;
target-sparc/ldst_helper.c:                env->mxccdata[3] = val;
target-sparc/ldst_helper.c:                env->mxccregs[0] = val;
target-sparc/ldst_helper.c:            env->mxccdata[0] = ldq_phys((env->mxccregs[0] & 0xffffffffULL) +
target-sparc/ldst_helper.c:            env->mxccdata[1] = ldq_phys((env->mxccregs[0] & 0xffffffffULL) +
target-sparc/ldst_helper.c:            env->mxccdata[2] = ldq_phys((env->mxccregs[0] & 0xffffffffULL) +
target-sparc/ldst_helper.c:            env->mxccdata[3] = ldq_phys((env->mxccregs[0] & 0xffffffffULL) +
target-sparc/ldst_helper.c:                env->mxccregs[1] = val;
target-sparc/ldst_helper.c:            stq_phys((env->mxccregs[1] & 0xffffffffULL) +  0,
target-sparc/ldst_helper.c:                     env->mxccdata[0]);
target-sparc/ldst_helper.c:            stq_phys((env->mxccregs[1] & 0xffffffffULL) +  8,
target-sparc/ldst_helper.c:                     env->mxccdata[1]);
target-sparc/ldst_helper.c:            stq_phys((env->mxccregs[1] & 0xffffffffULL) + 16,
target-sparc/ldst_helper.c:                     env->mxccdata[2]);
target-sparc/ldst_helper.c:            stq_phys((env->mxccregs[1] & 0xffffffffULL) + 24,
target-sparc/ldst_helper.c:                     env->mxccdata[3]);
target-sparc/ldst_helper.c:                env->mxccregs[3] = val;
target-sparc/ldst_helper.c:                env->mxccregs[3] = (env->mxccregs[3] & 0xffffffff00000000ULL)
target-sparc/ldst_helper.c:                env->mxccregs[6] &= ~val;
target-sparc/ldst_helper.c:                env->mxccregs[7] = val;
target-sparc/ldst_helper.c:            oldreg = env->mmuregs[reg];
target-sparc/ldst_helper.c:                env->mmuregs[reg] = (env->mmuregs[reg] & 0xff000000) |
target-sparc/ldst_helper.c:                if ((oldreg & (MMU_E | MMU_NF | env->def->mmu_bm)) !=
target-sparc/ldst_helper.c:                    (env->mmuregs[reg] & (MMU_E | MMU_NF | env->def->mmu_bm))) {
target-sparc/ldst_helper.c:                env->mmuregs[reg] = val & env->def->mmu_ctpr_mask;
target-sparc/ldst_helper.c:                env->mmuregs[reg] = val & env->def->mmu_cxr_mask;
target-sparc/ldst_helper.c:                if (oldreg != env->mmuregs[reg]) {
target-sparc/ldst_helper.c:                env->mmuregs[reg] = val & env->def->mmu_trcr_mask;
target-sparc/ldst_helper.c:                env->mmuregs[3] = val & env->def->mmu_sfsr_mask;
target-sparc/ldst_helper.c:                env->mmuregs[4] = val;
target-sparc/ldst_helper.c:                env->mmuregs[reg] = val;
target-sparc/ldst_helper.c:            if (oldreg != env->mmuregs[reg]) {
target-sparc/ldst_helper.c:                            reg, oldreg, env->mmuregs[reg]);
target-sparc/ldst_helper.c:                env->mmubpregs[reg] = (val & 0xfffffffffULL);
target-sparc/ldst_helper.c:                env->mmubpregs[reg] = (val & 0xfffffffffULL);
target-sparc/ldst_helper.c:                env->mmubpregs[reg] = (val & 0x7fULL);
target-sparc/ldst_helper.c:                env->mmubpregs[reg] = (val & 0xfULL);
target-sparc/ldst_helper.c:                        env->mmuregs[reg]);
target-sparc/ldst_helper.c:        env->mmubpctrv = val & 0xffffffff;
target-sparc/ldst_helper.c:        env->mmubpctrc = val & 0x3;
target-sparc/ldst_helper.c:        env->mmubpctrs = val & 0x3;
target-sparc/ldst_helper.c:        env->mmubpaction = val & 0x1fff;
target-sparc/ldst_helper.c:    if ((asi < 0x80 && (env->pstate & PS_PRIV) == 0)
target-sparc/ldst_helper.c:            && !(env->hpstate & HS_PRIV))) {
target-sparc/ldst_helper.c:        if (env->pstate & PS_PRIV) {
target-sparc/ldst_helper.c:            /* env->exception_index is set in get_physical_address_data(). */
target-sparc/ldst_helper.c:            helper_raise_exception(env, env->exception_index);
target-sparc/ldst_helper.c:        if ((asi & 0x80) && (env->pstate & PS_PRIV)) {
target-sparc/ldst_helper.c:        ret = env->lsu;
target-sparc/ldst_helper.c:                ret = ultrasparc_tag_target(env->immu.tag_access);
target-sparc/ldst_helper.c:                ret = env->immuregs[reg];
target-sparc/ldst_helper.c:            /* env->immuregs[5] holds I-MMU TSB register value
target-sparc/ldst_helper.c:               env->immuregs[6] holds I-MMU Tag Access register value */
target-sparc/ldst_helper.c:            ret = ultrasparc_tsb_pointer(env->immu.tsb, env->immu.tag_access,
target-sparc/ldst_helper.c:            /* env->immuregs[5] holds I-MMU TSB register value
target-sparc/ldst_helper.c:               env->immuregs[6] holds I-MMU Tag Access register value */
target-sparc/ldst_helper.c:            ret = ultrasparc_tsb_pointer(env->immu.tsb, env->immu.tag_access,
target-sparc/ldst_helper.c:            ret = env->itlb[reg].tte;
target-sparc/ldst_helper.c:            ret = env->itlb[reg].tag;
target-sparc/ldst_helper.c:                ret = ultrasparc_tag_target(env->dmmu.tag_access);
target-sparc/ldst_helper.c:                ret = env->dmmuregs[reg];
target-sparc/ldst_helper.c:            /* env->dmmuregs[5] holds D-MMU TSB register value
target-sparc/ldst_helper.c:               env->dmmuregs[6] holds D-MMU Tag Access register value */
target-sparc/ldst_helper.c:            ret = ultrasparc_tsb_pointer(env->dmmu.tsb, env->dmmu.tag_access,
target-sparc/ldst_helper.c:            /* env->dmmuregs[5] holds D-MMU TSB register value
target-sparc/ldst_helper.c:               env->dmmuregs[6] holds D-MMU Tag Access register value */
target-sparc/ldst_helper.c:            ret = ultrasparc_tsb_pointer(env->dmmu.tsb, env->dmmu.tag_access,
target-sparc/ldst_helper.c:            ret = env->dtlb[reg].tte;
target-sparc/ldst_helper.c:            ret = env->dtlb[reg].tag;
target-sparc/ldst_helper.c:        ret = env->ivec_status;
target-sparc/ldst_helper.c:                ret = env->ivec_data[reg];
target-sparc/ldst_helper.c:    if ((asi < 0x80 && (env->pstate & PS_PRIV) == 0)
target-sparc/ldst_helper.c:            && !(env->hpstate & HS_PRIV))) {
target-sparc/ldst_helper.c:        if ((asi & 0x80) && (env->pstate & PS_PRIV)) {
target-sparc/ldst_helper.c:            oldreg = env->lsu;
target-sparc/ldst_helper.c:            env->lsu = val & (DMMU_E | IMMU_E);
target-sparc/ldst_helper.c:            if (oldreg != env->lsu) {
target-sparc/ldst_helper.c:                            oldreg, env->lsu);
target-sparc/ldst_helper.c:            oldreg = env->immuregs[reg];
target-sparc/ldst_helper.c:                env->immu.sfsr = val;
target-sparc/ldst_helper.c:                            PRIx64 "\n", env->immu.tsb, val);
target-sparc/ldst_helper.c:                env->immu.tsb = val;
target-sparc/ldst_helper.c:                env->immu.tag_access = val;
target-sparc/ldst_helper.c:            if (oldreg != env->immuregs[reg]) {
target-sparc/ldst_helper.c:                            PRIx64 "\n", reg, oldreg, env->immuregs[reg]);
target-sparc/ldst_helper.c:        replace_tlb_1bit_lru(env->itlb, env->immu.tag_access, val, "immu", env);
target-sparc/ldst_helper.c:            replace_tlb_entry(&env->itlb[i], env->immu.tag_access, val, env);
target-sparc/ldst_helper.c:        demap_tlb(env->itlb, addr, "immu", env);
target-sparc/ldst_helper.c:            oldreg = env->dmmuregs[reg];
target-sparc/ldst_helper.c:                    env->dmmu.sfar = 0;
target-sparc/ldst_helper.c:                env->dmmu.sfsr = val;
target-sparc/ldst_helper.c:                env->dmmu.mmu_primary_context = val;
target-sparc/ldst_helper.c:                env->dmmu.mmu_secondary_context = val;
target-sparc/ldst_helper.c:                            PRIx64 "\n", env->dmmu.tsb, val);
target-sparc/ldst_helper.c:                env->dmmu.tsb = val;
target-sparc/ldst_helper.c:                env->dmmu.tag_access = val;
target-sparc/ldst_helper.c:                env->dmmuregs[reg] = val;
target-sparc/ldst_helper.c:            if (oldreg != env->dmmuregs[reg]) {
target-sparc/ldst_helper.c:                            PRIx64 "\n", reg, oldreg, env->dmmuregs[reg]);
target-sparc/ldst_helper.c:        replace_tlb_1bit_lru(env->dtlb, env->dmmu.tag_access, val, "dmmu", env);
target-sparc/ldst_helper.c:            replace_tlb_entry(&env->dtlb[i], env->dmmu.tag_access, val, env);
target-sparc/ldst_helper.c:        demap_tlb(env->dtlb, addr, "dmmu", env);
target-sparc/ldst_helper.c:        env->ivec_status = val & 0x20;
target-sparc/ldst_helper.c:    if ((asi < 0x80 && (env->pstate & PS_PRIV) == 0)
target-sparc/ldst_helper.c:            && !(env->hpstate & HS_PRIV))) {
target-sparc/ldst_helper.c:            env->gregs[1] = cpu_ldq_nucleus(env, addr + 8);
target-sparc/ldst_helper.c:                bswap64s(&env->gregs[1]);
target-sparc/ldst_helper.c:            env->gregs[rd] = cpu_ldq_nucleus(env, addr);
target-sparc/ldst_helper.c:            env->gregs[rd + 1] = cpu_ldq_nucleus(env, addr + 8);
target-sparc/ldst_helper.c:                bswap64s(&env->gregs[rd]);
target-sparc/ldst_helper.c:                bswap64s(&env->gregs[rd + 1]);
target-sparc/ldst_helper.c:            env->regwptr[rd] = cpu_ldq_nucleus(env, addr);
target-sparc/ldst_helper.c:            env->regwptr[rd + 1] = cpu_ldq_nucleus(env, addr + 8);
target-sparc/ldst_helper.c:                bswap64s(&env->regwptr[rd]);
target-sparc/ldst_helper.c:                bswap64s(&env->regwptr[rd + 1]);
target-sparc/ldst_helper.c:            env->gregs[1] = helper_ld_asi(env, addr + 4, asi, 4, 0);
target-sparc/ldst_helper.c:            env->gregs[rd] = helper_ld_asi(env, addr, asi, 4, 0);
target-sparc/ldst_helper.c:            env->gregs[rd + 1] = helper_ld_asi(env, addr + 4, asi, 4, 0);
target-sparc/ldst_helper.c:            env->regwptr[rd] = helper_ld_asi(env, addr, asi, 4, 0);
target-sparc/ldst_helper.c:            env->regwptr[rd + 1] = helper_ld_asi(env, addr + 4, asi, 4, 0);
target-sparc/ldst_helper.c:            env->fpr[rd / 2].ll = helper_ld_asi(env, addr, asi & 0x8f, 8, 0);
target-sparc/ldst_helper.c:            env->fpr[rd / 2].ll = helper_ld_asi(env, addr, asi & 0x19, 8, 0);
target-sparc/ldst_helper.c:            env->fpr[rd / 2].l.lower = val;
target-sparc/ldst_helper.c:            env->fpr[rd / 2].l.upper = val;
target-sparc/ldst_helper.c:        env->fpr[rd / 2].ll = helper_ld_asi(env, addr, asi, size, 0);
target-sparc/ldst_helper.c:        env->fpr[rd / 2].ll = helper_ld_asi(env, addr, asi, 8, 0);
target-sparc/ldst_helper.c:        env->fpr[rd / 2 + 1].ll = helper_ld_asi(env, addr + 8, asi, 8, 0);
target-sparc/ldst_helper.c:            helper_st_asi(env, addr, env->fpr[rd / 2].ll, asi & 0x8f, 8);
target-sparc/ldst_helper.c:            helper_st_asi(env, addr, env->fpr[rd / 2].ll, asi & 0x19, 8);
target-sparc/ldst_helper.c:            val = env->fpr[rd / 2].l.lower;
target-sparc/ldst_helper.c:            val = env->fpr[rd / 2].l.upper;
target-sparc/ldst_helper.c:        helper_st_asi(env, addr, env->fpr[rd / 2].ll, asi, size);
target-sparc/ldst_helper.c:        helper_st_asi(env, addr, env->fpr[rd / 2].ll, asi, 8);
target-sparc/ldst_helper.c:        helper_st_asi(env, addr + 8, env->fpr[rd / 2 + 1].ll, asi, 8);
target-sparc/ldst_helper.c:               size == 1 ? "" : "s", addr, is_asi, env->pc);
target-sparc/ldst_helper.c:               size == 1 ? "" : "s", addr, env->pc);
target-sparc/ldst_helper.c:    fault_type = (env->mmuregs[3] & 0x1c) >> 2;
target-sparc/ldst_helper.c:        env->mmuregs[3] = 0; /* Fault status register */
target-sparc/ldst_helper.c:            env->mmuregs[3] |= 1 << 16;
target-sparc/ldst_helper.c:        if (env->psrs) {
target-sparc/ldst_helper.c:            env->mmuregs[3] |= 1 << 5;
target-sparc/ldst_helper.c:            env->mmuregs[3] |= 1 << 6;
target-sparc/ldst_helper.c:            env->mmuregs[3] |= 1 << 7;
target-sparc/ldst_helper.c:        env->mmuregs[3] |= (5 << 2) | 2;
target-sparc/ldst_helper.c:            env->mmuregs[4] = addr; /* Fault address register */
target-sparc/ldst_helper.c:    if (fault_type == ((env->mmuregs[3] & 0x1c)) >> 2) {
target-sparc/ldst_helper.c:        env->mmuregs[3] |= 1;
target-sparc/ldst_helper.c:    if ((env->mmuregs[0] & MMU_E) && !(env->mmuregs[0] & MMU_NF)) {
target-sparc/ldst_helper.c:    if (env->mmuregs[0] & MMU_NF) {
target-sparc/ldst_helper.c:           "\n", addr, env->pc);
target-sparc/ldst_helper.c:           "\n", addr, env->pc);
target-sparc/cpu.c:        qemu_log("CPU Reset (CPU %d)\n", env->cpu_index);
target-sparc/cpu.c:    env->cwp = 0;
target-sparc/cpu.c:    env->wim = 1;
target-sparc/cpu.c:    env->regwptr = env->regbase + (env->cwp * 16);
target-sparc/cpu.c:    env->cleanwin = env->nwindows - 2;
target-sparc/cpu.c:    env->cansave = env->nwindows - 2;
target-sparc/cpu.c:    env->pstate = PS_RMO | PS_PEF | PS_IE;
target-sparc/cpu.c:    env->asi = 0x82; /* Primary no-fault */
target-sparc/cpu.c:    env->psret = 0;
target-sparc/cpu.c:    env->psrs = 1;
target-sparc/cpu.c:    env->psrps = 1;
target-sparc/cpu.c:    env->pstate = PS_PRIV|PS_RED|PS_PEF|PS_AG;
target-sparc/cpu.c:    env->hpstate = cpu_has_hypervisor(env) ? HS_PRIV : 0;
target-sparc/cpu.c:    env->tl = env->maxtl;
target-sparc/cpu.c:    env->lsu = 0;
target-sparc/cpu.c:    env->mmuregs[0] &= ~(MMU_E | MMU_NF);
target-sparc/cpu.c:    env->mmuregs[0] |= env->def->mmu_bm;
target-sparc/cpu.c:    env->pc = 0;
target-sparc/cpu.c:    env->npc = env->pc + 4;
target-sparc/cpu.c:    env->cache_control = 0;
target-sparc/cpu.c:    env->def = g_new0(sparc_def_t, 1);
target-sparc/cpu.c:    memcpy(env->def, def, sizeof(*def));
target-sparc/cpu.c:    if ((env->def->features & CPU_FEATURE_FLOAT)) {
target-sparc/cpu.c:        env->def->features |= CPU_FEATURE_FLOAT128;
target-sparc/cpu.c:    env->cpu_model_str = cpu_model;
target-sparc/cpu.c:    env->version = def->iu_version;
target-sparc/cpu.c:    env->fsr = def->fpu_version;
target-sparc/cpu.c:    env->nwindows = def->nwindows;
target-sparc/cpu.c:    env->mmuregs[0] |= def->mmu_version;
target-sparc/cpu.c:    env->mxccregs[7] |= def->mxcc_version;
target-sparc/cpu.c:    env->mmu_version = def->mmu_version;
target-sparc/cpu.c:    env->maxtl = def->maxtl;
target-sparc/cpu.c:    env->version |= def->maxtl << 8;
target-sparc/cpu.c:    env->version |= def->nwindows - 1;
target-sparc/cpu.c:    env->mxccregs[7] = ((cpu + 8) & 0xf) << 24;
target-sparc/cpu.c:    cpu_fprintf(f, "pc: " TARGET_FMT_lx "  npc: " TARGET_FMT_lx "\n", env->pc,
target-sparc/cpu.c:                env->npc);
target-sparc/cpu.c:        cpu_fprintf(f, " " TARGET_FMT_lx, env->gregs[i]);
target-sparc/cpu.c:            cpu_fprintf(f, TARGET_FMT_lx " ", env->regwptr[i + x * 8]);
target-sparc/cpu.c:        cpu_fprintf(f, " %016" PRIx64, env->fpr[i].ll);
target-sparc/cpu.c:    cpu_fprintf(f, "pstate: %08x ccr: %02x (icc: ", env->pstate,
target-sparc/cpu.c:    cpu_fprintf(f, ") asi: %02x tl: %d pil: %x\n", env->asi, env->tl,
target-sparc/cpu.c:                env->psrpil);
target-sparc/cpu.c:                env->cansave, env->canrestore, env->otherwin, env->wstate,
target-sparc/cpu.c:                env->cleanwin, env->nwindows - 1 - env->cwp);
target-sparc/cpu.c:                TARGET_FMT_lx "\n", env->fsr, env->y, env->fprs);
target-sparc/cpu.c:    cpu_fprintf(f, " SPE: %c%c%c) wim: %08x\n", env->psrs ? 'S' : '-',
target-sparc/cpu.c:                env->psrps ? 'P' : '-', env->psret ? 'E' : '-',
target-sparc/cpu.c:                env->wim);
target-sparc/cpu.c:                env->fsr, env->y);
target-sparc/cpu.c:    g_free(env->def);
target-sparc/int64_helper.c:    int intno = env->exception_index;
target-sparc/int64_helper.c:                env->pc,
target-sparc/int64_helper.c:                env->npc, env->regwptr[6]);
target-sparc/int64_helper.c:            ptr = (uint8_t *)env->pc;
target-sparc/int64_helper.c:    if (env->tl >= env->maxtl) {
target-sparc/int64_helper.c:                  " Error state", env->exception_index, env->tl, env->maxtl);
target-sparc/int64_helper.c:    if (env->tl < env->maxtl - 1) {
target-sparc/int64_helper.c:        env->tl++;
target-sparc/int64_helper.c:        env->pstate |= PS_RED;
target-sparc/int64_helper.c:        if (env->tl < env->maxtl) {
target-sparc/int64_helper.c:            env->tl++;
target-sparc/int64_helper.c:        ((env->asi & 0xff) << 24) | ((env->pstate & 0xf3f) << 8) |
target-sparc/int64_helper.c:    tsptr->tpc = env->pc;
target-sparc/int64_helper.c:    tsptr->tnpc = env->npc;
target-sparc/int64_helper.c:        cpu_set_cwp(env, cpu_cwp_dec(env, env->cwp - 1));
target-sparc/int64_helper.c:        cpu_set_cwp(env, cpu_cwp_dec(env, env->cwp - env->cansave - 2));
target-sparc/int64_helper.c:        cpu_set_cwp(env, cpu_cwp_inc(env, env->cwp + 1));
target-sparc/int64_helper.c:    env->tbr &= ~0x7fffULL;
target-sparc/int64_helper.c:    env->tbr |= ((env->tl > 1) ? 1 << 14 : 0) | (intno << 5);
target-sparc/int64_helper.c:    env->pc = env->tbr;
target-sparc/int64_helper.c:    env->npc = env->pc + 4;
target-sparc/int64_helper.c:    env->exception_index = -1;
target-sparc/int64_helper.c:    return &env->ts[env->tl & MAXTL_MASK];
target-sparc/int64_helper.c:    if (env->softint != value) {
target-sparc/int64_helper.c:        env->softint = value;
target-sparc/int64_helper.c:    if (do_modify_softint(env, env->softint | (uint32_t)value)) {
target-sparc/int64_helper.c:        trace_int_helper_set_softint(env->softint);
target-sparc/int64_helper.c:    if (do_modify_softint(env, env->softint & (uint32_t)~value)) {
target-sparc/int64_helper.c:        trace_int_helper_clear_softint(env->softint);
target-sparc/int64_helper.c:        trace_int_helper_write_softint(env->softint);
target-sparc/win_helper.c:    if (env->cwp == env->nwindows - 1) {
target-sparc/win_helper.c:        memcpy32(env->regbase, env->regbase + env->nwindows * 16);
target-sparc/win_helper.c:    env->cwp = new_cwp;
target-sparc/win_helper.c:    if (new_cwp == env->nwindows - 1) {
target-sparc/win_helper.c:        memcpy32(env->regbase + env->nwindows * 16, env->regbase);
target-sparc/win_helper.c:    env->regwptr = env->regbase + (new_cwp * 16);
target-sparc/win_helper.c:    return env->version | (env->psr & PSR_ICC) |
target-sparc/win_helper.c:        (env->psref ? PSR_EF : 0) |
target-sparc/win_helper.c:        (env->psrpil << 8) |
target-sparc/win_helper.c:        (env->psrs ? PSR_S : 0) |
target-sparc/win_helper.c:        (env->psrps ? PSR_PS : 0) |
target-sparc/win_helper.c:        (env->psret ? PSR_ET : 0) | env->cwp;
target-sparc/win_helper.c:    return env->psr & PSR_ICC;
target-sparc/win_helper.c:    env->psr = val & PSR_ICC;
target-sparc/win_helper.c:    env->psref = (val & PSR_EF) ? 1 : 0;
target-sparc/win_helper.c:    env->psrpil = (val & PSR_PIL) >> 8;
target-sparc/win_helper.c:    env->psrs = (val & PSR_S) ? 1 : 0;
target-sparc/win_helper.c:    env->psrps = (val & PSR_PS) ? 1 : 0;
target-sparc/win_helper.c:    env->psret = (val & PSR_ET) ? 1 : 0;
target-sparc/win_helper.c:    env->cc_op = CC_OP_FLAGS;
target-sparc/win_helper.c:    if (unlikely(cwp >= env->nwindows)) {
target-sparc/win_helper.c:        cwp -= env->nwindows;
target-sparc/win_helper.c:        cwp += env->nwindows;
target-sparc/win_helper.c:    if (env->psret == 1) {
target-sparc/win_helper.c:    env->psret = 1;
target-sparc/win_helper.c:    cwp = cpu_cwp_inc(env, env->cwp + 1) ;
target-sparc/win_helper.c:    if (env->wim & (1 << cwp)) {
target-sparc/win_helper.c:    env->psrs = env->psrps;
target-sparc/win_helper.c:    cwp = cpu_cwp_dec(env, env->cwp - 1);
target-sparc/win_helper.c:    if (env->wim & (1 << cwp)) {
target-sparc/win_helper.c:    cwp = cpu_cwp_inc(env, env->cwp + 1);
target-sparc/win_helper.c:    if (env->wim & (1 << cwp)) {
target-sparc/win_helper.c:    if ((new_psr & PSR_CWP) >= env->nwindows) {
target-sparc/win_helper.c:    cwp = cpu_cwp_dec(env, env->cwp - 1);
target-sparc/win_helper.c:    if (env->cansave == 0) {
target-sparc/win_helper.c:        helper_raise_exception(env, TT_SPILL | (env->otherwin != 0 ?
target-sparc/win_helper.c:                                                 ((env->wstate & 0x38) >> 1)) :
target-sparc/win_helper.c:                                                ((env->wstate & 0x7) << 2)));
target-sparc/win_helper.c:        if (env->cleanwin - env->canrestore == 0) {
target-sparc/win_helper.c:            env->cansave--;
target-sparc/win_helper.c:            env->canrestore++;
target-sparc/win_helper.c:    cwp = cpu_cwp_inc(env, env->cwp + 1);
target-sparc/win_helper.c:    if (env->canrestore == 0) {
target-sparc/win_helper.c:        helper_raise_exception(env, TT_FILL | (env->otherwin != 0 ?
target-sparc/win_helper.c:                                                ((env->wstate & 0x38) >> 1)) :
target-sparc/win_helper.c:                                               ((env->wstate & 0x7) << 2)));
target-sparc/win_helper.c:        env->cansave++;
target-sparc/win_helper.c:        env->canrestore--;
target-sparc/win_helper.c:    if (env->cansave != env->nwindows - 2) {
target-sparc/win_helper.c:        helper_raise_exception(env, TT_SPILL | (env->otherwin != 0 ?
target-sparc/win_helper.c:                                                 ((env->wstate & 0x38) >> 1)) :
target-sparc/win_helper.c:                                                ((env->wstate & 0x7) << 2)));
target-sparc/win_helper.c:    env->cansave++;
target-sparc/win_helper.c:    if (env->otherwin == 0) {
target-sparc/win_helper.c:        env->canrestore--;
target-sparc/win_helper.c:        env->otherwin--;
target-sparc/win_helper.c:    env->canrestore++;
target-sparc/win_helper.c:    if (env->cleanwin < env->nwindows - 1) {
target-sparc/win_helper.c:        env->cleanwin++;
target-sparc/win_helper.c:    if (env->otherwin == 0) {
target-sparc/win_helper.c:        env->cansave--;
target-sparc/win_helper.c:        env->otherwin--;
target-sparc/win_helper.c:    return ((env->xcc >> 20) << 4) | ((psr & PSR_ICC) >> 20);
target-sparc/win_helper.c:    env->xcc = (val >> 4) << 20;
target-sparc/win_helper.c:    env->psr = (val & 0xf) << 20;
target-sparc/win_helper.c:    return env->nwindows - 1 - env->cwp;
target-sparc/win_helper.c:    if (unlikely(cwp >= env->nwindows || cwp < 0)) {
target-sparc/win_helper.c:        cwp %= env->nwindows;
target-sparc/win_helper.c:    cpu_set_cwp(env, env->nwindows - 1 - cwp);
target-sparc/win_helper.c:        return env->bgregs;
target-sparc/win_helper.c:        return env->agregs;
target-sparc/win_helper.c:        return env->mgregs;
target-sparc/win_helper.c:        return env->igregs;
target-sparc/win_helper.c:    if (env->def->features & CPU_FEATURE_GL) {
target-sparc/win_helper.c:    pstate_regs = env->pstate & 0xc01;
target-sparc/win_helper.c:        memcpy32(dst, env->gregs);
target-sparc/win_helper.c:        memcpy32(env->gregs, src);
target-sparc/win_helper.c:    env->pstate = new_pstate;
target-sparc/win_helper.c:    trace_win_helper_wrpil(env->psrpil, (uint32_t)new_pil);
target-sparc/win_helper.c:    env->psrpil = new_pil;
target-sparc/win_helper.c:    env->pc = tsptr->tnpc;
target-sparc/win_helper.c:    env->npc = tsptr->tnpc + 4;
target-sparc/win_helper.c:    env->asi = (tsptr->tstate >> 24) & 0xff;
target-sparc/win_helper.c:    env->tl--;
target-sparc/win_helper.c:    trace_win_helper_done(env->tl);
target-sparc/win_helper.c:    env->pc = tsptr->tpc;
target-sparc/win_helper.c:    env->npc = tsptr->tnpc;
target-sparc/win_helper.c:    env->asi = (tsptr->tstate >> 24) & 0xff;
target-sparc/win_helper.c:    env->tl--;
target-sparc/win_helper.c:    trace_win_helper_retry(env->tl);
target-sparc/machine.c:    // if env->cwp == env->nwindows - 1, this will set the ins of the last
target-sparc/machine.c:    cpu_set_cwp(env, env->cwp);
target-sparc/machine.c:        qemu_put_betls(f, &env->gregs[i]);
target-sparc/machine.c:    qemu_put_be32s(f, &env->nwindows);
target-sparc/machine.c:    for(i = 0; i < env->nwindows * 16; i++)
target-sparc/machine.c:        qemu_put_betls(f, &env->regbase[i]);
target-sparc/machine.c:        qemu_put_be32(f, env->fpr[i].l.upper);
target-sparc/machine.c:        qemu_put_be32(f, env->fpr[i].l.lower);
target-sparc/machine.c:    qemu_put_betls(f, &env->pc);
target-sparc/machine.c:    qemu_put_betls(f, &env->npc);
target-sparc/machine.c:    qemu_put_betls(f, &env->y);
target-sparc/machine.c:    qemu_put_betls(f, &env->fsr);
target-sparc/machine.c:    qemu_put_betls(f, &env->tbr);
target-sparc/machine.c:    tmp = env->interrupt_index;
target-sparc/machine.c:    qemu_put_be32s(f, &env->pil_in);
target-sparc/machine.c:    qemu_put_be32s(f, &env->wim);
target-sparc/machine.c:        qemu_put_be32s(f, &env->mmuregs[i]);
target-sparc/machine.c:        qemu_put_be64s(f, &env->mxccdata[i]);
target-sparc/machine.c:        qemu_put_be64s(f, &env->mxccregs[i]);
target-sparc/machine.c:    qemu_put_be32s(f, &env->mmubpctrv);
target-sparc/machine.c:    qemu_put_be32s(f, &env->mmubpctrc);
target-sparc/machine.c:    qemu_put_be32s(f, &env->mmubpctrs);
target-sparc/machine.c:    qemu_put_be64s(f, &env->mmubpaction);
target-sparc/machine.c:        qemu_put_be64s(f, &env->mmubpregs[i]);
target-sparc/machine.c:    qemu_put_be64s(f, &env->lsu);
target-sparc/machine.c:        qemu_put_be64s(f, &env->immuregs[i]);
target-sparc/machine.c:        qemu_put_be64s(f, &env->dmmuregs[i]);
target-sparc/machine.c:        qemu_put_be64s(f, &env->itlb[i].tag);
target-sparc/machine.c:        qemu_put_be64s(f, &env->itlb[i].tte);
target-sparc/machine.c:        qemu_put_be64s(f, &env->dtlb[i].tag);
target-sparc/machine.c:        qemu_put_be64s(f, &env->dtlb[i].tte);
target-sparc/machine.c:    qemu_put_be32s(f, &env->mmu_version);
target-sparc/machine.c:        qemu_put_be64s(f, &env->ts[i].tpc);
target-sparc/machine.c:        qemu_put_be64s(f, &env->ts[i].tnpc);
target-sparc/machine.c:        qemu_put_be64s(f, &env->ts[i].tstate);
target-sparc/machine.c:        qemu_put_be32s(f, &env->ts[i].tt);
target-sparc/machine.c:    qemu_put_be32s(f, &env->xcc);
target-sparc/machine.c:    qemu_put_be32s(f, &env->asi);
target-sparc/machine.c:    qemu_put_be32s(f, &env->pstate);
target-sparc/machine.c:    qemu_put_be32s(f, &env->tl);
target-sparc/machine.c:    qemu_put_be32s(f, &env->cansave);
target-sparc/machine.c:    qemu_put_be32s(f, &env->canrestore);
target-sparc/machine.c:    qemu_put_be32s(f, &env->otherwin);
target-sparc/machine.c:    qemu_put_be32s(f, &env->wstate);
target-sparc/machine.c:    qemu_put_be32s(f, &env->cleanwin);
target-sparc/machine.c:        qemu_put_be64s(f, &env->agregs[i]);
target-sparc/machine.c:        qemu_put_be64s(f, &env->bgregs[i]);
target-sparc/machine.c:        qemu_put_be64s(f, &env->igregs[i]);
target-sparc/machine.c:        qemu_put_be64s(f, &env->mgregs[i]);
target-sparc/machine.c:    qemu_put_be64s(f, &env->fprs);
target-sparc/machine.c:    qemu_put_be64s(f, &env->tick_cmpr);
target-sparc/machine.c:    qemu_put_be64s(f, &env->stick_cmpr);
target-sparc/machine.c:    cpu_put_timer(f, env->tick);
target-sparc/machine.c:    cpu_put_timer(f, env->stick);
target-sparc/machine.c:    qemu_put_be64s(f, &env->gsr);
target-sparc/machine.c:    qemu_put_be32s(f, &env->gl);
target-sparc/machine.c:    qemu_put_be64s(f, &env->hpstate);
target-sparc/machine.c:        qemu_put_be64s(f, &env->htstate[i]);
target-sparc/machine.c:    qemu_put_be64s(f, &env->hintp);
target-sparc/machine.c:    qemu_put_be64s(f, &env->htba);
target-sparc/machine.c:    qemu_put_be64s(f, &env->hver);
target-sparc/machine.c:    qemu_put_be64s(f, &env->hstick_cmpr);
target-sparc/machine.c:    qemu_put_be64s(f, &env->ssr);
target-sparc/machine.c:    cpu_put_timer(f, env->hstick);
target-sparc/machine.c:        qemu_get_betls(f, &env->gregs[i]);
target-sparc/machine.c:    qemu_get_be32s(f, &env->nwindows);
target-sparc/machine.c:    for(i = 0; i < env->nwindows * 16; i++)
target-sparc/machine.c:        qemu_get_betls(f, &env->regbase[i]);
target-sparc/machine.c:        env->fpr[i].l.upper = qemu_get_be32(f);
target-sparc/machine.c:        env->fpr[i].l.lower = qemu_get_be32(f);
target-sparc/machine.c:    qemu_get_betls(f, &env->pc);
target-sparc/machine.c:    qemu_get_betls(f, &env->npc);
target-sparc/machine.c:    qemu_get_betls(f, &env->y);
target-sparc/machine.c:    env->cwp = 0; /* needed to ensure that the wrapping registers are
target-sparc/machine.c:    qemu_get_betls(f, &env->fsr);
target-sparc/machine.c:    qemu_get_betls(f, &env->tbr);
target-sparc/machine.c:    env->interrupt_index = tmp;
target-sparc/machine.c:    qemu_get_be32s(f, &env->pil_in);
target-sparc/machine.c:    qemu_get_be32s(f, &env->wim);
target-sparc/machine.c:        qemu_get_be32s(f, &env->mmuregs[i]);
target-sparc/machine.c:        qemu_get_be64s(f, &env->mxccdata[i]);
target-sparc/machine.c:        qemu_get_be64s(f, &env->mxccregs[i]);
target-sparc/machine.c:    qemu_get_be32s(f, &env->mmubpctrv);
target-sparc/machine.c:    qemu_get_be32s(f, &env->mmubpctrc);
target-sparc/machine.c:    qemu_get_be32s(f, &env->mmubpctrs);
target-sparc/machine.c:    qemu_get_be64s(f, &env->mmubpaction);
target-sparc/machine.c:        qemu_get_be64s(f, &env->mmubpregs[i]);
target-sparc/machine.c:    qemu_get_be64s(f, &env->lsu);
target-sparc/machine.c:        qemu_get_be64s(f, &env->immuregs[i]);
target-sparc/machine.c:        qemu_get_be64s(f, &env->dmmuregs[i]);
target-sparc/machine.c:        qemu_get_be64s(f, &env->itlb[i].tag);
target-sparc/machine.c:        qemu_get_be64s(f, &env->itlb[i].tte);
target-sparc/machine.c:        qemu_get_be64s(f, &env->dtlb[i].tag);
target-sparc/machine.c:        qemu_get_be64s(f, &env->dtlb[i].tte);
target-sparc/machine.c:    qemu_get_be32s(f, &env->mmu_version);
target-sparc/machine.c:        qemu_get_be64s(f, &env->ts[i].tpc);
target-sparc/machine.c:        qemu_get_be64s(f, &env->ts[i].tnpc);
target-sparc/machine.c:        qemu_get_be64s(f, &env->ts[i].tstate);
target-sparc/machine.c:        qemu_get_be32s(f, &env->ts[i].tt);
target-sparc/machine.c:    qemu_get_be32s(f, &env->xcc);
target-sparc/machine.c:    qemu_get_be32s(f, &env->asi);
target-sparc/machine.c:    qemu_get_be32s(f, &env->pstate);
target-sparc/machine.c:    qemu_get_be32s(f, &env->tl);
target-sparc/machine.c:    qemu_get_be32s(f, &env->cansave);
target-sparc/machine.c:    qemu_get_be32s(f, &env->canrestore);
target-sparc/machine.c:    qemu_get_be32s(f, &env->otherwin);
target-sparc/machine.c:    qemu_get_be32s(f, &env->wstate);
target-sparc/machine.c:    qemu_get_be32s(f, &env->cleanwin);
target-sparc/machine.c:        qemu_get_be64s(f, &env->agregs[i]);
target-sparc/machine.c:        qemu_get_be64s(f, &env->bgregs[i]);
target-sparc/machine.c:        qemu_get_be64s(f, &env->igregs[i]);
target-sparc/machine.c:        qemu_get_be64s(f, &env->mgregs[i]);
target-sparc/machine.c:    qemu_get_be64s(f, &env->fprs);
target-sparc/machine.c:    qemu_get_be64s(f, &env->tick_cmpr);
target-sparc/machine.c:    qemu_get_be64s(f, &env->stick_cmpr);
target-sparc/machine.c:    cpu_get_timer(f, env->tick);
target-sparc/machine.c:    cpu_get_timer(f, env->stick);
target-sparc/machine.c:    qemu_get_be64s(f, &env->gsr);
target-sparc/machine.c:    qemu_get_be32s(f, &env->gl);
target-sparc/machine.c:    qemu_get_be64s(f, &env->hpstate);
target-sparc/machine.c:        qemu_get_be64s(f, &env->htstate[i]);
target-sparc/machine.c:    qemu_get_be64s(f, &env->hintp);
target-sparc/machine.c:    qemu_get_be64s(f, &env->htba);
target-sparc/machine.c:    qemu_get_be64s(f, &env->hver);
target-sparc/machine.c:    qemu_get_be64s(f, &env->hstick_cmpr);
target-sparc/machine.c:    qemu_get_be64s(f, &env->ssr);
target-sparc/machine.c:    cpu_get_timer(f, env->hstick);
target-sparc/int32_helper.c:    int cwp, intno = env->exception_index;
target-sparc/int32_helper.c:                env->pc,
target-sparc/int32_helper.c:                env->npc, env->regwptr[6]);
target-sparc/int32_helper.c:            ptr = (uint8_t *)env->pc;
target-sparc/int32_helper.c:    if (env->psret == 0) {
target-sparc/int32_helper.c:        if (env->exception_index == 0x80 &&
target-sparc/int32_helper.c:            env->def->features & CPU_FEATURE_TA0_SHUTDOWN) {
target-sparc/int32_helper.c:                      env->exception_index);
target-sparc/int32_helper.c:    env->psret = 0;
target-sparc/int32_helper.c:    cwp = cpu_cwp_dec(env, env->cwp - 1);
target-sparc/int32_helper.c:    env->regwptr[9] = env->pc;
target-sparc/int32_helper.c:    env->regwptr[10] = env->npc;
target-sparc/int32_helper.c:    env->psrps = env->psrs;
target-sparc/int32_helper.c:    env->psrs = 1;
target-sparc/int32_helper.c:    env->tbr = (env->tbr & TBR_BASE_MASK) | (intno << 4);
target-sparc/int32_helper.c:    env->pc = env->tbr;
target-sparc/int32_helper.c:    env->npc = env->pc + 4;
target-sparc/int32_helper.c:    env->exception_index = -1;
target-sparc/int32_helper.c:    if ((intno & ~15) == TT_EXTINT && env->qemu_irq_ack != NULL) {
target-sparc/int32_helper.c:        env->qemu_irq_ack(env, env->irq_manager, intno);
target-sparc/int32_helper.c:    if (env->cache_control & CACHE_CTRL_IF) {
target-sparc/int32_helper.c:        state = env->cache_control & CACHE_STATE_MASK;
target-sparc/int32_helper.c:        env->cache_control &= ~CACHE_STATE_MASK;
target-sparc/int32_helper.c:        env->cache_control |= state;
target-sparc/int32_helper.c:    if (env->cache_control & CACHE_CTRL_DF) {
target-sparc/int32_helper.c:        state = (env->cache_control >> 2) & CACHE_STATE_MASK;
target-sparc/int32_helper.c:        env->cache_control &= ~(CACHE_STATE_MASK << 2);
target-sparc/int32_helper.c:        env->cache_control |= (state << 2);
target-sparc/translate.c:    if (!(env->y & 1))
target-sparc/translate.c:    // env->y = (b2 << 31) | (env->y >> 1);
target-sparc/translate.c:    /* load env->tl into r_tl */
target-sparc/translate.c:    /* calculate offset to current trap state from env->ts, reuse r_tl */
target-sparc/translate.c:    /* tsptr = env->ts[env->tl & MAXTL_MASK] */
target-sparc/translate.c:    dc->def = env->def;
target-sparc/translate.c:    dc->singlestep = (env->singlestep_enabled || singlestep);
target-sparc/translate.c:        if (unlikely(!QTAILQ_EMPTY(&env->breakpoints))) {
target-sparc/translate.c:            QTAILQ_FOREACH(bp, &env->breakpoints, entry) {
target-sparc/translate.c:    env->pc = gen_opc_pc[pc_pos];
target-sparc/translate.c:        if (env->cond) {
target-sparc/translate.c:            env->npc = gen_opc_jump_pc[0];
target-sparc/translate.c:            env->npc = gen_opc_jump_pc[1];
target-sparc/translate.c:        env->npc = npc;
target-unicore32/op_helper.c:    env->exception_index = excp;
target-unicore32/op_helper.c:    ZF = (env->ZF == 0);
target-unicore32/op_helper.c:    return env->uncached_asr | (env->NF & 0x80000000) | (ZF << 30) |
target-unicore32/op_helper.c:        (env->CF << 29) | ((env->VF & 0x80000000) >> 3);
target-unicore32/op_helper.c:        env->ZF = (~val) & ASR_Z;
target-unicore32/op_helper.c:        env->NF = val;
target-unicore32/op_helper.c:        env->CF = (val >> 29) & 1;
target-unicore32/op_helper.c:        env->VF = (val << 3) & 0x80000000;
target-unicore32/op_helper.c:    if ((env->uncached_asr ^ val) & mask & ASR_M) {
target-unicore32/op_helper.c:    env->uncached_asr = (env->uncached_asr & ~mask) | (val & mask);
target-unicore32/op_helper.c:        val = env->banked_r29[0];
target-unicore32/op_helper.c:        val = env->banked_r30[0];
target-unicore32/op_helper.c:        val = env->regs[regno];
target-unicore32/op_helper.c:        env->banked_r29[0] = val;
target-unicore32/op_helper.c:        env->banked_r30[0] = val;
target-unicore32/op_helper.c:        env->regs[regno] = val;
target-unicore32/op_helper.c:    env->NF = env->ZF = result;
target-unicore32/op_helper.c:    env->CF = result < a;
target-unicore32/op_helper.c:    env->VF = (a ^ b ^ -1) & (a ^ result);
target-unicore32/op_helper.c:    if (!env->CF) {
target-unicore32/op_helper.c:        env->CF = result < a;
target-unicore32/op_helper.c:        env->CF = result <= a;
target-unicore32/op_helper.c:    env->VF = (a ^ b ^ -1) & (a ^ result);
target-unicore32/op_helper.c:    env->NF = env->ZF = result;
target-unicore32/op_helper.c:    env->NF = env->ZF = result;
target-unicore32/op_helper.c:    env->CF = a >= b;
target-unicore32/op_helper.c:    env->VF = (a ^ b) & (a ^ result);
target-unicore32/op_helper.c:    if (!env->CF) {
target-unicore32/op_helper.c:        env->CF = a > b;
target-unicore32/op_helper.c:        env->CF = a >= b;
target-unicore32/op_helper.c:    env->VF = (a ^ b) & (a ^ result);
target-unicore32/op_helper.c:    env->NF = env->ZF = result;
target-unicore32/op_helper.c:            env->CF = x & 1;
target-unicore32/op_helper.c:            env->CF = 0;
target-unicore32/op_helper.c:        env->CF = (x >> (32 - shift)) & 1;
target-unicore32/op_helper.c:            env->CF = (x >> 31) & 1;
target-unicore32/op_helper.c:            env->CF = 0;
target-unicore32/op_helper.c:        env->CF = (x >> (shift - 1)) & 1;
target-unicore32/op_helper.c:        env->CF = (x >> 31) & 1;
target-unicore32/op_helper.c:        env->CF = (x >> (shift - 1)) & 1;
target-unicore32/op_helper.c:            env->CF = (x >> 31) & 1;
target-unicore32/op_helper.c:        env->CF = (x >> (shift - 1)) & 1;
target-unicore32/cpu.h:#define UC32_CPUID(env)                 (env->cp0.c0_cpuid)
target-unicore32/cpu.h:    return (env->uncached_asr & ASR_M) == ASR_MODE_USER ? 1 : 0;
target-unicore32/cpu.h:        env->regs[29] = newsp;
target-unicore32/cpu.h:    env->regs[0] = 0;
target-unicore32/cpu.h:    env->regs[16] = newtls;
target-unicore32/cpu.h:    env->regs[31] = tb->pc;
target-unicore32/cpu.h:    *pc = env->regs[31];
target-unicore32/cpu.h:    if ((env->uncached_asr & ASR_M) != ASR_MODE_USER) {
target-unicore32/cpu.h:    return env->interrupt_request &
target-unicore32/helper.c:    env->exception_index = -1;
target-unicore32/helper.c:    env->exception_index = UC32_EXCP_TRAP;
target-unicore32/helper.c:    env->cp0.c4_faultaddr = address;
target-unicore32/helper.c:    fpscr = (env->ucf64.xregs[UC32_UCF64_FPSCR] & UCF64_FPSCR_MASK);
target-unicore32/helper.c:    i = get_float_exception_flags(&env->ucf64.fp_status);
target-unicore32/helper.c:    changed = env->ucf64.xregs[UC32_UCF64_FPSCR];
target-unicore32/helper.c:    env->ucf64.xregs[UC32_UCF64_FPSCR] = (val & UCF64_FPSCR_MASK);
target-unicore32/helper.c:        set_float_rounding_mode(i, &env->ucf64.fp_status);
target-unicore32/helper.c:    set_float_exception_flags(i, &env->ucf64.fp_status);
target-unicore32/helper.c:    return float32_add(a, b, &env->ucf64.fp_status);
target-unicore32/helper.c:    return float64_add(a, b, &env->ucf64.fp_status);
target-unicore32/helper.c:    return float32_sub(a, b, &env->ucf64.fp_status);
target-unicore32/helper.c:    return float64_sub(a, b, &env->ucf64.fp_status);
target-unicore32/helper.c:    return float32_mul(a, b, &env->ucf64.fp_status);
target-unicore32/helper.c:    return float64_mul(a, b, &env->ucf64.fp_status);
target-unicore32/helper.c:    return float32_div(a, b, &env->ucf64.fp_status);
target-unicore32/helper.c:    return float64_div(a, b, &env->ucf64.fp_status);
target-unicore32/helper.c:    flag = float32_compare_quiet(a, b, &env->ucf64.fp_status);
target-unicore32/helper.c:    env->CF = 0;
target-unicore32/helper.c:            env->CF = 1;
target-unicore32/helper.c:            env->CF = 1;
target-unicore32/helper.c:            env->CF = 1;
target-unicore32/helper.c:            env->CF = 1;
target-unicore32/helper.c:            env->CF = 1;
target-unicore32/helper.c:            env->CF = 1;
target-unicore32/helper.c:            env->CF = 1;
target-unicore32/helper.c:    env->ucf64.xregs[UC32_UCF64_FPSCR] = (env->CF << 29)
target-unicore32/helper.c:                    | (env->ucf64.xregs[UC32_UCF64_FPSCR] & 0x0fffffff);
target-unicore32/helper.c:    flag = float64_compare_quiet(a, b, &env->ucf64.fp_status);
target-unicore32/helper.c:    env->CF = 0;
target-unicore32/helper.c:            env->CF = 1;
target-unicore32/helper.c:            env->CF = 1;
target-unicore32/helper.c:            env->CF = 1;
target-unicore32/helper.c:            env->CF = 1;
target-unicore32/helper.c:            env->CF = 1;
target-unicore32/helper.c:            env->CF = 1;
target-unicore32/helper.c:            env->CF = 1;
target-unicore32/helper.c:    env->ucf64.xregs[UC32_UCF64_FPSCR] = (env->CF << 29)
target-unicore32/helper.c:                    | (env->ucf64.xregs[UC32_UCF64_FPSCR] & 0x0fffffff);
target-unicore32/helper.c:    return int32_to_float32(ucf64_stoi(x), &env->ucf64.fp_status);
target-unicore32/helper.c:    return int32_to_float64(ucf64_stoi(x), &env->ucf64.fp_status);
target-unicore32/helper.c:    return ucf64_itos(float32_to_int32(x, &env->ucf64.fp_status));
target-unicore32/helper.c:    return ucf64_itos(float64_to_int32(x, &env->ucf64.fp_status));
target-unicore32/helper.c:    return float32_to_float64(x, &env->ucf64.fp_status);
target-unicore32/helper.c:    return float64_to_float32(x, &env->ucf64.fp_status);
target-unicore32/cpu.c:    env->features |= feature;
target-unicore32/cpu.c:    env->cp0.c0_cpuid = 0x40010863;
target-unicore32/cpu.c:    env->ucf64.xregs[UC32_UCF64_FPSCR] = 0;
target-unicore32/cpu.c:    env->cp0.c0_cachetype = 0x1dd20d2;
target-unicore32/cpu.c:    env->cp0.c1_sys = 0x00090078;
target-unicore32/cpu.c:    env->cp0.c0_cpuid = 0xffffffff;
target-unicore32/cpu.c:    env->cpu_model_str = object_get_typename(obj);
target-unicore32/cpu.c:    env->uncached_asr = ASR_MODE_USER;
target-unicore32/cpu.c:    env->regs[31] = 0;
target-unicore32/translate.c:    dc->singlestep_enabled = env->singlestep_enabled;
target-unicore32/translate.c:        if (unlikely(!QTAILQ_EMPTY(&env->breakpoints))) {
target-unicore32/translate.c:            QTAILQ_FOREACH(bp, &env->breakpoints, entry) {
target-unicore32/translate.c:             !env->singlestep_enabled &&
target-unicore32/translate.c:    if (unlikely(env->singlestep_enabled)) {
target-unicore32/translate.c:        cpu_fprintf(f, "R%02d=%08x", i, env->regs[i]);
target-unicore32/translate.c:        d.d = env->ucf64.regs[i];
target-unicore32/translate.c:    cpu_fprintf(f, "FPSCR: %08x\n", (int)env->ucf64.xregs[UC32_UCF64_FPSCR]);
target-unicore32/translate.c:    env->regs[31] = gen_opc_pc[pc_pos];
target-xtensa/op_helper.c:    if (xtensa_option_enabled(env->config, XTENSA_OPTION_UNALIGNED_EXCEPTION) &&
target-xtensa/op_helper.c:            !xtensa_option_enabled(env->config, XTENSA_OPTION_HW_ALIGNMENT)) {
target-xtensa/op_helper.c:                env->pc, LOAD_STORE_ALIGNMENT_CAUSE, addr);
target-xtensa/op_helper.c:            HELPER(exception_cause_vaddr)(env->pc, ret, vaddr);
target-xtensa/op_helper.c:    env->exception_index = excp;
target-xtensa/op_helper.c:    env->pc = pc;
target-xtensa/op_helper.c:    if (env->sregs[PS] & PS_EXCM) {
target-xtensa/op_helper.c:        if (env->config->ndepc) {
target-xtensa/op_helper.c:            env->sregs[DEPC] = pc;
target-xtensa/op_helper.c:            env->sregs[EPC1] = pc;
target-xtensa/op_helper.c:        env->sregs[EPC1] = pc;
target-xtensa/op_helper.c:        vector = (env->sregs[PS] & PS_UM) ? EXC_USER : EXC_KERNEL;
target-xtensa/op_helper.c:    env->sregs[EXCCAUSE] = cause;
target-xtensa/op_helper.c:    env->sregs[PS] |= PS_EXCM;
target-xtensa/op_helper.c:    env->sregs[EXCVADDR] = vaddr;
target-xtensa/op_helper.c:    if (xtensa_get_cintlevel(new_env) < new_env->config->debug_level) {
target-xtensa/op_helper.c:        HELPER(debug_exception)(env->pc, cause);
target-xtensa/op_helper.c:    unsigned level = env->config->debug_level;
target-xtensa/op_helper.c:    env->pc = pc;
target-xtensa/op_helper.c:    env->sregs[DEBUGCAUSE] = cause;
target-xtensa/op_helper.c:    env->sregs[EPC1 + level - 1] = pc;
target-xtensa/op_helper.c:    env->sregs[EPS2 + level - 2] = env->sregs[PS];
target-xtensa/op_helper.c:    env->sregs[PS] = (env->sregs[PS] & ~PS_INTLEVEL) | PS_EXCM |
target-xtensa/op_helper.c:    assert(phys < env->config->nareg);
target-xtensa/op_helper.c:    if (phys + n <= env->config->nareg) {
target-xtensa/op_helper.c:        memcpy(env->regs + window, env->phys_regs + phys,
target-xtensa/op_helper.c:        uint32_t n1 = env->config->nareg - phys;
target-xtensa/op_helper.c:        memcpy(env->regs + window, env->phys_regs + phys,
target-xtensa/op_helper.c:        memcpy(env->regs + window + n1, env->phys_regs,
target-xtensa/op_helper.c:    assert(phys < env->config->nareg);
target-xtensa/op_helper.c:    if (phys + n <= env->config->nareg) {
target-xtensa/op_helper.c:        memcpy(env->phys_regs + phys, env->regs + window,
target-xtensa/op_helper.c:        uint32_t n1 = env->config->nareg - phys;
target-xtensa/op_helper.c:        memcpy(env->phys_regs + phys, env->regs + window,
target-xtensa/op_helper.c:        memcpy(env->phys_regs, env->regs + window + n1,
target-xtensa/op_helper.c:    return a & (env->config->nareg / 4 - 1);
target-xtensa/op_helper.c:    copy_window_from_phys(env, 0, env->sregs[WINDOW_BASE] * 4, 16);
target-xtensa/op_helper.c:    copy_phys_from_window(env, env->sregs[WINDOW_BASE] * 4, 0, 16);
target-xtensa/op_helper.c:    env->sregs[WINDOW_BASE] = windowbase_bound(position, env);
target-xtensa/op_helper.c:    rotate_window_abs(env->sregs[WINDOW_BASE] + delta);
target-xtensa/op_helper.c:    int callinc = (env->sregs[PS] & PS_CALLINC) >> PS_CALLINC_SHIFT;
target-xtensa/op_helper.c:    if (s > 3 || ((env->sregs[PS] & (PS_WOE | PS_EXCM)) ^ PS_WOE) != 0) {
target-xtensa/op_helper.c:                pc, env->sregs[PS]);
target-xtensa/op_helper.c:        env->regs[(callinc << 2) | (s & 3)] = env->regs[s] - (imm << 3);
target-xtensa/op_helper.c:        env->sregs[WINDOW_START] |=
target-xtensa/op_helper.c:            windowstart_bit(env->sregs[WINDOW_BASE], env);
target-xtensa/op_helper.c:    uint32_t windowbase = windowbase_bound(env->sregs[WINDOW_BASE], env);
target-xtensa/op_helper.c:    uint32_t windowstart = env->sregs[WINDOW_START];
target-xtensa/op_helper.c:    if ((env->sregs[PS] & (PS_WOE | PS_EXCM)) ^ PS_WOE) {
target-xtensa/op_helper.c:    env->sregs[PS] = (env->sregs[PS] & ~PS_OWB) |
target-xtensa/op_helper.c:    env->sregs[EPC1] = env->pc = pc;
target-xtensa/op_helper.c:    int n = (env->regs[0] >> 30) & 0x3;
target-xtensa/op_helper.c:    uint32_t windowbase = windowbase_bound(env->sregs[WINDOW_BASE], env);
target-xtensa/op_helper.c:    uint32_t windowstart = env->sregs[WINDOW_START];
target-xtensa/op_helper.c:            ((env->sregs[PS] & (PS_WOE | PS_EXCM)) ^ PS_WOE) != 0) {
target-xtensa/op_helper.c:                pc, env->sregs[PS], m, n);
target-xtensa/op_helper.c:        ret_pc = (pc & 0xc0000000) | (env->regs[0] & 0x3fffffff);
target-xtensa/op_helper.c:        if (windowstart & windowstart_bit(env->sregs[WINDOW_BASE], env)) {
target-xtensa/op_helper.c:            env->sregs[WINDOW_START] &= ~windowstart_bit(owb, env);
target-xtensa/op_helper.c:            env->sregs[PS] = (env->sregs[PS] & ~PS_OWB) |
target-xtensa/op_helper.c:            env->sregs[EPC1] = env->pc = pc;
target-xtensa/op_helper.c:    rotate_window_abs((env->sregs[PS] & PS_OWB) >> PS_OWB_SHIFT);
target-xtensa/op_helper.c:    if ((env->sregs[WINDOW_START] &
target-xtensa/op_helper.c:            (windowstart_bit(env->sregs[WINDOW_BASE] - 3, env) |
target-xtensa/op_helper.c:             windowstart_bit(env->sregs[WINDOW_BASE] - 2, env) |
target-xtensa/op_helper.c:             windowstart_bit(env->sregs[WINDOW_BASE] - 1, env))) == 0) {
target-xtensa/op_helper.c:    if (env->sregs[LBEG] != v) {
target-xtensa/op_helper.c:        tb_invalidate_virtual_addr(env, env->sregs[LEND] - 1);
target-xtensa/op_helper.c:        env->sregs[LBEG] = v;
target-xtensa/op_helper.c:    if (env->sregs[LEND] != v) {
target-xtensa/op_helper.c:        tb_invalidate_virtual_addr(env, env->sregs[LEND] - 1);
target-xtensa/op_helper.c:        env->sregs[LEND] = v;
target-xtensa/op_helper.c:        tb_invalidate_virtual_addr(env, env->sregs[LEND] - 1);
target-xtensa/op_helper.c:    env->pc = pc;
target-xtensa/op_helper.c:    env->sregs[PS] = (env->sregs[PS] & ~PS_INTLEVEL) |
target-xtensa/op_helper.c:    if (env->pending_irq_level) {
target-xtensa/op_helper.c:    env->halt_clock = qemu_get_clock_ns(vm_clock);
target-xtensa/op_helper.c:    env->halted = 1;
target-xtensa/op_helper.c:    if (xtensa_option_enabled(env->config, XTENSA_OPTION_TIMER_INTERRUPT)) {
target-xtensa/op_helper.c:    if (v != env->sregs[RASID]) {
target-xtensa/op_helper.c:        env->sregs[RASID] = v;
target-xtensa/op_helper.c:    uint32_t tlbcfg = env->sregs[dtlb ? DTLBCFG : ITLBCFG];
target-xtensa/op_helper.c:    if (xtensa_option_enabled(env->config, XTENSA_OPTION_MMU)) {
target-xtensa/op_helper.c:            env->config->dtlb.varway56 :
target-xtensa/op_helper.c:            env->config->itlb.varway56;
target-xtensa/op_helper.c:                env->config->dtlb.nrefillentries :
target-xtensa/op_helper.c:                env->config->itlb.nrefillentries) == 32;
target-xtensa/op_helper.c:            env->config->dtlb.varway56 :
target-xtensa/op_helper.c:            env->config->itlb.varway56;
target-xtensa/op_helper.c:        env->config->dtlb.varway56 :
target-xtensa/op_helper.c:        env->config->itlb.varway56;
target-xtensa/op_helper.c:                env->config->dtlb.nrefillentries :
target-xtensa/op_helper.c:                env->config->itlb.nrefillentries) == 32;
target-xtensa/op_helper.c:    if (xtensa_option_enabled(env->config, XTENSA_OPTION_MMU)) {
target-xtensa/op_helper.c:    if (xtensa_option_enabled(env->config, XTENSA_OPTION_MMU)) {
target-xtensa/op_helper.c:    if (xtensa_option_enabled(env->config, XTENSA_OPTION_MMU)) {
target-xtensa/op_helper.c:    if (xtensa_option_enabled(env->config, XTENSA_OPTION_MMU)) {
target-xtensa/op_helper.c:            HELPER(exception_cause_vaddr)(env->pc, res, v);
target-xtensa/op_helper.c:    if (xtensa_option_enabled(env->config, XTENSA_OPTION_MMU)) {
target-xtensa/op_helper.c:            entry->asid = (env->sregs[RASID] >> ((pte >> 1) & 0x18)) & 0xff;
target-xtensa/op_helper.c:        if (xtensa_option_enabled(env->config,
target-xtensa/op_helper.c:    uint32_t change = v ^ env->sregs[IBREAKENABLE];
target-xtensa/op_helper.c:    for (i = 0; i < env->config->nibreak; ++i) {
target-xtensa/op_helper.c:            tb_invalidate_virtual_addr(env, env->sregs[IBREAKA + i]);
target-xtensa/op_helper.c:    env->sregs[IBREAKENABLE] = v & ((1 << env->config->nibreak) - 1);
target-xtensa/op_helper.c:    if (env->sregs[IBREAKENABLE] & (1 << i) && env->sregs[IBREAKA + i] != v) {
target-xtensa/op_helper.c:        tb_invalidate_virtual_addr(env, env->sregs[IBREAKA + i]);
target-xtensa/op_helper.c:    env->sregs[IBREAKA + i] = v;
target-xtensa/op_helper.c:    if (env->cpu_watchpoint[i]) {
target-xtensa/op_helper.c:        cpu_watchpoint_remove_by_ref(env, env->cpu_watchpoint[i]);
target-xtensa/op_helper.c:            flags, &env->cpu_watchpoint[i])) {
target-xtensa/op_helper.c:        env->cpu_watchpoint[i] = NULL;
target-xtensa/op_helper.c:    uint32_t dbreakc = env->sregs[DBREAKC + i];
target-xtensa/op_helper.c:            env->sregs[DBREAKA + i] != v) {
target-xtensa/op_helper.c:    env->sregs[DBREAKA + i] = v;
target-xtensa/op_helper.c:    if ((env->sregs[DBREAKC + i] ^ v) & (DBREAKC_SB_LB | DBREAKC_MASK)) {
target-xtensa/op_helper.c:            set_dbreak(i, env->sregs[DBREAKA + i], v);
target-xtensa/op_helper.c:            if (env->cpu_watchpoint[i]) {
target-xtensa/op_helper.c:                cpu_watchpoint_remove_by_ref(env, env->cpu_watchpoint[i]);
target-xtensa/op_helper.c:                env->cpu_watchpoint[i] = NULL;
target-xtensa/op_helper.c:    env->sregs[DBREAKC + i] = v;
target-xtensa/cpu.h:    int level = (env->sregs[PS] & PS_INTLEVEL) >> PS_INTLEVEL_SHIFT;
target-xtensa/cpu.h:    if ((env->sregs[PS] & PS_EXCM) && env->config->excm_level > level) {
target-xtensa/cpu.h:        level = env->config->excm_level;
target-xtensa/cpu.h:    if (xtensa_option_enabled(env->config, XTENSA_OPTION_MMU)) {
target-xtensa/cpu.h:        return (env->sregs[PS] & PS_RING) >> PS_RING_SHIFT;
target-xtensa/cpu.h:    if (xtensa_option_enabled(env->config, XTENSA_OPTION_MMU) &&
target-xtensa/cpu.h:            (env->sregs[PS] & PS_EXCM) == 0) {
target-xtensa/cpu.h:        return (env->sregs[PS] & PS_RING) >> PS_RING_SHIFT;
target-xtensa/cpu.h:        env->dtlb[wi] + ei :
target-xtensa/cpu.h:        env->itlb[wi] + ei;
target-xtensa/cpu.h:    *pc = env->pc;
target-xtensa/cpu.h:    if (env->sregs[PS] & PS_EXCM) {
target-xtensa/cpu.h:    if (xtensa_option_enabled(env->config, XTENSA_OPTION_EXTENDED_L32R) &&
target-xtensa/cpu.h:            (env->sregs[LITBASE] & 1)) {
target-xtensa/cpu.h:    if (xtensa_option_enabled(env->config, XTENSA_OPTION_DEBUG)) {
target-xtensa/cpu.h:        if (xtensa_get_cintlevel(env) < env->config->debug_level) {
target-xtensa/cpu.h:        if (xtensa_get_cintlevel(env) < env->sregs[ICOUNTLEVEL]) {
target-xtensa/cpu.h:    return env->pending_irq_level;
target-xtensa/cpu.h:    env->pc = tb->pc;
target-xtensa/helper.c:    for (i = 0; i < env->config->ndbreak; ++i) {
target-xtensa/helper.c:        if (env->cpu_watchpoint[i] &&
target-xtensa/helper.c:                env->cpu_watchpoint[i]->flags & BP_WATCHPOINT_HIT) {
target-xtensa/helper.c:    if (env->watchpoint_hit) {
target-xtensa/helper.c:        if (env->watchpoint_hit->flags & BP_CPU) {
target-xtensa/helper.c:            env->watchpoint_hit = NULL;
target-xtensa/helper.c:    env->config = config;
target-xtensa/helper.c:    if (xtensa_option_enabled(env->config,
target-xtensa/helper.c:        return vector - env->config->vecbase + env->sregs[VECBASE];
target-xtensa/helper.c:    int level = env->pending_irq_level;
target-xtensa/helper.c:            level <= env->config->nlevel &&
target-xtensa/helper.c:            (env->config->level_mask[level] &
target-xtensa/helper.c:             env->sregs[INTSET] &
target-xtensa/helper.c:             env->sregs[INTENABLE])) {
target-xtensa/helper.c:            env->sregs[EPC1 + level - 1] = env->pc;
target-xtensa/helper.c:            env->sregs[EPS2 + level - 2] = env->sregs[PS];
target-xtensa/helper.c:            env->sregs[PS] =
target-xtensa/helper.c:                (env->sregs[PS] & ~PS_INTLEVEL) | level | PS_EXCM;
target-xtensa/helper.c:            env->pc = relocated_vector(env,
target-xtensa/helper.c:                    env->config->interrupt_vector[level]);
target-xtensa/helper.c:            env->sregs[EXCCAUSE] = LEVEL1_INTERRUPT_CAUSE;
target-xtensa/helper.c:            if (env->sregs[PS] & PS_EXCM) {
target-xtensa/helper.c:                if (env->config->ndepc) {
target-xtensa/helper.c:                    env->sregs[DEPC] = env->pc;
target-xtensa/helper.c:                    env->sregs[EPC1] = env->pc;
target-xtensa/helper.c:                env->exception_index = EXC_DOUBLE;
target-xtensa/helper.c:                env->sregs[EPC1] = env->pc;
target-xtensa/helper.c:                env->exception_index =
target-xtensa/helper.c:                    (env->sregs[PS] & PS_UM) ? EXC_USER : EXC_KERNEL;
target-xtensa/helper.c:            env->sregs[PS] |= PS_EXCM;
target-xtensa/helper.c:        env->exception_taken = 1;
target-xtensa/helper.c:    if (env->exception_index == EXC_IRQ) {
target-xtensa/helper.c:                __func__, env->pending_irq_level, xtensa_get_cintlevel(env),
target-xtensa/helper.c:                env->pc, env->regs[0], env->sregs[PS],
target-xtensa/helper.c:                env->sregs[INTSET], env->sregs[INTENABLE],
target-xtensa/helper.c:                env->sregs[CCOUNT]);
target-xtensa/helper.c:    switch (env->exception_index) {
target-xtensa/helper.c:                __func__, env->exception_index,
target-xtensa/helper.c:                env->pc, env->regs[0], env->sregs[PS], env->sregs[CCOUNT]);
target-xtensa/helper.c:        if (env->config->exception_vector[env->exception_index]) {
target-xtensa/helper.c:            env->pc = relocated_vector(env,
target-xtensa/helper.c:                    env->config->exception_vector[env->exception_index]);
target-xtensa/helper.c:            env->exception_taken = 1;
target-xtensa/helper.c:                    __func__, env->pc, env->exception_index);
target-xtensa/helper.c:                __func__, env->pc, env->exception_index);
target-xtensa/helper.c:    if (xtensa_option_enabled(env->config, XTENSA_OPTION_MMU)) {
target-xtensa/helper.c:        env->sregs[RASID] = 0x04030201;
target-xtensa/helper.c:        env->sregs[ITLBCFG] = 0;
target-xtensa/helper.c:        env->sregs[DTLBCFG] = 0;
target-xtensa/helper.c:        env->autorefill_idx = 0;
target-xtensa/helper.c:        reset_tlb_mmu_all_ways(env, &env->config->itlb, env->itlb);
target-xtensa/helper.c:        reset_tlb_mmu_all_ways(env, &env->config->dtlb, env->dtlb);
target-xtensa/helper.c:        reset_tlb_mmu_ways56(env, &env->config->itlb, env->itlb);
target-xtensa/helper.c:        reset_tlb_mmu_ways56(env, &env->config->dtlb, env->dtlb);
target-xtensa/helper.c:        reset_tlb_region_way0(env, env->itlb);
target-xtensa/helper.c:        reset_tlb_region_way0(env, env->dtlb);
target-xtensa/helper.c:        if (((env->sregs[RASID] >> i * 8) & 0xff) == asid) {
target-xtensa/helper.c:        &env->config->dtlb : &env->config->itlb;
target-xtensa/helper.c:        env->dtlb : env->itlb;
target-xtensa/helper.c:            (mmu_idx != 0 || ((vaddr ^ env->sregs[PTEVADDR]) & 0xffc00000)) &&
target-xtensa/helper.c:        (env->sregs[PTEVADDR] | (vaddr >> 10)) & 0xfffffffc;
target-xtensa/helper.c:        *wi = (++env->autorefill_idx) & 0x3;
target-xtensa/helper.c:    if (xtensa_option_enabled(env->config, XTENSA_OPTION_MMU)) {
target-xtensa/helper.c:    } else if (xtensa_option_bits_enabled(env->config,
target-xtensa/helper.c:        dtlb ? &env->config->dtlb : &env->config->itlb;
target-xtensa/helper.c:        xtensa_option_enabled(env->config, XTENSA_OPTION_MMU) ?
target-xtensa/helper.c:    if (xtensa_option_bits_enabled(env->config,
target-xtensa/cpu.c:    env->exception_taken = 0;
target-xtensa/cpu.c:    env->pc = env->config->exception_vector[EXC_RESET];
target-xtensa/cpu.c:    env->sregs[LITBASE] &= ~1;
target-xtensa/cpu.c:    env->sregs[PS] = xtensa_option_enabled(env->config,
target-xtensa/cpu.c:    env->sregs[VECBASE] = env->config->vecbase;
target-xtensa/cpu.c:    env->sregs[IBREAKENABLE] = 0;
target-xtensa/cpu.c:    env->pending_irq_level = 0;
target-xtensa/translate.c:    if (unlikely(!QTAILQ_EMPTY(&env->breakpoints))) {
target-xtensa/translate.c:        QTAILQ_FOREACH(bp, &env->breakpoints, entry) {
target-xtensa/translate.c:        if ((env->sregs[IBREAKENABLE] & (1 << i)) &&
target-xtensa/translate.c:                env->sregs[IBREAKA + i] == dc->pc) {
target-xtensa/translate.c:    dc.config = env->config;
target-xtensa/translate.c:    dc.singlestep_enabled = env->singlestep_enabled;
target-xtensa/translate.c:    dc.lbeg = env->sregs[LBEG];
target-xtensa/translate.c:    dc.lend = env->sregs[LEND];
target-xtensa/translate.c:    if (env->singlestep_enabled && env->exception_taken) {
target-xtensa/translate.c:        env->exception_taken = 0;
target-xtensa/translate.c:        if (env->singlestep_enabled) {
target-xtensa/translate.c:    cpu_fprintf(f, "PC=%08x\n\n", env->pc);
target-xtensa/translate.c:            cpu_fprintf(f, "%s=%08x%c", sregnames[i], env->sregs[i],
target-xtensa/translate.c:            cpu_fprintf(f, "%s=%08x%c", uregnames[i], env->uregs[i],
target-xtensa/translate.c:        cpu_fprintf(f, "A%02d=%08x%c", i, env->regs[i],
target-xtensa/translate.c:    for (i = 0; i < env->config->nareg; ++i) {
target-xtensa/translate.c:        cpu_fprintf(f, "AR%02d=%08x%c", i, env->phys_regs[i],
target-xtensa/translate.c:    env->pc = gen_opc_pc[pc_pos];
tcg/ppc64/tcg-target.c:    /* r0 now contains &env->tlb_table[mem_index][index].addr_read */
tcg/ppc64/tcg-target.c:    /* r0 = env->tlb_table[mem_index][index].addend */
tcg/ppc64/tcg-target.c:    /* r0 = env->tlb_table[mem_index][index].addend + addr */
tcg/ppc64/tcg-target.c:    /* r0 = env->tlb_table[mem_index][index].addend */
tcg/ppc64/tcg-target.c:    /* r0 = env->tlb_table[mem_index][index].addend + addr */
tcg/ppc/tcg-target.c:    /* r0 now contains &env->tlb_table[mem_index][index].addr_read */
tcg/ppc/tcg-target.c:    /* r0 = env->tlb_table[mem_index][index].addend */
tcg/ppc/tcg-target.c:    /* r0 = env->tlb_table[mem_index][index].addend + addr */
tcg/ppc/tcg-target.c:    /* r0 = env->tlb_table[mem_index][index].addend */
tcg/ppc/tcg-target.c:    /* r0 = env->tlb_table[mem_index][index].addend + addr */
translate-all.c:        env->icount_decr.u16.low += tb->icount;
translate-all.c:        env->can_do_io = 0;
translate-all.c:    env->icount_decr.u16.low -= gen_opc_icount[j];
user-exec.c:    env->exception_index = -1;
user-exec.c:    longjmp(env->jmp_env, 1);
xen-all.c:    env->halted = 1;
xtensa-semi.c:    uint32_t *regs = env->regs;
